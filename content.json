{"pages":[{"title":"分类","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"ACwing 94 95 96 解题报告","text":"题目链接：递归实现指数型枚举 递归实现组合型枚举 递归实现排列型枚举 题目描述：指数型：在 $1-n$ 这 $n$ 个整数中随机选取任意多个，输出所有可能的次序。 组合型：从 $1- n$ 这 $n$ 个整数中随机选出 $m$ 个，输出所有可能的选择方案。 排列型：把 $1-n$ 这 $n$ 个整数排成一行后随机打乱顺序，输出所有可能的次序。 解题思路：这三题的思路大致一致，所以放在一起来写。 指数型：很明显，这个问题可以转化成： 有 $n$ 个整数，每个整数可以选可以不选，求总共有几种方案。 我们可以使用递归来求解问题，每次递归时，我们有两条路：“选”，”不选” 放在代码里就是这样： 12345v.push_back(p);//选择这个数calc(x+1);//选择这个数的分支v.pop_back();//还原现场calc(x+1);//不选这个数的分支 而每次递归后，我们面对的问题规模（还剩几个数需要选）-1，变成一个规模更小的问题，所以可以用递归求解。 组合型：这个问题和上一个本质一样，我们只要加入更多的限制条件： 当当前选取的数数量大于 $m$ 时，不再选数。 当剩下的数全选也不够 $m$ 时，不再选数。 放在代码里就是这样： 1if (v.size() &gt; m || v.size + (n-x+1) &lt; m) return ; 排列性：这里，我们的问题就变成了： 把 $n$ 个整数按照任意次序排列 递归中，我们每次选取一个数放在当前位置，问题就变成了：把 $n-1$ 个整数按照任意次序排列，所以可以用递归来做 放在代码里就是这样： 12345678for (int i = 1;i &lt;= n;++i) { if (!chos[i]) { ord[x] = i; chos[i] = 1; calc(x+1); chos[i] = 1; } } 代码： 指数型： 12345678910111213141516171819202122int x;vector &lt;int&gt; chosen;void choice(int n) { if (n == x+1) { fp(i,0,chosen.size()) { printf(\"%d \",chosen[i]); } printf(\"\\n\"); return ; } choice(n+1); chosen.push_back(n); choice(n+1); chosen.pop_back();}int main() { x = read(); choice(1); return 0;} 组合型： 12345678910111213141516171819202122232425262728std::vector&lt;int&gt; v;int n,m;void c(int x) { if (v.size() == m) { for (size_t i = 0;i &lt; v.size();++i) { printf(\"%d \",v[i]); } puts(\"\"); return ; } if (v.size() &gt; m || v.size() + (n - x + 1) &lt; m) {//判断边界，第一个是判断当前是否大于m个了，第二个判断是否选不够 return ; } v.push_back(x); c(x+1); v.pop_back(); c(x+1);}signed main() { n = read(),m = read(); c(1); return 0;} 排列型： 1234567891011121314151617181920212223242526int n,ord[10];bool chos[10];void calc(int x) { if (x == n+1) { for (int i = 1;i &lt;= n;++i) { printf(\"%d \",ord[i]); } puts(\"\"); return ; } for (int i = 1;i &lt;= n;++i) { if (!chos[i]) { ord[x] = i; chos[i] = 1; calc(x+1); chos[i] = 1; } }}signed main() { n = read(); calc(1); return 0;}","link":"/2020/04/06/ACwing-%E6%8E%92%E5%88%97/"},{"title":"CodeForcesRound#1206题解","text":"##A. Choose Two Numbers 题目描述：给你两个集合 $A,B$, 要求你分别从$A,B$中取出一个数，使得两数之和不在$A$中也不在$B$中 $n ,m\\leq 100$ 解题思路：看数据范围应该很容易想出来一个 $O(nm(n+m))$ 的暴力，枚举 $A,B$ 中的每一个数，将他们相加之后再在两个集合中判定一下，这个题就完了。事实上由于$n ,m\\leq 100$ 可以轻松通过本题。 但是显然，还会有更好的解法，我们可以观察到，如果选取这两个集合中最大的数相加，显然这个和不会出现在两个集合里面，复杂度下降到了 $O(m \\log {m} + n \\log {n}) $ 如果用排序还可以达到$O(m+n)$的线性时间复杂度(排序是作者给出的解法，实际上可以直接读入的时候求出) 代码： $O(nm(n+m))$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;cctype&gt;inline int read() { char v = getchar();int x = 0,f = 1; while (!isdigit(v)) {if(v == '-')f = -1;v = getchar();} while (isdigit(v)) {x = x * 10 + v - 48;v = getchar();} return x * f;}const int N = 110;int a[N],b[N],n,m,a1,a2;int main() { n = read(); for (int i = 1;i &lt;= n;++i) { a[i] = read(); } m = read(); for (int i = 1;i &lt;= m;++i) { b[i] = read(); } for (int i = 1;i &lt;= n;++i) { for (int j = 1;j &lt;= m;++j) { a1 = a[i],a2 = b[j]; int sum = a1 + a2;bool flag = 0; for (int k = 1;k &lt;= n;++k) { if (sum == a[k]) { flag = 1; break; } } for (int k = 1;k &lt;= m;++k) { if (sum == b[k]) { flag = 1; break; } } if (!flag) { printf(\"%d %d\\n\",a1,a2); return 0; } } } return 0;} $O(m + n) $ 12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;using std::max;inline int read() { char v = getchar();int x = 0,f = 1; while (!isdigit(v)) {if(v == '-')f = -1;v = getchar();} while (isdigit(v)) {x = x * 10 + v - 48;v = getchar();} return x * f;}const int N = 110;int tmp,a,b;int main() { n = read(); for (int i = 1;i &lt;= n;++i) { tmp = read(); a = max(a,tmp); } m = read(); for (int i = 1;i &lt;= m;++i) { tmp = read(); b = max(b,tmp); } printf(\"%d %d\",a,b); return 0;} ##B. Make Product Equal One 题目描述：给你一个有 $n$ 个数字的数列，你有两种操作：将某个数 $+1$ 或 $-1$ 。求用最小的操作次数让这个数列的每一项乘起来等于 1 $n \\leq 10^5$ 解题思路：用C换来的 分析一下，每个数字只有两种情况：变成 1 或者变成 -1 所以每个数字的代价就是min(abs(1 - a[i]),abs(-1 - a[i])) 值得一提的几个大坑点是，最后可能会变成 -1 ，所以顺便记一下，如果最后变成 -1 了记得加上 2 。而且 0 也要记，最后要加上 0 的个数。 时间复杂度$O(n)$ 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;#define int long longinline int read() { char v = getchar();int x = 0,f = 1; while (!isdigit(v)) {if(v == '-')f = -1;v = getchar();} while (isdigit(v)) {x = x * 10 + v - 48;v = getchar();} return x * f;}const int N = 100010;int pre[N],n,p1,p2,ans,z,res = 1;signed main() { n = read(); for (int i = 1;i &lt;= n;++i) { pre[i] = read(); if (pre[i] == 0) { z++; } } sort(pre+1,pre+1+n); for (int i = 1;i &lt;= n;++i) { if (pre[i] &lt;= -1) { ans += (-1 - pre[i]); res *= -1; } else if (pre[i] &gt;= 1) { ans += (pre[i] - 1); res *= 1; } } if (res == -1) { if (z) { ans += z; } else { ans += 2; } } else { ans += z; } cout &lt;&lt; ans; return 0;} C. Almost Equal题目描述：给定一个数字 $n$ ，要求你使用 $1…2*n$ 的数字构造出一个环，使得这个环每三个数相加的和之间差不超过 1. 解题思路：偶数显然不能构造，奇数按照样例构造即可，具体看代码 代码：123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using std::min;inline int read() { char v = getchar();int x = 0,f = 1; while (!isdigit(v)) {if(v == '-')f = -1;v = getchar();} while (isdigit(v)) {x = x * 10 + v - 48;v = getchar();} return x * f;}const int N = 200010;int pre[N],n,now = 1;int main() { n = read(); if (n % 2 == 0) { printf(\"NO\"); return 0; } for (int i = 1;i &lt;= 2*n;++i) { pre[now] = i; if (i % 2 == 0) { now += 1; } else { if ((i / 2) % 2) { now -= n; } else { now += n; } } } printf(\"YES\\n\"); for (int i = 1;i &lt;= 2*n;++i) { printf(\"%d \",pre[i]); } return 0;} D. Shortest Circle题目描述：给你 $n$ 个点，每个点有一个点权，两点之间有边当且仅当 $a[i] &amp; a[j] \\ne 0$ ，求出图中最小环的长度。 $n \\leq 100000,a_i \\leq 10^{18}$ 解题思路：直接构造显然是 $O(n^2)$ 的，考虑优化建边的过程。 首先可以观察到，如果二进制内某一位有 3 个 1 ，那么肯定有一个长度为 3 的环，直接输出即可。 那么现在问题简化为了每位至多有两个 1 的情况，我们可以发现每一位最多只有一条边，所以整张图其实至多剩下 60 条边了！接下来直接跑一遍最小环即可，我使用的是 Floyd . 注意开 long long 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cctype&gt;#define min(a,b) ((a) &lt; (b) ? (a) : (b))#define int long longconst int N = 100010;const int M = 130; inline int read() { char v = getchar();int x = 0,f = 1; while (!isdigit(v)) {if (v == '-')f = -1;v = getchar();} while (isdigit(v)) {x = x * 10 + v - 48;v = getchar();} return x * f;} int a[N],pre[N],f[M][M],n,cnt,dis[M][M],ans = 0x3f3f3f3f;signed main() { n = read(); for (int i = 1;i &lt;= n;++i) { a[i] = read(); if (a[i] != 0) pre[++cnt] = a[i]; } for (int i = 1;i &lt;= 64;++i) { int cnt = 0; for (int j = 1;j &lt;= n;++j) { if (a[j]&gt;&gt;(i-1)&amp;1) { cnt++; } } if (cnt &gt;= 3) { printf(\"3\"); return 0; } } for (int i = 1;i &lt;= cnt;++i) { for (int j = 1;j &lt;= cnt;++j) { if (i != j &amp;&amp; (pre[i] &amp; pre[j]) != 0) { f[i][j] = 1;dis[i][j] = 1; } else { f[i][j] = dis[i][j] = 0x3f3f3f3f; } } } for (int k = 1;k &lt;= cnt;++k) { for (int i = 1;i &lt; k;++i) { for (int j = i+1;j &lt; k;++j) { ans = min(dis[i][j] + f[i][k] + f[k][j],ans); } } for (int i = 1;i &lt;= cnt;++i) { for (int j = 1;j &lt;= cnt;++j) { dis[i][j] = min(dis[i][k]+dis[k][j],dis[i][j]); } } } printf(\"%d\\n\",((ans&gt;=0x3f3f3f3f) ? -1 : ans));}","link":"/2019/08/22/CodeForcesRound-1206%E9%A2%98%E8%A7%A3/"},{"title":"Codeforces55D-Beautiful Numbers  解题报告","text":"题目链接Codeforces55D-Beautiful Numbers 题意简述定义“美丽的数字”为：被它自己的每一位数上的数整除的数 给定区间[L,R]，求有多少个美丽的数字 思路显然的数位DP，简单拉个板子就写完了.但是定义状态的时候发现会存不下，我们考虑压缩一下他们的状态。 引入两条重要的性质： 如果一个数能整除它的所有数位上的数，那么它一定能整除所有这些数位上的数的最小公倍数 而$1$到$9$的最小公倍数是$2520$，所有数可能形成的数位上所有数的最小公倍数一定是$2520$的因数 因为$lcm(1,2,3,4,5,6,7,8,9) = 2520$，所以直接定义$dp[i][j][k]$为前$i$位数$mod$$ 2520 = j$，前$i$位数的$lcm$为$j$。 然而，这样设计状态出来会发现总状态数达到了$2025202520 = 127008000$，显然存不下，我们再次考虑进行优化。观察到第二维还是会有冗余，手打个表可以发现总共只有48种可能性，再次进行压缩。 根据性质1，如果最后的数能整除$k$，那么它一定能整除它各位数字的最小公倍数。由于性质2，所有可能出现的$k$都是$2520$的因数，借助这一性质，将$j$取模$2520$，若所得的结果整除$k$，那么原来的数也一定整除$k$。所以转移方程就很自然的出来了： $f[i][j][k] = \\sum f[i][lcm(k,x)][j*10+x \\mod 2520|1 \\leq x\\leq Maxx]$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#define ll long long#define FILE A#define N 2520 + 1#define M 200inline ll read() { char v = getchar();ll x = 0,f = 1; while (!isdigit(v)) {if (v == '-'){f = -1;}v = getchar();} while (isdigit(v)) {x = x * 10 + v - 48;v = getchar();} return x * f;}ll dp[20][50][N],dig[N],ind[N],cnt,mod,num[N],l,r,c;ll gcd(int a,int b){return b?gcd(b,a%b):a;}ll mylcm(int a,int b){return a/gcd(a,b)*b;}ll dfs(ll now,ll lcm,ll sum,int limit) { if (!now) { return sum % lcm == 0; } if (!limit &amp;&amp; dp[now][num[lcm]][sum] != -1) return dp[now][num[lcm]][sum]; ll ans = 0,ret = (limit)?dig[now]:9; for (ll i = 0;i &lt;= ret;++i) { int lcm1 = i ? mylcm(lcm,i) : lcm; int sum1 = (sum * 10 + i) % mod; ans += dfs(now-1,lcm1,sum1,limit&amp;&amp;i==ret); } if (!limit) { dp[now][num[lcm]][sum] = ans; } return ans;}ll work(ll x) { int len = 0; while (x) { dig[++len] = x % 10;x /= 10; } return dfs(len,1,0,1);}int main() { memset(dp,-1,sizeof(dp)); int T = read(); mod = 2520; for (int i = 1;i &lt;= mod;++i) { if (mod % i == 0) { num[i] = cnt++; } } while (T--) { ll l = read(),r = read(); printf(\"%lld\\n\",work(r) - work(l-1)); } return 0;}","link":"/2019/08/13/Codeforces55D-Beautiful%20Numbers%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"},{"title":"Luogu1840 Color the Axis_NOI导刊2011提高（05） 解题报告","text":"题目链接：Color the Axis_NOI导刊2011提高（05） 题目描述：在一条数轴上有$N$个点，分别是$1 \\rightarrow N$。一开始所有的点都被染成黑色。接着我们进行$M$次操作，第$i$次操作将$[L_i,R_i]$这些点染成白色。请输出每个操作执行后剩余黑色点的个数。 解题思路：这个题的思路很简单，把黑色的部分当成1，白色的部分当成0来处理，使用支持区间修改，区间查询的数据结构维护一下即可。 如果你和我一样是写线段树的，那么更简单了，在下传lazytag的时候只需要将其的左右节点清零即可。 另外在区间查询时由于每次都是查整段的，所以只需要输出tree[1].num即可 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;using namespace std;const int N = 200010;const int M = 500010&lt;&lt;1;inline int read() { int x = 0,f = 1;char v = getchar(); while (!isdigit(v)) {if (v =='-') f = -1;v = getchar();} while (isdigit(v)) {x = x * 10 + v - 48;v = getchar();} return x * f;}struct node { int l,r,num,tag;}tree[N&lt;&lt;2];inline void build(int p,int l,int r) { tree[p].l = l;tree[p].r = r; if (l == r) { tree[p].num = 1; return ; } int mid = (l + r) &gt;&gt; 1; build (p &lt;&lt; 1,l,mid); build (p &lt;&lt; 1 | 1,mid + 1,r); tree[p].num = tree[p&lt;&lt;1].num + tree[p &lt;&lt; 1 | 1].num; return;} inline void spread(int p) { if (!tree[p].num) { tree[p&lt;&lt;1].num = tree[p&lt;&lt;1|1].num = 0; }}inline void change (int p,int x,int y) { if (tree[p].l &gt;= x &amp;&amp; tree[p].r &lt;= y) { tree[p].num = 0; return ; } spread(p); int mid = (tree[p].l + tree[p].r) &gt;&gt; 1; if (mid &gt;= x) change(p&lt;&lt;1,x,y); if (mid &lt; y) change(p&lt;&lt;1|1,x,y); tree[p].num = tree[p&lt;&lt;1].num + tree[p&lt;&lt;1|1].num; return ;}int main() { int n = read(),m = read(); build (1,1,n); for (int i = 1;i &lt;= m;++i) { int x = read(),y = read(); change(1,x,y); printf(\"%d\\n\",tree[1].num); } return 0;}","link":"/2019/09/22/ColortheAxis/"},{"title":"Luogu P2194 HXY烧情侣 解题报告","text":"题目链接：P2194 HXY烧情侣 题目描述：众所周知，HXY已经加入了FFF团。现在她要开始喜（sang）闻（xin）乐（bing）见（kuang）地烧情侣了。这里有n座电影院，n对情侣分别在每座电影院里，然后电影院里都有汽油，但是要使用它需要一定的费用。m条单向通道连接相邻的两对情侣所在电影院。然后HXY有个绝技，如果她能从一个点开始烧，最后回到这个点，那么烧这条回路上的情侣的费用只需要该点的汽油费即可。并且每对情侣只需烧一遍，电影院可以重复去。然后她想花尽可能少的费用烧掉所有的情侣。问最少需要多少费用，并且当费用最少时的方案数是多少？由于方案数可能过大，所以请输出方案数对1e9+7取模的结果。 （注：这里HXY每次可以从任何一个点开始走回路。就是说一个回路走完了，下一个开始位置可以任选。所以说不存在烧不了所有情侣的情况，即使图不连通，HXY自行选择顶点进行烧情侣行动。且走过的道路可以重复走。） 解题思路：题目中写的很清楚，这题直接套一个 Tarjan 就完了 现在讨论一下两个问题： 最少需要多少费用 这个比较好想，只要将缩点后的每个 SCC 权值变成其中点权最小的即可 总共有多少方案 这个比较难想，但是我们可以结合一下乘法原理的思想，将每个 SCC 中的点权等于 SCC 的点权的个数相乘 可能有点绕口，我们用形式化的语言来描述一下 记 $siz_i$ 为 $SCC_i$ 中点权最小的权值， $num_i$ 为 $SCC_i$ 中点权等于最小点权的权值的点，$cnt$ 为 SCC 数量 则有 $$ans_1 = \\sum^{cnt}_{i=1}siz[i]$$ $$ans_2 = \\prod^{cnt}_{i=1}num_i$$ 便可写出代码 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;stack&gt;using std::stack;#define long long ll#define register int richar buf[1&lt;&lt;21],*p1=buf,*p2=buf;inline int gc(){return p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++;}inline int read() { char v = gc();int x = 0,f = 1; while (!isdigit(v)) {if (v == '-')f = -1;v = gc();} while (isdigit(v)) {x = x * 10 + v - 48;v = gc();} return x * f;}const int N = 100001;const int M = 500001;const int INF = 0x3f3f3f3f;int to[M],hd[N],nxt[M],tot;inline void add(int u,int v) {to[++tot] = v;nxt[tot] = hd[u];hd[u] = tot;}inline void addedge(int u,int v) {add(u,v),add(v,u);}template &lt;typename T&gt; inline T min(T x,T y) {return x&lt;y?x:y;}template &lt;typename T&gt; inline T max(T x,T y) {return x&gt;y?x:y;}int dfn[N],low[N],c[N],cnt,num,siz[N],p[N],pre[N],ins[N],n,m,ans1,ans2 = 1;stack &lt;int&gt; s;void tarjan(int x) { dfn[x] = low[x] = ++cnt; s.push(x);ins[x] = 1; for (int i = hd[x];i;i = nxt[i]) { if (!dfn[to[i]]) { tarjan(to[i]); low[x] = min(low[x],low[to[i]]); } else if (ins[to[i]]) { low[x] = min(low[x],dfn[to[i]]); } } if (dfn[x] == low[x]) { int y;c[x] = ++num; do { y = s.top();c[y] = num;ins[y] = 0;s.pop(); if (pre[y] &lt; p[num]) { p[num] = pre[y]; siz[num] = 1; } else if (pre[y] == p[num]) { ++siz[num]; } }while (x != y); }}signed main() { memset(p,INF,sizeof(p)); n = read(); for (int i = 1;i &lt;= n;++i) pre[i] = read(); m = read(); for (int i = 1;i &lt;= m;++i) { int x = read(),y = read();add(x,y); } for (int i = 1;i &lt;= n;++i) { if (!dfn[i]) tarjan(i); } for (int i = 1;i &lt;= num;++i) { ans1 += p[i];ans2 *= siz[i]; } printf(\"%d %d\",ans1,ans2); return 0;}","link":"/2019/10/11/Hxyburncp/"},{"title":"Luogu P3469 [POI2008]BLO-Blockade 解题报告","text":"题目链接：[POI2008]BLO-Blockade 题目描述：有 $n$ 个节点的无向图，定义封锁一个点为切断这个点的所有连边。求每个节点被封锁后图内的不连通有序点对个数。 解题思路：Tarjan。 首先分类讨论一下，封锁一个点有两种情况： 不是割点 这种情况好搞，从图中显然可以看出只有自己和其他 $n - 1 $ 个节点不连通，因为是有序节点，所以答案为 $2 \\times (n-1)$ 是割点 这种情况就有意思了。 我们可以发现，如果点 i 为割点，显然去掉这个点之后整个图会变成几个联通块，如下图： 这种情况我们也很好发现，把联通块的大小两两相乘可得答案。 记第 i 个联通块为$s_i$ 但是把联通块大小两两相乘的复杂度为 $O(n^2)$ 不能接受，我们可以在 dfs 时把搜索树子树大小算出来，记为 $siz[i]$ 最后的答案即为： $(n - 1 - \\sum_{i=1}^{t}siz[s_k])*(1+\\sum_{i=1}^{t}siz[s_k])$ 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;const int M = 500010&lt;&lt;1;inline int read() { int x = 0,f = 1;char v = getchar(); while (!isdigit(v)) {if (v =='-') f = -1;v = getchar();} while (isdigit(v)) {x = x * 10 + v - 48;v = getchar();} return x * f;}int nxt[M],hd[N],to[M],tot = 1,cnt,dfn[N],low[N],siz[N],n,m;long long ans[N];bool cut[N];inline void adde(int u,int v) { to[++tot] = v;nxt[tot] = hd[u];hd[u] = tot;}inline void addedge(int u,int v) { adde(u,v);adde(v,u);}void tarjan(int x) { dfn[x] = low[x] = ++cnt; siz[x] = 1; int flag = 0,sum = 0; for (int i = hd[x];i;i = nxt[i]) { int v = to[i]; if (!dfn[v]) { tarjan(v); low[x] = min(low[x],low[v]); siz[x] += siz[v]; if (low[v] &gt;= dfn[x]) { flag++; ans[x] += (long long)siz[v]*(n - siz[v]); sum += siz[v]; if (x != 1 || flag &gt; 1) { cut[x] = 1; } } } else { low[x] = min(low[x],dfn[v]); } } if (cut[x]) { ans[x] += (long long)(n - sum - 1) * (sum + 1) + (n - 1); } else { ans[x] = 2*(n-1); }}int main() { n = read(),m = read(); for (int i = 1;i &lt;= m;++i) { int x = read(),y = read(); if (x == y) { continue; } addedge(x,y); } tarjan(1); for (int i = 1;i &lt;= n;++i) { printf(&quot;%lld\\n&quot;,ans[i]); } return 0;} 参考：部分思路来自于lyd的《算法竞赛进阶指南》","link":"/2019/09/08/Luogu%20P3469%20%5BPOI2008%5DBLO-Blockade%20%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"},{"title":"Luogu P4999 烦人的数学作业 解题报告","text":"题目链接：P4999 烦人的数学作业 题目描述：给出一个区间$L - R$，求$L$到$R$区间内每个数的数字和，如123这个数的数字和为1+2+3=6 有T组数据，结果$\\mod 10^9+7$ $（1 \\leq L \\leq R \\leq 10^18）$ 解题思路：确实烦人 第一眼看上去跟[ZJOI2010]数字计数很像，确实是，把那个题的数位DP抄过来乘个 i 这题就没了。 那为啥要写这个题解呢？因为这个题坑多。 注意开 long long 取模很坑，请使用传统技巧(ans % mod + mod) % mod，正确性证明应该不用多说 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#define int long long const int N = 20;const int mod = 1e9+7;const int M = N &lt;&lt; 1;inline int read() { char v = getchar();int x = 0,f = 1; while (!isdigit(v)) {if (v == '-')f = -1;v = getchar();} while (isdigit(v)) {x = x * 10 + v - 48;v = getchar();} return x * f;}int num[N],dp[N][N],l,r;int dfs(int pos,bool limit,bool zer,int dig,int sum) { int ans = 0; if (pos == 0) { return sum; } if (!limit &amp;&amp; dp[pos][sum]) return dp[pos][sum]; int up = 9; if (limit) up = num[pos]; for (int j = 0;j &lt;= up;++j) { ans += dfs(pos-1,(j==up)&amp;&amp;limit,zer||j,dig,sum+((j||zer)&amp;&amp;(j==dig))); } if (!limit&amp;&amp;zer){ dp[pos][sum] = ans; } return ans;}int work(int p,int w) { memset(dp,0,sizeof(dp)); int len = 0; while (p) { num[++len] = p % 10; p /= 10; } return dfs(len,1,0,w,0) % mod;} signed main() { int T = read(); while (T--) { int ans = 0; l = read(),r = read(); for (int i = 0;i &lt;= 9;++i) { ans += ((work(r,i) - work(l-1,i) % mod) * i) % mod; } printf(\"%lld\\n\",(ans%mod+mod)%mod); } return 0;}","link":"/2019/09/07/Luogu%20P4999%20%E7%83%A6%E4%BA%BA%E7%9A%84%E6%95%B0%E5%AD%A6%E4%BD%9C%E4%B8%9A%20%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"},{"title":"Luogu 1417 烹调方案 解题报告","text":"题目链接：烹调方案 题目描述：一共有$n$件食材，每件食材有三个属性， $a_i$ ， $b_i$ 和 $c_i$ ，如果在 $t$ 时刻完成第 $i$ 样食材则得到 $a_i-t*b_i$ 的美味指数，用第 $i$ 件食材做饭要花去 $c_i$ 的时间。 在 $T$ 时间内设计烹调方案使得美味指数最大 解题思路：显然是一个01背包，但是，当你写完01背包板子交上去以后会发现只有30分。 题目中给了一个条件：在 $t$ 时刻完成第 $i$ 样食材则得到 $a_i-t*b_i$ 的美味指数，有了这个条件，显然我们要对每个物品选择的先后性进行讨论了。 设 $a_1,b_1,c_1$ 为第一组物品，$a_2,b_2,c_2$ 为第二组物品， $t$为当前时间. 将两个物品可获得的值表示出来为： $$m_1 = a_1-(t \\times c_1) \\times b_1 + a_2 - (t+c_1+c_2) \\times b_2$$ $$m_2 = a_2-(t \\times c_2) \\times b_2 + a_1 - (t+c_1+c_2) \\times b_1$$ 设 $m_1 &gt; m_2$ 得 $$a_1-(t \\times c_1) \\times b_1 + a_2 - (t+c_1+c_2) \\times b_2 &gt; m_2 = a_2-(t \\times c_2) \\times b_2 + a_1 - (t+c_1+c_2) \\times b_1$$ 拆项得 $$a_1-b_1t-b_1c_1+a_2-b_2t-b_2c_1-b_2c_2&gt;a_2-b_2t-b_2c_2+a_1-b_1t-b_1c_1-b_1c_2$$ 化简得 $$b_1c_2 &gt; b_2c_1$$ 由此，我们就得到了我们 sort 函数中cmp的写法。注意开 long long 这题就完了。 这题的关键就在此，我不知道是为什么，大部分题解中都没有给出自己的完整证明，这个证明也不难证，希望读者看完后可以自己证明一遍。 代码：12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#define int long longusing namespace std;const int N = 1000100;const int M = 500010&lt;&lt;1;inline int read() { int x = 0,f = 1;char v = getchar(); while (!isdigit(v)) {if (v =='-') f = -1;v = getchar();} while (isdigit(v)) {x = x * 10 + v - 48;v = getchar();} return x * f;}int f[N],n,m,ans;struct node { int a,b,c; friend inline bool operator &lt; (const node &amp;rhs,const node &amp;rs) { return rhs.b*rs.c &gt; rhs.c*rs.b; }}pre[N];signed main() { m = read(),n = read(); for (int i = 1;i &lt;= n;++i) pre[i].a = read(); for (int i = 1;i &lt;= n;++i) pre[i].b = read(); for (int i = 1;i &lt;= n;++i) pre[i].c = read(); sort(pre+1,pre+1+n); for (int i = 1;i &lt;= n;++i) { for (int j = m;j &gt;= pre[i].c;--j) { f[j] = max(f[j],f[j-pre[i].c] + (pre[i].a - j * pre[i].b)); } } for (int i = 1;i &lt;= m;++i) { ans = max(ans,f[i]); } printf(\"%lld\",ans); return 0;}","link":"/2019/09/22/Luogu1417/"},{"title":"Luogu P1032 字串变换 解题报告","text":"题目链接：【NOIP2002】字串变换 题目描述：给你两个字符串 $A,B$ ，并给你 $n$ 个规则$(n\\leq 6)$ ，求从 $A$ 到 $B$ 最小的变换步数（若$10$步内无法变换则无解，字符串长度不能超过$20$）。 解题思路：从”$10$步内无法变换则无解” 则可以马上反应到：这是个搜索题（要素察觉） 既然是个搜索题，我们就要确定几点：搜索方式，搜索状态，搜索转移，搜索边界。 方式：这题是求最快的步数，所以我们采用 bfs 显然会比 dfs 快很多，而且有起点和终点状态我们就可以用双向搜索（具体不多说了），这里我们讲单向 bfs 的方法。 状态：首先，题目是对一个字符串进行操作，所以字符串显然是其中的一个状态 其次，题目中提到了对步数的限制，所以步数也是其中的一个状态。 1234struct node { int sum;//步数 string s;//当前字符串} 转移：其实题目中给的已经很明显了：就是按照这几种规则去转移当前字符串即可。 边界：题目中也有明显的指出，每次取出队头节点时要判断一下步数是否$ &gt; 10$。 以上便是此题的基本思路，但是这题的代码及其繁琐，所以我们着重讲一讲代码的实现。 储存规则：规则是两个字符串，我们可以用一个pair&lt;string,string&gt;来储存。 转移：我们用的是string，在这里，我们可以使用stirng::find 和 string::replace来实现字串的替换。 特判：每次取出节点的时候判断一下步数，每次变换完判断一下长度是否超限。 由此，我们可以写出一份基本的代码： 1234567891011121314151617181920212223242526272829vector&lt;pair&lt;string,string&gt; &gt; ma;//储存变换规则queue &lt;node&gt; s;void bfs() { node s = (node){a,0}; q.push(s);//初始状态插入 while (!q.empty()) { node p = q.front();q.pop(); string now = p.s; int num = p.sum;//取出当前状态 if (num &gt; 10) continue;//判断当前步数是否&gt;10 for (int i = 0;i &lt; tot;++i) {//循环判断 string a1 = ma[i].first,b1 = ma[i].second; if (now.find(a1) != std::string::npos) {//如果能找到 for (size_t j = now.find(a1);j != std::string::npos;j = now.find(a1,j+1)) { //上行代码有几个点要讲解的：1.使用size_t是因为string::npos是size_t的，如果不懂什么意思可以把它当作unsigned long long(有大佬说系统位数是32位这个值会变成unsigned int)来看待 2.前面一个find是找到最开始串里有没有这个最初的串，后面是在这个变换完的串之后看是否还有可以变换的 string t = now; t.replace(j,a1.length(),b1);//将可以变换的变换为 b1 if (t == b) {cout &lt;&lt; num+1;return ;}//如果找到了，可以直接退出 if (t.length() &lt;= 20) {//判断字符串长度 node pp = (node){t,num+1}; q.push(pp); se.insert(t); } } } } } cout &lt;&lt; \"NO ANSWER!\";} 这份代码没什么问题，但是我们可以分析一下这个题目性质： 显然，一个串可以被几个不同的规则搜到，但是由于我们是 bfs 所以可以证明最开始搜到的那个情况是最优的，之后搜到的情况都可以直接舍弃。 所以，我们可以把用过的情况存在一个 map 里，如果这个情况搜过了就跳过。 1234567if (t.length() &lt;= 20) { if (se.find(t)==se.end()){ node pp = (node){t,num+1}; q.push(pp); se.insert(t); }} 这样，你的代码就没什么问题了。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;#define ll long long#define ri register intconst int N = 100001;const int M = 500001;struct node { string s;int sum;};vector&lt;pair&lt;string,string&gt; &gt; ma;string a,b,a1,b1;int ans,cnt,tot;set &lt;string&gt; se;queue &lt;node&gt; q;void bfs() { node s = (node){a,0}; q.push(s); while (!q.empty()) { node p = q.front();q.pop(); string now = p.s; int num = p.sum; if (num &gt; 10) continue; for (int i = 0;i &lt; tot;++i) { string a1 = ma[i].first,b1 = ma[i].second; if (now.find(a1) != std::string::npos) { for (size_t j = now.find(a1);j != std::string::npos;j = now.find(a1,j+1)) { string t = now; t.replace(j,a1.length(),b1); if (t == b) {cout&lt;&lt;num+1;return ;} if (t.length() &lt;= 20) { if (se.find(t)==se.end()){ node pp = (node){t,num+1}; q.push(pp); se.insert(t); } } } } } } cout &lt;&lt; \"NO ANSWER!\";}int main() { ios::sync_with_stdio(false); cin.tie(0);cout.tie(0); cin &gt;&gt; a &gt;&gt; b; while (cin &gt;&gt; a1 &gt;&gt; b1) { ma.push_back(make_pair(a1,b1)); ++tot; } bfs(); return 0;}","link":"/2020/02/11/LuoguP1032/"},{"title":"Luogu P2169 正则表达式 解题报告","text":"题目链接：P2169 正则表达式 题目描述：在Internet网络中的每台电脑并不是直接一对一连通的，而是某些电脑之间存在单向的网络连接，也就是说存在A到B的连接不一定存在B到A的连接，并且有些连接传输速度很快，有些则很慢，所以不同连接传输所花的时间是有大有小的。另外，如果存在A到B的连接的同时也存在B到A的连接的话，那么A和B实际上处于同一局域网内，可以通过本地传输，这样花费的传输时间为0。 现在小Z告诉你整个网络的构成情况，他希望知道从他的电脑（编号为1），到小X的电脑（编号为n）所需要的最短传输时间。 对于100%的数据，$1\\leq n\\leq200000, 1\\leq m\\leq 1000000$ 解题思路：Tarjan 缩点 + SPFA/DP 首先观察数据范围，显然这么大的 $n,m$ ，直接跑 $O(nm)$ 的 SPFA 会炸掉。 观察题面，发现如果有 x 和 y 构成一个环（处在同一个 SCC 中），那么他们之间的边长度为 0 这启发我们可以用缩点后再来跑 SPFA ，但是这样的复杂度是不够严谨的，最坏情况下仍旧是 $O(nm)$ 的，只是由于这题水所以可以过。 代码：SPFA 版本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;stack&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;inline int read() { char v = getchar();int x = 0,f = 1; while (!isdigit(v)) {if (v == '-')f = -1;v = getchar();} while (isdigit(v)) {x = x * 10 + v - 48;v = getchar();} return x * f;}const int N = 10010;const int M = 5000010;int to[M],hd[N],nxt[M],tot,edg[M];inline void add(int u,int v,int w) {to[++tot] = v;edg[tot] = w;nxt[tot] = hd[u];hd[u] = tot;}inline int min(int x,int y) {return x&lt;y?x:y;}inline int max(int x,int y) {return x&gt;y?x:y;}using std::stack;int dfn[N],low[N],ins[N],cnt,num,c[N],n,m,p[N],f[N];stack &lt;int&gt; s;void tarjan(int x) { dfn[x] = low[x] = ++cnt; s.push(x);ins[x] = 1; for (int i = hd[x];i;i = nxt[i]) { if (!dfn[to[i]]) { tarjan(to[i]); low[x] = min(low[x],low[to[i]]); } else if (ins[to[i]]) { low[x] = min(low[x],dfn[to[i]]); } } if (dfn[x] == low[x]) { c[x] = ++num;int y; do { y = s.top(),s.pop(); ins[y] = 0;c[y] = num; }while (x != y); }}int vis[N],dis[N];void SPFA(int s) { memset(dis,0x3f,sizeof(dis)); queue &lt;int&gt; q; vis[s] = 1;dis[s] = 0; q.push(s); while (!q.empty()) { int x = q.front();q.pop(); vis[x] = 0; for (int i = hd[x];i;i = nxt[i]) { int y = to[i],w = edg[i]; if (c[x] == c[y]) w = 0; if (dis[y] &gt; dis[x] + w) { dis[y] = dis[x] + w; if (!vis[y]) { q.push(y); vis[y] = 1; } } } }}int main() { n = read(),m = read(); for (int i = 1;i &lt;= m;++i) { int x = read(),y = read(),w = read();add(x,y,w); } for (int i = 1;i &lt;= n;++i) if (!dfn[i]) tarjan(i); SPFA(1); printf(\"%d\",dis[n]); return 0;}","link":"/2019/10/11/sol-P2169/"},{"title":"图论板子","text":"存图前向星存图，尽量不用结构体，绝对不用vector 123456789int hd[N],edg[M],nxt[M],to[M],tot;inline void add(int u,int v,int w) { edg[++tot] = w;to[tot] = v;nxt[tot] = hd[u];hd[u] = tot;}inline void addedge(int u,int v,int w) { add(u,v,w);add(v,u,w);} 最短路Dijkstra带堆优化，时间复杂度$O(n\\log n)$，在正权图以及SPFA被卡的情况适用 1234567891011121314151617181920212223242526272829303132struct node { int dis,num; friend inline bool operator &lt; (const node &amp;a,const node &amp;b) { return a.dis &gt; b.dis; }};int dis[N],n,m,s;bool vis[N],hasfuhuan;void Dijkstra(int s) { priority_queue &lt;node&gt; heap; memset(dis,INF,sizeof(dis)); heap.push((node){dis[s] = 0,s}); while (!heap.empty()) { node p = heap.top();heap.pop(); int x = p.num; if (vis[x]) { continue; } vis[x] = 1; for (int i = hd[x];i;i = nxt[i]) { int y = to[i],w = edg[i]; if (dis[y] &gt; dis[x] + w) { dis[y] = dis[x] + w; if (!vis[y]) { heap.push((node){dis[y],y}); } } } }} SPFA最坏时间复杂度$O(nm)$，在证明不会被卡的时候用 12345678910111213141516171819void SPFA(int s) { queue &lt;int&gt; q; vis[s] = 1;dis[s] = 0; q.push(s); while (!q.empty()) { int x = q.front();q.pop(); vis[x] = 0; for (int i = hd[x];i;i = nxt[i]) { int y = to[i],w = edg[i]; if (dis[y] &gt; dis[x] + w) { dis[y] = dis[x] + w; if (!vis[y]) { q.push(y); vis[y] = 1; } } } }} Bellman-Ford稳定时间复杂度$O(nm)$，判负环用 因为不会SPFA判负环 123456789101112131415161718void Bellman_Ford(int s) { memset(dis,INF,sizeof(dis)); dis[s] = 0; int cnt = 0,flag = 1; while (flag) { for (int i = 0;i &lt; m;++i) { flag = 0; int u = edges[i].u,v = edges[i].v,w = edges[i].w; if (dis[v] &gt; dis[u] + w) { dis[v] = dis[u] + w; flag = 1; } if (++cnt &gt; n) { hasfuhuan = 1; } } }} 最小生成树菜的要死只会Kruskal Kruskal并查集+排序 时间复杂度$O(m\\log m)$，对于边数较少的图适用 1234567891011121314151617181920212223242526272829//Union-Find Setint f[N];int find(int x) { return f[x] == x ? f[x]:f[x] = find(f[x]);}//Kruskalstruct edge { int u,v,w; friend inline bool operator &lt; (const edge &amp;a,const edge &amp;b) { return a.w &lt; b.w; }}edges[M];int Kruskal() { int tot = 0,ans = 0; sort(edges+1,edges+1+n); for (int i = 1;i &lt;= m;++i) { int u = edges[i].u,v = edges[i].v,w = edges[i].w; if (find(u) != find(v)) { ans += w; ++tot; } if (tot == n-1) { break; } } return ans;} 拓扑排序用来巧妙求解DAGdp等，利用BFS实现，同样可以用DFS实现 12345678910111213141516int cnt[N];void toposort(int s) { queue &lt;int&gt; q; for (int i = 1;i &lt;= n;++i) { if (!cnt[i]) q.push(i); } while (!q.empty()) { int u = q.front(); for (int i = hd[u];i;i = nxt[i]) { int v = to[i]; if (--cnt[v] == 0) { q.push(v); } } }} 树链剖分树链剖分这个OIer很强 快速求解树上问题，具体应用请看[树链剖分 学习笔记](https://www.zzlblog.ga/2019/08/26/树链剖分 学习笔记/) 12345678910111213141516171819202122232425262728293031323334353637int dfn[N],top[N],siz[N],son[N],dep[N],fat[N];void dfs1(int u,int f) { son[u] = 0; siz[u] = 1; dep[u] = dep[f] + 1; fat[u] = f; for (int i = hd[u];i;i = nxt[i]) { int v = to[i],w = edg[i]; if (v != f) { dfs(v,u); siz[u] += siz[v]; if (siz[v] &gt; siz[son[u]]) { son[u] = v; } } }}void dfs2(int u,int f) { dfn[u] = ++cnt; if (u == son[f]) { top[u] = top[f]; } else { top[u] = u; } if (son[u]) { dfs2(son[u],u); } for (int i = hd[u];i;i = nxt[i]) { int v = to[i],w = edg[i]; if (v != f &amp;&amp; v != son[u]) { dfs2(v,u); } }}","link":"/2019/08/11/%E5%9B%BE%E8%AE%BA%E6%9D%BF%E5%AD%90/"},{"title":"树链剖分 学习笔记","text":"树链剖分是个很强的 OIer 树链剖分是用来解决一系列树上问题的利器。 定义 链：树上不拐弯的一条路径 重儿子：子树大小最大的儿子 轻儿子：其他儿子 重链：由重儿子组成的链 结果和过程结果这是原树 剖分之后的树 这里，红色的边构成重链，蓝色的点为重儿子，绿色的点为轻儿子。 注意，这里的 7 号与 8 号节点子树大小相同，因此我们选择编号靠前的儿子为重儿子。 实现一般来说，树链剖分通过两遍 dfs 来实现。 定义12345siz[x] //子树x的大小top[x] //x所在链的顶端fat[x] //x的父亲dep[x] //x的深度son[x] //x的重儿子 第一遍 dfs ，我们先处理出每个节点的父亲，深度，子树大小，重儿子 12345678910111213141516void dfs1(int u,int f) { siz[u] = 1; dep[u] = dep[f] + 1; son[u] = 0; fat[u] = f; for (int i = hd[u];i;i= nxt[i]) { int v = to[i]; if (v != f) { dfs1(v,u); siz[u] += siz[v]; if (siz[v] &gt; siz[son[u]]) { son[u] = v; } } }} 第二遍 dfs，我们处理出每条链链顶的节点， 1234567891011121314151617void dfs2(int u,int f) { if (son[f] == u) { top[u] = top[f]; } else { top[u] = u; } if (son[u]) { dfs2(son[u],u); } for (int i = hd[u];i;i = nxt[i]) { int v = to[i]; if (v != f &amp;&amp; v != son[u]) { dfs2(v,u); } }} 这样树链剖分的基本结构就写完辣！是不是很简单 应用LCA显然，我们可以发现，在一条重链上的两个节点的 LCA 显然就是深度更浅的那个节点。 所以我们可以先将两个节点跳到同一条链上，求出深度浅的那个节点即可，于是有了如下代码： 12345678910inline int LCA(int x,int y) { int tx = top[x],ty = top[y] while (tx != ty) { if (dep[x] &gt; dep[y]) { swap(x,y); } x = fat[top[x]]; } return (x &lt; y) ? x : y;} 时间复杂度$O(\\log{n})$ 例题：板子题 随手套个板子写掉。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;const int N = 500010;const int M = N &lt;&lt; 1;inline int read() { char v = getchar();int x = 0,f = 1; while (!isdigit(v)) {if (v == '-')f = -1;v = getchar();} while (isdigit(v)) {x = x * 10 + v - 48;v = getchar();} return x * f;}int hd[N],edg[M],nxt[M],to[M],n,m,tot,cnt;inline void add(int u,int v,int w) { to[++tot] = v;edg[tot] = w;nxt[tot] = hd[u];hd[u] = tot;}inline void addedge(int u,int v,int w) { add(u,v,w);add(v,u,w);}int dfn[N],top[N],fat[N],siz[N],son[N],end[N],dep[N],s;void dfs1(int s,int f) { son[s] = 0; dep[s] = dep[f] + 1; siz[s] = 1; fat[s] = f; for (int i = hd[s];i;i = nxt[i]) { if (to[i] != f) { dfs1(to[i],s); siz[s] += siz[to[i]]; if (siz[to[i]] &gt; siz[son[s]]) { son[s] = to[i]; } } }}void dfs2(int u,int f) { dfn[u] = ++cnt; if (u == son[f]) { top[u] = top[f]; } else { top[u] = u; } if (son[u]) { dfs2(son[u],u); } for (int i = hd[u];i;i = nxt[i]) { int v = to[i]; if (v != f &amp;&amp; v != son[u]) { dfs2(v,u); } } end[u] = cnt;}inline int lca(int x,int y) { int tx = top[x],ty = top[y] while (tx != ty) { if (dep[x] &gt; dep[y]) { swap(x,y); } x = fat[top[x]]; } return (x &lt; y) ? x : y;}int main() { n = read(),m = read(),s = read(); for (int i = 1;i &lt; n;++i) { int u = read(),v = read(),w = 1; addedge(u,v,w); } dfs1(s,0); dfs2(s,0); for (int i = 1;i &lt;= m;++i) { int u = read(),v = read(); printf(\"%d\\n\",lca(u,v)); } return 0;} 链上修改，子树修改这里就必须引出一个新东西了：dfs 序 指的是第几次 dfs 遍历到的这个节点 定义数组dfn[x]为节点 x 的 dfs 序。 我们可以在 dfs2 中顺手维护一下。 1234567891011121314151617void dfs2(int u,int f) { dfn[u] = ++cnt; if (son[f] == u) { top[u] = top[f]; } else { top[u] = u; } if (son) for (int i = hd[u];i;i = nxt[i]) { int v = to[i]; if (v != f) { dfs2(v,u); } } end[cnt] = u;} 这里给出每个节点加上 dfn 的图 我们可以发现，在每棵子树，每条链上的dfn都是连续的！ 这样看可能不太明朗，我们把它转化成区间来看（这里是子树的，链同理） 所以我们就可以利用数据结构维护一下节点了。 对子树修改就是 change(dfn[x],dfn[x]+siz[x]-1) 链上修改就是 change(dfn[x],dfn[y]) 这里的核心思想是：将树上问题转化成序列问题来处理 例题：[ZJOI2008]树的统计 用线段树维护最大值最小值。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851866#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;iostream&gt;#include &lt;string&gt;const int N = 100010;const int M = N &lt;&lt; 1;const int INF = 0x3f3f3f3f;using namespace std;inline int read() { char v = getchar();int x = 0,f = 1; while (!isdigit(v)) {if (v == '-')f = -1;v = getchar();} while (isdigit(v)) {x = x * 10 + v - 48;v = getchar();} return x * f;}int to[M],hd[N],nxt[M],tot;string s;inline void add(int u,int v) { to[++tot] = v;nxt[tot] = hd[u];hd[u] = tot;}inline void addedge(int u,int v) { add(u,v);add(v,u);}int dfn[N],top[N],fat[N],siz[N],dep[N],son[N],rk[N],cnt,n;void dfs1(int u,int f) { fat[u] = f; dep[u] = dep[f] + 1; son[u] = 0; siz[u] = 1; for (int i = hd[u];i;i = nxt[i]) { int v = to[i]; if (v != f) { dfs1(v,u); siz[u] += siz[v]; if (siz[v] &gt; siz[son[u]]) { son[u] = v; } } }}void dfs2(int u,int f) { dfn[u] = ++cnt;rk[cnt] = u; if (son[f] == u) { top[u] = top[f]; } else { top[u] = u; } if (son[u]) { dfs2(son[u],u); } for (int i = hd[u];i;i = nxt[i]) { int v = to[i]; if (v != f &amp;&amp; v != son[u]) { dfs2(v,u); } }}int num[N];struct node { int l,r,big,sum;}tree[N&lt;&lt;2];inline void build(int p,int l,int r) { tree[p].l = l;tree[p].r = r; if (l == r) { tree[p].big = tree[p].sum = num[rk[l]]; return ; } int mid = (l + r) &gt;&gt; 1; build(p &lt;&lt; 1,l,mid); build(p &lt;&lt; 1|1,mid+1,r); tree[p].sum = tree[p&lt;&lt;1].sum + tree[p&lt;&lt;1|1].sum; tree[p].big = max(tree[p&lt;&lt;1].big,tree[p&lt;&lt;1|1].big); return ;}inline void modify(int p,int x,int v) { if (tree[p].l == tree[p].r) { tree[p].sum = tree[p].big = v; return ; } int mid = (tree[p].l + tree[p].r) &gt;&gt; 1; if (x &lt;= mid) modify(p&lt;&lt;1,x,v); if (x &gt; mid) modify(p&lt;&lt;1|1,x,v); tree[p].sum = tree[p&lt;&lt;1].sum + tree[p&lt;&lt;1|1].sum; tree[p].big = max(tree[p&lt;&lt;1].big,tree[p&lt;&lt;1|1].big); return ;} inline int querym(int p,int x,int y) { if (tree[p].l &gt;= x &amp;&amp; tree[p].r &lt;= y) { return tree[p].big; } int mid = (tree[p].l + tree[p].r) &gt;&gt; 1,ans = -INF; if (x &lt;= mid) { ans = max(ans,querym(p&lt;&lt;1,x,y)); } if (y &gt; mid) { ans = max(ans,querym(p&lt;&lt;1|1,x,y)); } return ans;}inline int querys(int p,int x,int y) { if (tree[p].l &gt;= x &amp;&amp; tree[p].r &lt;= y) { return tree[p].sum; } int mid = (tree[p].l + tree[p].r) &gt;&gt; 1,ans = 0; if (x &lt;= mid) { ans += querys(p&lt;&lt;1,x,y); } if (y &gt; mid) { ans += querys(p&lt;&lt;1|1,x,y); } return ans;}inline void change(int u,int t) { modify(1,dfn[u],t);}inline int qmax(int u,int v) { int ans = -INF; while (top[u] != top[v]) { if (dep[top[u]] &lt; dep[top[v]]) { swap(u,v); } ans = max(ans,querym(1,dfn[top[u]],dfn[u])); u = fat[top[u]]; } if (dep[u] &gt; dep[v]) { swap(u,v); } ans = max(ans,querym(1,dfn[u],dfn[v])); return ans;}inline int qsum(int u,int v) { int ans = 0; while (top[u] != top[v]) { if (dep[top[u]] &lt; dep[top[v]]) { swap(u,v); } ans += querys(1,dfn[top[u]],dfn[u]); u = fat[top[u]]; } if (dep[u] &gt; dep[v]) { swap(u,v); } ans += querys(1,dfn[u],dfn[v]); return ans;}signed main() { n = read(); for (int i = 1;i &lt; n;++i) { addedge(read(),read()); } for (int i = 1;i &lt;= n;++i) { num[i] = read(); } dfs1(1,0);dfs2(1,0);build(1,1,n); int m = read(); for (int i = 1;i &lt;= m;++i) { cin &gt;&gt; s; int u = read(),v = read(); if (s == \"CHANGE\") { change(u,v); } if (s == \"QSUM\") { printf(\"%d\\n\",qsum(u,v)); } if (s == \"QMAX\") { printf(\"%d\\n\",qmax(u,v)); } } return 0;} 傻逼好题推荐Qtree 把边权变成点权，巧妙的做法 [HAOI2015]树上操作 练手，区间修改，区间查询 [JLOI2014]松鼠的新家 巧妙的做法，也可以用树上差分来写 [NOI2015]程序包管理器 稍微转换一下问题 后记感谢 $\\color{black}z\\color{red}{gjjj}$ 给我提供了极大的帮助，感谢 $\\color{black}Y\\color{red}{ouSiKi}$ 的教导","link":"/2019/08/26/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"经验教训","text":"多组数据一定要清空（@zgjjj） 在同样的数据范围($n \\leq 1000$)下，跑$n$边Djikstra比Floyd快($O((n+m)^2 \\log n)$与$O(n^3)$，如果有O2常数差不多)","link":"/2019/08/11/%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD/"}],"tags":[{"name":"递归","slug":"递归","link":"/tags/%E9%80%92%E5%BD%92/"},{"name":"codeforces","slug":"codeforces","link":"/tags/codeforces/"},{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"暴力","slug":"暴力","link":"/tags/%E6%9A%B4%E5%8A%9B/"},{"name":"思维","slug":"思维","link":"/tags/%E6%80%9D%E7%BB%B4/"},{"name":"数位DP","slug":"数位DP","link":"/tags/%E6%95%B0%E4%BD%8DDP/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"数论","slug":"数论","link":"/tags/%E6%95%B0%E8%AE%BA/"},{"name":"线段树","slug":"线段树","link":"/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"Tarjan","slug":"Tarjan","link":"/tags/Tarjan/"},{"name":"割点","slug":"割点","link":"/tags/%E5%89%B2%E7%82%B9/"},{"name":"背包","slug":"背包","link":"/tags/%E8%83%8C%E5%8C%85/"},{"name":"BFS","slug":"BFS","link":"/tags/BFS/"},{"name":"搜索","slug":"搜索","link":"/tags/%E6%90%9C%E7%B4%A2/"},{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"缩点","slug":"缩点","link":"/tags/%E7%BC%A9%E7%82%B9/"},{"name":"MST","slug":"MST","link":"/tags/MST/"},{"name":"并查集","slug":"并查集","link":"/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"拓扑排序","slug":"拓扑排序","link":"/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"name":"最短路","slug":"最短路","link":"/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"负环","slug":"负环","link":"/tags/%E8%B4%9F%E7%8E%AF/"},{"name":"树链剖分","slug":"树链剖分","link":"/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"},{"name":"树","slug":"树","link":"/tags/%E6%A0%91/"}],"categories":[{"name":"解题报告","slug":"解题报告","link":"/categories/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"},{"name":"Codeforces赛后题解","slug":"Codeforces赛后题解","link":"/categories/Codeforces%E8%B5%9B%E5%90%8E%E9%A2%98%E8%A7%A3/"},{"name":"学习笔记","slug":"学习笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]}