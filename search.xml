<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Luogu P4999 烦人的数学作业 解题报告]]></title>
    <url>%2F2019%2F09%2F07%2FLuogu%20P4999%20%E7%83%A6%E4%BA%BA%E7%9A%84%E6%95%B0%E5%AD%A6%E4%BD%9C%E4%B8%9A%20%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[题目链接：P4999 烦人的数学作业 题目描述：给出一个区间$L - R$，求$L$到$R$区间内每个数的数字和，如123这个数的数字和为1+2+3=6 有T组数据，结果$\mod 10^9+7$ $（1 \leq L \leq R \leq 10^18）$ 解题思路：确实烦人 第一眼看上去跟[ZJOI2010]数字计数很像，确实是，把那个题的数位DP抄过来乘个 i 这题就没了。 那为啥要写这个题解呢？因为这个题坑多。 注意开 long long 取模很坑，请使用传统技巧(ans % mod + mod) % mod，正确性证明应该不用多说 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#define int long long const int N = 20;const int mod = 1e9+7;const int M = N &lt;&lt; 1;inline int read() &#123; char v = getchar();int x = 0,f = 1; while (!isdigit(v)) &#123;if (v == '-')f = -1;v = getchar();&#125; while (isdigit(v)) &#123;x = x * 10 + v - 48;v = getchar();&#125; return x * f;&#125;int num[N],dp[N][N],l,r;int dfs(int pos,bool limit,bool zer,int dig,int sum) &#123; int ans = 0; if (pos == 0) &#123; return sum; &#125; if (!limit &amp;&amp; dp[pos][sum]) return dp[pos][sum]; int up = 9; if (limit) up = num[pos]; for (int j = 0;j &lt;= up;++j) &#123; ans += dfs(pos-1,(j==up)&amp;&amp;limit,zer||j,dig,sum+((j||zer)&amp;&amp;(j==dig))); &#125; if (!limit&amp;&amp;zer)&#123; dp[pos][sum] = ans; &#125; return ans;&#125;int work(int p,int w) &#123; memset(dp,0,sizeof(dp)); int len = 0; while (p) &#123; num[++len] = p % 10; p /= 10; &#125; return dfs(len,1,0,w,0) % mod;&#125; signed main() &#123; int T = read(); while (T--) &#123; int ans = 0; l = read(),r = read(); for (int i = 0;i &lt;= 9;++i) &#123; ans += ((work(r,i) - work(l-1,i) % mod) * i) % mod; &#125; printf("%lld\n",(ans%mod+mod)%mod); &#125; return 0;&#125;]]></content>
      <categories>
        <category>解题报告</category>
      </categories>
      <tags>
        <tag>数位DP</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树链剖分 学习笔记]]></title>
    <url>%2F2019%2F08%2F26%2F%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[树链剖分是个很强的 OIer 树链剖分是用来解决一系列树上问题的利器。 定义 链：树上不拐弯的一条路径 重儿子：子树大小最大的儿子 轻儿子：其他儿子 重链：由重儿子组成的链 结果和过程结果这是原树 剖分之后的树 这里，红色的边构成重链，蓝色的点为重儿子，绿色的点为轻儿子。 注意，这里的 7 号与 8 号节点子树大小相同，因此我们选择编号靠前的儿子为重儿子。 实现一般来说，树链剖分通过两遍 dfs 来实现。 定义12345siz[x] //子树x的大小top[x] //x所在链的顶端fat[x] //x的父亲dep[x] //x的深度son[x] //x的重儿子 第一遍 dfs ，我们先处理出每个节点的父亲，深度，子树大小，重儿子 12345678910111213141516void dfs1(int u,int f) &#123; siz[u] = 1; dep[u] = dep[f] + 1; son[u] = 0; fat[u] = f; for (int i = hd[u];i;i= nxt[i]) &#123; int v = to[i]; if (v != f) &#123; dfs1(v,u); siz[u] += siz[v]; if (siz[v] &gt; siz[son[u]]) &#123; son[u] = v; &#125; &#125; &#125;&#125; 第二遍 dfs，我们处理出每条链链顶的节点， 1234567891011121314151617void dfs2(int u,int f) &#123; if (son[f] == u) &#123; top[u] = top[f]; &#125; else &#123; top[u] = u; &#125; if (son[u]) &#123; dfs2(son[u],u); &#125; for (int i = hd[u];i;i = nxt[i]) &#123; int v = to[i]; if (v != f &amp;&amp; v != son[u]) &#123; dfs2(v,u); &#125; &#125;&#125; 这样树链剖分的基本结构就写完辣！是不是很简单 应用LCA显然，我们可以发现，在一条重链上的两个节点的 LCA 显然就是深度更浅的那个节点。 所以我们可以先将两个节点跳到同一条链上，求出深度浅的那个节点即可，于是有了如下代码： 12345678910inline int LCA(int x,int y) &#123; int tx = top[x],ty = top[y] while (tx != ty) &#123; if (dep[x] &gt; dep[y]) &#123; swap(x,y); &#125; x = fat[top[x]]; &#125; return (x &lt; y) ? x : y;&#125; 时间复杂度$O(\log{n})$ 例题：板子题 随手套个板子写掉。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;const int N = 500010;const int M = N &lt;&lt; 1;inline int read() &#123; char v = getchar();int x = 0,f = 1; while (!isdigit(v)) &#123;if (v == '-')f = -1;v = getchar();&#125; while (isdigit(v)) &#123;x = x * 10 + v - 48;v = getchar();&#125; return x * f;&#125;int hd[N],edg[M],nxt[M],to[M],n,m,tot,cnt;inline void add(int u,int v,int w) &#123; to[++tot] = v;edg[tot] = w;nxt[tot] = hd[u];hd[u] = tot;&#125;inline void addedge(int u,int v,int w) &#123; add(u,v,w);add(v,u,w);&#125;int dfn[N],top[N],fat[N],siz[N],son[N],end[N],dep[N],s;void dfs1(int s,int f) &#123; son[s] = 0; dep[s] = dep[f] + 1; siz[s] = 1; fat[s] = f; for (int i = hd[s];i;i = nxt[i]) &#123; if (to[i] != f) &#123; dfs1(to[i],s); siz[s] += siz[to[i]]; if (siz[to[i]] &gt; siz[son[s]]) &#123; son[s] = to[i]; &#125; &#125; &#125;&#125;void dfs2(int u,int f) &#123; dfn[u] = ++cnt; if (u == son[f]) &#123; top[u] = top[f]; &#125; else &#123; top[u] = u; &#125; if (son[u]) &#123; dfs2(son[u],u); &#125; for (int i = hd[u];i;i = nxt[i]) &#123; int v = to[i]; if (v != f &amp;&amp; v != son[u]) &#123; dfs2(v,u); &#125; &#125; end[u] = cnt;&#125;inline int lca(int x,int y) &#123; int tx = top[x],ty = top[y] while (tx != ty) &#123; if (dep[x] &gt; dep[y]) &#123; swap(x,y); &#125; x = fat[top[x]]; &#125; return (x &lt; y) ? x : y;&#125;int main() &#123; n = read(),m = read(),s = read(); for (int i = 1;i &lt; n;++i) &#123; int u = read(),v = read(),w = 1; addedge(u,v,w); &#125; dfs1(s,0); dfs2(s,0); for (int i = 1;i &lt;= m;++i) &#123; int u = read(),v = read(); printf("%d\n",lca(u,v)); &#125; return 0;&#125; 链上修改，子树修改这里就必须引出一个新东西了：dfs 序 指的是第几次 dfs 遍历到的这个节点 定义数组dfn[x]为节点 x 的 dfs 序。 我们可以在 dfs2 中顺手维护一下。 1234567891011121314151617void dfs2(int u,int f) &#123; dfn[u] = ++cnt; if (son[f] == u) &#123; top[u] = top[f]; &#125; else &#123; top[u] = u; &#125; if (son) for (int i = hd[u];i;i = nxt[i]) &#123; int v = to[i]; if (v != f) &#123; dfs2(v,u); &#125; &#125; end[cnt] = u;&#125; 这里给出每个节点加上 dfn 的图 我们可以发现，在每棵子树，每条链上的dfn都是连续的！ 这样看可能不太明朗，我们把它转化成区间来看（这里是子树的，链同理） 所以我们就可以利用数据结构维护一下节点了。 对子树修改就是 change(dfn[x],dfn[x]+siz[x]-1) 链上修改就是 change(dfn[x],dfn[y]) 这里的核心思想是：将树上问题转化成序列问题来处理 例题：[ZJOI2008]树的统计 用线段树维护最大值最小值。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851866#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;iostream&gt;#include &lt;string&gt;const int N = 100010;const int M = N &lt;&lt; 1;const int INF = 0x3f3f3f3f;using namespace std;inline int read() &#123; char v = getchar();int x = 0,f = 1; while (!isdigit(v)) &#123;if (v == '-')f = -1;v = getchar();&#125; while (isdigit(v)) &#123;x = x * 10 + v - 48;v = getchar();&#125; return x * f;&#125;int to[M],hd[N],nxt[M],tot;string s;inline void add(int u,int v) &#123; to[++tot] = v;nxt[tot] = hd[u];hd[u] = tot;&#125;inline void addedge(int u,int v) &#123; add(u,v);add(v,u);&#125;int dfn[N],top[N],fat[N],siz[N],dep[N],son[N],rk[N],cnt,n;void dfs1(int u,int f) &#123; fat[u] = f; dep[u] = dep[f] + 1; son[u] = 0; siz[u] = 1; for (int i = hd[u];i;i = nxt[i]) &#123; int v = to[i]; if (v != f) &#123; dfs1(v,u); siz[u] += siz[v]; if (siz[v] &gt; siz[son[u]]) &#123; son[u] = v; &#125; &#125; &#125;&#125;void dfs2(int u,int f) &#123; dfn[u] = ++cnt;rk[cnt] = u; if (son[f] == u) &#123; top[u] = top[f]; &#125; else &#123; top[u] = u; &#125; if (son[u]) &#123; dfs2(son[u],u); &#125; for (int i = hd[u];i;i = nxt[i]) &#123; int v = to[i]; if (v != f &amp;&amp; v != son[u]) &#123; dfs2(v,u); &#125; &#125;&#125;int num[N];struct node &#123; int l,r,big,sum;&#125;tree[N&lt;&lt;2];inline void build(int p,int l,int r) &#123; tree[p].l = l;tree[p].r = r; if (l == r) &#123; tree[p].big = tree[p].sum = num[rk[l]]; return ; &#125; int mid = (l + r) &gt;&gt; 1; build(p &lt;&lt; 1,l,mid); build(p &lt;&lt; 1|1,mid+1,r); tree[p].sum = tree[p&lt;&lt;1].sum + tree[p&lt;&lt;1|1].sum; tree[p].big = max(tree[p&lt;&lt;1].big,tree[p&lt;&lt;1|1].big); return ;&#125;inline void modify(int p,int x,int v) &#123; if (tree[p].l == tree[p].r) &#123; tree[p].sum = tree[p].big = v; return ; &#125; int mid = (tree[p].l + tree[p].r) &gt;&gt; 1; if (x &lt;= mid) modify(p&lt;&lt;1,x,v); if (x &gt; mid) modify(p&lt;&lt;1|1,x,v); tree[p].sum = tree[p&lt;&lt;1].sum + tree[p&lt;&lt;1|1].sum; tree[p].big = max(tree[p&lt;&lt;1].big,tree[p&lt;&lt;1|1].big); return ;&#125; inline int querym(int p,int x,int y) &#123; if (tree[p].l &gt;= x &amp;&amp; tree[p].r &lt;= y) &#123; return tree[p].big; &#125; int mid = (tree[p].l + tree[p].r) &gt;&gt; 1,ans = -INF; if (x &lt;= mid) &#123; ans = max(ans,querym(p&lt;&lt;1,x,y)); &#125; if (y &gt; mid) &#123; ans = max(ans,querym(p&lt;&lt;1|1,x,y)); &#125; return ans;&#125;inline int querys(int p,int x,int y) &#123; if (tree[p].l &gt;= x &amp;&amp; tree[p].r &lt;= y) &#123; return tree[p].sum; &#125; int mid = (tree[p].l + tree[p].r) &gt;&gt; 1,ans = 0; if (x &lt;= mid) &#123; ans += querys(p&lt;&lt;1,x,y); &#125; if (y &gt; mid) &#123; ans += querys(p&lt;&lt;1|1,x,y); &#125; return ans;&#125;inline void change(int u,int t) &#123; modify(1,dfn[u],t);&#125;inline int qmax(int u,int v) &#123; int ans = -INF; while (top[u] != top[v]) &#123; if (dep[top[u]] &lt; dep[top[v]]) &#123; swap(u,v); &#125; ans = max(ans,querym(1,dfn[top[u]],dfn[u])); u = fat[top[u]]; &#125; if (dep[u] &gt; dep[v]) &#123; swap(u,v); &#125; ans = max(ans,querym(1,dfn[u],dfn[v])); return ans;&#125;inline int qsum(int u,int v) &#123; int ans = 0; while (top[u] != top[v]) &#123; if (dep[top[u]] &lt; dep[top[v]]) &#123; swap(u,v); &#125; ans += querys(1,dfn[top[u]],dfn[u]); u = fat[top[u]]; &#125; if (dep[u] &gt; dep[v]) &#123; swap(u,v); &#125; ans += querys(1,dfn[u],dfn[v]); return ans;&#125;signed main() &#123; n = read(); for (int i = 1;i &lt; n;++i) &#123; addedge(read(),read()); &#125; for (int i = 1;i &lt;= n;++i) &#123; num[i] = read(); &#125; dfs1(1,0);dfs2(1,0);build(1,1,n); int m = read(); for (int i = 1;i &lt;= m;++i) &#123; cin &gt;&gt; s; int u = read(),v = read(); if (s == "CHANGE") &#123; change(u,v); &#125; if (s == "QSUM") &#123; printf("%d\n",qsum(u,v)); &#125; if (s == "QMAX") &#123; printf("%d\n",qmax(u,v)); &#125; &#125; return 0;&#125; 傻逼好题推荐Qtree 把边权变成点权，巧妙的做法 [HAOI2015]树上操作 练手，区间修改，区间查询 [JLOI2014]松鼠的新家 巧妙的做法，也可以用树上差分来写 [NOI2015]程序包管理器 稍微转换一下问题 后记感谢 $\color{black}z\color{red}{gjjj}$ 给我提供了极大的帮助，感谢 $\color{black}Y\color{red}{ouSiKi}$ 的教导]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>树链剖分</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForcesRound#1206题解]]></title>
    <url>%2F2019%2F08%2F22%2FCodeForcesRound-1206%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[A. Choose Two Numbers题目描述：给你两个集合 $A,B$, 要求你分别从$A,B$中取出一个数，使得两数之和不在$A$中也不在$B$中 $n ,m\leq 100$ 解题思路：看数据范围应该很容易想出来一个 $O(nm(n+m))$ 的暴力，枚举 $A,B$ 中的每一个数，将他们相加之后再在两个集合中判定一下，这个题就完了。事实上由于$n ,m\leq 100$ 可以轻松通过本题。 但是显然，还会有更好的解法，我们可以观察到，如果选取这两个集合中最大的数相加，显然这个和不会出现在两个集合里面，复杂度下降到了 $O(m \log {m} + n \log {n}) $ 如果用排序还可以达到$O(m+n)$的线性时间复杂度(排序是作者给出的解法，实际上可以直接读入的时候求出) 代码： $O(nm(n+m))$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;cctype&gt;inline int read() &#123; char v = getchar();int x = 0,f = 1; while (!isdigit(v)) &#123;if(v == '-')f = -1;v = getchar();&#125; while (isdigit(v)) &#123;x = x * 10 + v - 48;v = getchar();&#125; return x * f;&#125;const int N = 110;int a[N],b[N],n,m,a1,a2;int main() &#123; n = read(); for (int i = 1;i &lt;= n;++i) &#123; a[i] = read(); &#125; m = read(); for (int i = 1;i &lt;= m;++i) &#123; b[i] = read(); &#125; for (int i = 1;i &lt;= n;++i) &#123; for (int j = 1;j &lt;= m;++j) &#123; a1 = a[i],a2 = b[j]; int sum = a1 + a2;bool flag = 0; for (int k = 1;k &lt;= n;++k) &#123; if (sum == a[k]) &#123; flag = 1; break; &#125; &#125; for (int k = 1;k &lt;= m;++k) &#123; if (sum == b[k]) &#123; flag = 1; break; &#125; &#125; if (!flag) &#123; printf("%d %d\n",a1,a2); return 0; &#125; &#125; &#125; return 0;&#125; $O(m + n) $ 12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;using std::max;inline int read() &#123; char v = getchar();int x = 0,f = 1; while (!isdigit(v)) &#123;if(v == '-')f = -1;v = getchar();&#125; while (isdigit(v)) &#123;x = x * 10 + v - 48;v = getchar();&#125; return x * f;&#125;const int N = 110;int tmp,a,b;int main() &#123; n = read(); for (int i = 1;i &lt;= n;++i) &#123; tmp = read(); a = max(a,tmp); &#125; m = read(); for (int i = 1;i &lt;= m;++i) &#123; tmp = read(); b = max(b,tmp); &#125; printf("%d %d",a,b); return 0;&#125; B. Make Product Equal One题目描述：给你一个有 $n$ 个数字的数列，你有两种操作：将某个数 $+1$ 或 $-1$ 。求用最小的操作次数让这个数列的每一项乘起来等于 1 $n \leq 10^5$ 解题思路：用C换来的 分析一下，每个数字只有两种情况：变成 1 或者变成 -1 所以每个数字的代价就是min(abs(1 - a[i]),abs(-1 - a[i])) 值得一提的几个大坑点是，最后可能会变成 -1 ，所以顺便记一下，如果最后变成 -1 了记得加上 2 。而且 0 也要记，最后要加上 0 的个数。 时间复杂度$O(n)$ 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;#define int long longinline int read() &#123; char v = getchar();int x = 0,f = 1; while (!isdigit(v)) &#123;if(v == '-')f = -1;v = getchar();&#125; while (isdigit(v)) &#123;x = x * 10 + v - 48;v = getchar();&#125; return x * f;&#125;const int N = 100010;int pre[N],n,p1,p2,ans,z,res = 1;signed main() &#123; n = read(); for (int i = 1;i &lt;= n;++i) &#123; pre[i] = read(); if (pre[i] == 0) &#123; z++; &#125; &#125; sort(pre+1,pre+1+n); for (int i = 1;i &lt;= n;++i) &#123; if (pre[i] &lt;= -1) &#123; ans += (-1 - pre[i]); res *= -1; &#125; else if (pre[i] &gt;= 1) &#123; ans += (pre[i] - 1); res *= 1; &#125; &#125; if (res == -1) &#123; if (z) &#123; ans += z; &#125; else &#123; ans += 2; &#125; &#125; else &#123; ans += z; &#125; cout &lt;&lt; ans; return 0;&#125; C. Almost Equal题目描述：给定一个数字 $n$ ，要求你使用 $1…2*n$ 的数字构造出一个环，使得这个环每三个数相加的和之间差不超过 1. 解题思路：偶数显然不能构造，奇数按照样例构造即可，具体看代码 代码：123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using std::min;inline int read() &#123; char v = getchar();int x = 0,f = 1; while (!isdigit(v)) &#123;if(v == '-')f = -1;v = getchar();&#125; while (isdigit(v)) &#123;x = x * 10 + v - 48;v = getchar();&#125; return x * f;&#125;const int N = 200010;int pre[N],n,now = 1;int main() &#123; n = read(); if (n % 2 == 0) &#123; printf("NO"); return 0; &#125; for (int i = 1;i &lt;= 2*n;++i) &#123; pre[now] = i; if (i % 2 == 0) &#123; now += 1; &#125; else &#123; if ((i / 2) % 2) &#123; now -= n; &#125; else &#123; now += n; &#125; &#125; &#125; printf("YES\n"); for (int i = 1;i &lt;= 2*n;++i) &#123; printf("%d ",pre[i]); &#125; return 0;&#125; D. Shortest Circle题目描述：给你 $n$ 个点，每个点有一个点权，两点之间有边当且仅当 $a[i] \&amp; a[j] \ne 0$ ，求出图中最小环的长度。 $n \leq 100000,a_i \leq 10^{18}$ 解题思路：直接构造显然是 $O(n^2)$ 的，考虑优化建边的过程。 首先可以观察到，如果二进制内某一位有 3 个 1 ，那么肯定有一个长度为 3 的环，直接输出即可。 那么现在问题简化为了每位至多有两个 1 的情况，我们可以发现每一位最多只有一条边，所以整张图其实至多剩下 60 条边了！接下来直接跑一遍最小环即可，我使用的是 Floyd . 注意开 long long 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cctype&gt;#define min(a,b) ((a) &lt; (b) ? (a) : (b))#define int long longconst int N = 100010;const int M = 130; inline int read() &#123; char v = getchar();int x = 0,f = 1; while (!isdigit(v)) &#123;if (v == '-')f = -1;v = getchar();&#125; while (isdigit(v)) &#123;x = x * 10 + v - 48;v = getchar();&#125; return x * f;&#125; int a[N],pre[N],f[M][M],n,cnt,dis[M][M],ans = 0x3f3f3f3f;signed main() &#123; n = read(); for (int i = 1;i &lt;= n;++i) &#123; a[i] = read(); if (a[i] != 0) pre[++cnt] = a[i]; &#125; for (int i = 1;i &lt;= 64;++i) &#123; int cnt = 0; for (int j = 1;j &lt;= n;++j) &#123; if (a[j]&gt;&gt;(i-1)&amp;1) &#123; cnt++; &#125; &#125; if (cnt &gt;= 3) &#123; printf("3"); return 0; &#125; &#125; for (int i = 1;i &lt;= cnt;++i) &#123; for (int j = 1;j &lt;= cnt;++j) &#123; if (i != j &amp;&amp; (pre[i] &amp; pre[j]) != 0) &#123; f[i][j] = 1;dis[i][j] = 1; &#125; else &#123; f[i][j] = dis[i][j] = 0x3f3f3f3f; &#125; &#125; &#125; for (int k = 1;k &lt;= cnt;++k) &#123; for (int i = 1;i &lt; k;++i) &#123; for (int j = i+1;j &lt; k;++j) &#123; ans = min(dis[i][j] + f[i][k] + f[k][j],ans); &#125; &#125; for (int i = 1;i &lt;= cnt;++i) &#123; for (int j = 1;j &lt;= cnt;++j) &#123; dis[i][j] = min(dis[i][k]+dis[k][j],dis[i][j]); &#125; &#125; &#125; printf("%d\n",((ans&gt;=0x3f3f3f3f) ? -1 : ans));&#125;]]></content>
      <categories>
        <category>Codeforces赛后题解</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
        <tag>图论</tag>
        <tag>暴力</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces55D-Beautiful Numbers 解题报告]]></title>
    <url>%2F2019%2F08%2F13%2FCodeforces55D-Beautiful%20Numbers%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[题目链接Codeforces55D-Beautiful Numbers 题意简述定义“美丽的数字”为：被它自己的每一位数上的数整除的数 给定区间[L,R]，求有多少个美丽的数字 思路显然的数位DP，简单拉个板子就写完了.但是定义状态的时候发现会存不下，我们考虑压缩一下他们的状态。 引入两条重要的性质： 如果一个数能整除它的所有数位上的数，那么它一定能整除所有这些数位上的数的最小公倍数 而$1$到$9$的最小公倍数是$2520$，所有数可能形成的数位上所有数的最小公倍数一定是$2520$的因数 因为$lcm(1,2,3,4,5,6,7,8,9) = 2520$，所以直接定义$dp[i][j][k]$为前$i$位数$mod$$ 2520 = j$，前$i$位数的$lcm$为$j$。 然而，这样设计状态出来会发现总状态数达到了$2025202520 = 127008000$，显然存不下，我们再次考虑进行优化。观察到第二维还是会有冗余，手打个表可以发现总共只有48种可能性，再次进行压缩。 根据性质1，如果最后的数能整除$k$，那么它一定能整除它各位数字的最小公倍数。由于性质2，所有可能出现的$k$都是$2520$的因数，借助这一性质，将$j$取模$2520$，若所得的结果整除$k$，那么原来的数也一定整除$k$。所以转移方程就很自然的出来了： $f[i][j][k] = \sum f[i][lcm(k,x)][j*10+x \mod 2520|1 \leq x\leq Maxx]$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#define ll long long#define FILE A#define N 2520 + 1#define M 200inline ll read() &#123; char v = getchar();ll x = 0,f = 1; while (!isdigit(v)) &#123;if (v == '-')&#123;f = -1;&#125;v = getchar();&#125; while (isdigit(v)) &#123;x = x * 10 + v - 48;v = getchar();&#125; return x * f;&#125;ll dp[20][50][N],dig[N],ind[N],cnt,mod,num[N],l,r,c;ll gcd(int a,int b)&#123;return b?gcd(b,a%b):a;&#125;ll mylcm(int a,int b)&#123;return a/gcd(a,b)*b;&#125;ll dfs(ll now,ll lcm,ll sum,int limit) &#123; if (!now) &#123; return sum % lcm == 0; &#125; if (!limit &amp;&amp; dp[now][num[lcm]][sum] != -1) return dp[now][num[lcm]][sum]; ll ans = 0,ret = (limit)?dig[now]:9; for (ll i = 0;i &lt;= ret;++i) &#123; int lcm1 = i ? mylcm(lcm,i) : lcm; int sum1 = (sum * 10 + i) % mod; ans += dfs(now-1,lcm1,sum1,limit&amp;&amp;i==ret); &#125; if (!limit) &#123; dp[now][num[lcm]][sum] = ans; &#125; return ans;&#125;ll work(ll x) &#123; int len = 0; while (x) &#123; dig[++len] = x % 10;x /= 10; &#125; return dfs(len,1,0,1);&#125;int main() &#123; memset(dp,-1,sizeof(dp)); int T = read(); mod = 2520; for (int i = 1;i &lt;= mod;++i) &#123; if (mod % i == 0) &#123; num[i] = cnt++; &#125; &#125; while (T--) &#123; ll l = read(),r = read(); printf("%lld\n",work(r) - work(l-1)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>解题报告</category>
      </categories>
      <tags>
        <tag>数位DP</tag>
        <tag>DP</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经验教训]]></title>
    <url>%2F2019%2F08%2F11%2F%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD%2F</url>
    <content type="text"><![CDATA[多组数据一定要清空（@zgjjj） 在同样的数据范围($n \leq 1000$)下，跑$n$边Djikstra比Floyd快($O((n+m)^2 \log n)$与$O(n^3)$，如果有O2常数差不多)]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图论板子]]></title>
    <url>%2F2019%2F08%2F11%2F%E5%9B%BE%E8%AE%BA%E6%9D%BF%E5%AD%90%2F</url>
    <content type="text"><![CDATA[存图前向星存图，尽量不用结构体，绝对不用vector123456789int hd[N],edg[M],nxt[M],to[M],tot;inline void add(int u,int v,int w) &#123; edg[++tot] = w;to[tot] = v;nxt[tot] = hd[u];hd[u] = tot;&#125;inline void addedge(int u,int v,int w) &#123; add(u,v,w);add(v,u,w);&#125; 最短路Dijkstra带堆优化，时间复杂度$O(n\log n)$，在正权图以及SPFA被卡的情况适用 1234567891011121314151617181920212223242526272829303132struct node &#123; int dis,num; friend inline bool operator &lt; (const node &amp;a,const node &amp;b) &#123; return a.dis &gt; b.dis; &#125;&#125;;int dis[N],n,m,s;bool vis[N],hasfuhuan;void Dijkstra(int s) &#123; priority_queue &lt;node&gt; heap; memset(dis,INF,sizeof(dis)); heap.push((node)&#123;dis[s] = 0,s&#125;); while (!heap.empty()) &#123; node p = heap.top();heap.pop(); int x = p.num; if (vis[x]) &#123; continue; &#125; vis[x] = 1; for (int i = hd[x];i;i = nxt[i]) &#123; int y = to[i],w = edg[i]; if (dis[y] &gt; dis[x] + w) &#123; dis[y] = dis[x] + w; if (!vis[y]) &#123; heap.push((node)&#123;dis[y],y&#125;); &#125; &#125; &#125; &#125;&#125; SPFA最坏时间复杂度$O(nm)$，在证明不会被卡的时候用 12345678910111213141516171819void SPFA(int s) &#123; queue &lt;int&gt; q; vis[s] = 1;dis[s] = 0; q.push(s); while (!q.empty()) &#123; int x = q.front();q.pop(); vis[x] = 0; for (int i = hd[x];i;i = nxt[i]) &#123; int y = to[i],w = edg[i]; if (dis[y] &gt; dis[x] + w) &#123; dis[y] = dis[x] + w; if (!vis[y]) &#123; q.push(y); vis[y] = 1; &#125; &#125; &#125; &#125;&#125; Bellman-Ford稳定时间复杂度$O(nm)$，判负环用 因为不会SPFA判负环 123456789101112131415161718void Bellman_Ford(int s) &#123; memset(dis,INF,sizeof(dis)); dis[s] = 0; int cnt = 0,flag = 1; while (flag) &#123; for (int i = 0;i &lt; m;++i) &#123; flag = 0; int u = edges[i].u,v = edges[i].v,w = edges[i].w; if (dis[v] &gt; dis[u] + w) &#123; dis[v] = dis[u] + w; flag = 1; &#125; if (++cnt &gt; n) &#123; hasfuhuan = 1; &#125; &#125; &#125;&#125; 最小生成树菜的要死只会Kruskal Kruskal并查集+排序 时间复杂度$O(m\log m)$，对于边数较少的图适用 1234567891011121314151617181920212223242526272829//Union-Find Setint f[N];int find(int x) &#123; return f[x] == x ? f[x]:f[x] = find(f[x]);&#125;//Kruskalstruct edge &#123; int u,v,w; friend inline bool operator &lt; (const edge &amp;a,const edge &amp;b) &#123; return a.w &lt; b.w; &#125;&#125;edges[M];int Kruskal() &#123; int tot = 0,ans = 0; sort(edges+1,edges+1+n); for (int i = 1;i &lt;= m;++i) &#123; int u = edges[i].u,v = edges[i].v,w = edges[i].w; if (find(u) != find(v)) &#123; ans += w; ++tot; &#125; if (tot == n-1) &#123; break; &#125; &#125; return ans;&#125; 拓扑排序用来巧妙求解DAGdp等，利用BFS实现，同样可以用DFS实现 12345678910111213141516int cnt[N];void toposort(int s) &#123; queue &lt;int&gt; q; for (int i = 1;i &lt;= n;++i) &#123; if (!cnt[i]) q.push(i); &#125; while (!q.empty()) &#123; int u = q.front(); for (int i = hd[u];i;i = nxt[i]) &#123; int v = to[i]; if (--cnt[v] == 0) &#123; q.push(v); &#125; &#125; &#125;&#125; 树链剖分树链剖分这个OIer很强 快速求解树上问题，具体应用请看树链剖分 学习笔记 12345678910111213141516171819202122232425262728293031323334353637int dfn[N],top[N],siz[N],son[N],dep[N],fat[N];void dfs1(int u,int f) &#123; son[u] = 0; siz[u] = 1; dep[u] = dep[f] + 1; fat[u] = f; for (int i = hd[u];i;i = nxt[i]) &#123; int v = to[i],w = edg[i]; if (v != f) &#123; dfs(v,u); siz[u] += siz[v]; if (siz[v] &gt; siz[son[u]]) &#123; son[u] = v; &#125; &#125; &#125;&#125;void dfs2(int u,int f) &#123; dfn[u] = ++cnt; if (u == son[f]) &#123; top[u] = top[f]; &#125; else &#123; top[u] = u; &#125; if (son[u]) &#123; dfs2(son[u],u); &#125; for (int i = hd[u];i;i = nxt[i]) &#123; int v = to[i],w = edg[i]; if (v != f &amp;&amp; v != son[u]) &#123; dfs2(v,u); &#125; &#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>MST</tag>
        <tag>并查集</tag>
        <tag>拓扑排序</tag>
        <tag>最短路</tag>
        <tag>负环</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
</search>
