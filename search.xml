<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Codeforces55D-Beautiful Numbers 解题报告]]></title>
    <url>%2F2019%2F08%2F13%2FCodeforces55D-Beautiful%20Numbers%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[题目链接Codeforces55D-Beautiful Numbers 题意简述定义“美丽的数字”为：被它自己的每一位数上的数整除的数 给定区间[L,R]，求有多少个美丽的数字 思路显然的数位DP，简单拉个板子就写完了.但是定义状态的时候发现会存不下，我们考虑压缩一下他们的状态。 引入两条重要的性质： 如果一个数能整除它的所有数位上的数，那么它一定能整除所有这些数位上的数的最小公倍数 而$1$到$9$的最小公倍数是$2520$，所有数可能形成的数位上所有数的最小公倍数一定是$2520$的因数 因为$lcm(1,2,3,4,5,6,7,8,9) = 2520$，所以直接定义$dp[i][j][k]$为前$i$位数$mod$$ 2520 = j$，前$i$位数的$lcm$为$j$。 然而，这样设计状态出来会发现总状态数达到了$2025202520 = 127008000$，显然存不下，我们再次考虑进行优化。观察到第二维还是会有冗余，手打个表可以发现总共只有48种可能性，再次进行压缩。 根据性质1，如果最后的数能整除$k$，那么它一定能整除它各位数字的最小公倍数。由于性质2，所有可能出现的$k$都是$2520$的因数，借助这一性质，将$j$取模$2520$，若所得的结果整除$k$，那么原来的数也一定整除$k$。所以转移方程就很自然的出来了： $f[i][j][k] = \sum f[i][lcm(k,x)][j*10+x \mod 2520|1 \leq x\leq Maxx]$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#define ll long long#define FILE A#define N 2520 + 1#define M 200inline ll read() &#123; char v = getchar();ll x = 0,f = 1; while (!isdigit(v)) &#123;if (v == '-')&#123;f = -1;&#125;v = getchar();&#125; while (isdigit(v)) &#123;x = x * 10 + v - 48;v = getchar();&#125; return x * f;&#125;ll dp[20][50][N],dig[N],ind[N],cnt,mod,num[N],l,r,c;ll gcd(int a,int b)&#123;return b?gcd(b,a%b):a;&#125;ll mylcm(int a,int b)&#123;return a/gcd(a,b)*b;&#125;ll dfs(ll now,ll lcm,ll sum,int limit) &#123; if (!now) &#123; return sum % lcm == 0; &#125; if (!limit &amp;&amp; dp[now][num[lcm]][sum] != -1) return dp[now][num[lcm]][sum]; ll ans = 0,ret = (limit)?dig[now]:9; for (ll i = 0;i &lt;= ret;++i) &#123; int lcm1 = i ? mylcm(lcm,i) : lcm; int sum1 = (sum * 10 + i) % mod; ans += dfs(now-1,lcm1,sum1,limit&amp;&amp;i==ret); &#125; if (!limit) &#123; dp[now][num[lcm]][sum] = ans; &#125; return ans;&#125;ll work(ll x) &#123; int len = 0; while (x) &#123; dig[++len] = x % 10;x /= 10; &#125; return dfs(len,1,0,1);&#125;int main() &#123; memset(dp,-1,sizeof(dp)); int T = read(); mod = 2520; for (int i = 1;i &lt;= mod;++i) &#123; if (mod % i == 0) &#123; num[i] = cnt++; &#125; &#125; while (T--) &#123; ll l = read(),r = read(); printf("%lld\n",work(r) - work(l-1)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>解题报告</category>
      </categories>
      <tags>
        <tag>数位DP</tag>
        <tag>DP</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经验教训]]></title>
    <url>%2F2019%2F08%2F11%2F%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD%2F</url>
    <content type="text"><![CDATA[多组数据一定要清空（@zgjjj） 在同样的数据范围($n \leq 1000$)下，跑$n$边Djikstra比Floyd快($O((n+m)^2 \log n)$与$O(n^3)$，如果有O2常数差不多)]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图论板子]]></title>
    <url>%2F2019%2F08%2F11%2F%E5%9B%BE%E8%AE%BA%E6%9D%BF%E5%AD%90%2F</url>
    <content type="text"><![CDATA[存图前向星存图，尽量不用结构体，绝对不用vector 123456789int hd[N],edg[M],nxt[M],to[M],tot;inline void add(int u,int v,int w) &#123; edg[++tot] = w;to[tot] = v;nxt[tot] = hd[u];hd[u] = tot;&#125;inline void addedge(int u,int v,int w) &#123; add(u,v,w);add(v,u,w);&#125; 最短路Dijkstra带堆优化，时间复杂度$O(n\log n)$，在正权图以及SPFA被卡的情况适用 1234567891011121314151617181920212223242526272829303132struct node &#123; int dis,num; friend inline bool operator &lt; (const node &amp;a,const node &amp;b) &#123; return a.dis &gt; b.dis; &#125;&#125;;int dis[N],n,m,s;bool vis[N],hasfuhuan;void Dijkstra(int s) &#123; priority_queue &lt;node&gt; heap; memset(dis,INF,sizeof(dis)); heap.push((node)&#123;dis[s] = 0,s&#125;); while (!heap.empty()) &#123; node p = heap.top();heap.pop(); int x = p.num; if (vis[x]) &#123; continue; &#125; vis[x] = 1; for (int i = hd[x];i;i = nxt[i]) &#123; int y = to[i],w = edg[i]; if (dis[y] &gt; dis[x] + w) &#123; dis[y] = dis[x] + w; if (!vis[y]) &#123; heap.push((node)&#123;dis[y],y&#125;); &#125; &#125; &#125; &#125;&#125; SPFA最坏时间复杂度$O(nm)$，在证明不会被卡的时候用 12345678910111213141516171819void SPFA(int s) &#123; queue &lt;int&gt; q; vis[s] = 1;dis[s] = 0; q.push(s); while (!q.empty()) &#123; int x = q.front();q.pop(); vis[x] = 0; for (int i = hd[x];i;i = nxt[i]) &#123; int y = to[i],w = edg[i]; if (dis[y] &gt; dis[x] + w) &#123; dis[y] = dis[x] + w; if (!vis[y]) &#123; q.push(y); vis[y] = 1; &#125; &#125; &#125; &#125;&#125; Bellman-Ford稳定时间复杂度$O(nm)$，判负环用 因为不会SPFA判负环 123456789101112131415161718void Bellman_Ford(int s) &#123; memset(dis,INF,sizeof(dis)); dis[s] = 0; int cnt = 0,flag = 1; while (flag) &#123; for (int i = 0;i &lt; m;++i) &#123; flag = 0; int u = edges[i].u,v = edges[i].v,w = edges[i].w; if (dis[v] &gt; dis[u] + w) &#123; dis[v] = dis[u] + w; flag = 1; &#125; if (++cnt &gt; n) &#123; hasfuhuan = 1; &#125; &#125; &#125;&#125; 最小生成树菜的要死只会Kruskal Kruskal并查集+排序 时间复杂度$O(m\log m)$，对于边数较少的图适用 1234567891011121314151617181920212223242526272829//Union-Find Setint f[N];int find(int x) &#123; return f[x] == x ? f[x]:f[x] = find(f[x]);&#125;//Kruskalstruct edge &#123; int u,v,w; friend inline bool operator &lt; (const edge &amp;a,const edge &amp;b) &#123; return a.w &lt; b.w; &#125;&#125;edges[M];int Kruskal() &#123; int tot = 0,ans = 0; sort(edges+1,edges+1+n); for (int i = 1;i &lt;= m;++i) &#123; int u = edges[i].u,v = edges[i].v,w = edges[i].w; if (find(u) != find(v)) &#123; ans += w; ++tot; &#125; if (tot == n-1) &#123; break; &#125; &#125; return ans;&#125; 拓扑排序用来巧妙求解DAGdp等，利用BFS实现，同样可以用DFS实现 12345678910111213141516int cnt[N];void toposort(int s) &#123; queue &lt;int&gt; q; for (int i = 1;i &lt;= n;++i) &#123; if (!cnt[i]) q.push(i); &#125; while (!q.empty()) &#123; int u = q.front(); for (int i = hd[u];i;i = nxt[i]) &#123; int v = to[i]; if (--cnt[v] == 0) &#123; q.push(v); &#125; &#125; &#125;&#125; 树链剖分树链剖分这个OIer很强 快速求解树上问题，具体应用请看《树链剖分 学习笔记》（咕咕咕） 12345678910111213141516171819202122232425262728293031323334353637int dfn[N],top[N],siz[N],son[N],dep[N],fat[N];void dfs1(int u,int f) &#123; son[u] = 0; siz[u] = 1; dep[u] = dep[f] + 1; fat[u] = f; for (int i = hd[u];i;i = nxt[i]) &#123; int v = to[i],w = edg[i]; if (v != f) &#123; dfs(v,u); siz[u] += siz[v]; if (siz[v] &gt; siz[son[u]]) &#123; son[u] = v; &#125; &#125; &#125;&#125;void dfs2(int u,int f) &#123; dfn[u] = ++cnt; if (u == son[f]) &#123; top[u] = top[f]; &#125; else &#123; top[u] = u; &#125; if (son[u]) &#123; dfs2(son[u],u); &#125; for (int i = hd[u];i;i = nxt[i]) &#123; int v = to[i],w = edg[i]; if (v != f &amp;&amp; v != son[u]) &#123; dfs2(v,u); &#125; &#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MST</tag>
        <tag>并查集</tag>
        <tag>图论</tag>
        <tag>拓扑排序</tag>
        <tag>最短路</tag>
        <tag>负环</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
</search>
