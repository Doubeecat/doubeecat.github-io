<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ACwing 92 93 94 解题报告</title>
    <url>/2020/04/06/ACwing-%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.acwing.com/problem/content/94/" target="_blank" rel="noopener">递归实现指数型枚举</a></p>
<p><a href="https://www.acwing.com/problem/content/95/" target="_blank" rel="noopener">递归实现组合型枚举</a></p>
<p><a href="https://www.acwing.com/problem/content/96/" target="_blank" rel="noopener">递归实现排列型枚举</a></p>
<p>指数型：在 $1-n$ 这 $n$ 个整数中随机选取任意多个，输出所有可能的次序。</p>
<p>组合型：从 $1- n$ 这 $n$ 个整数中随机选出 $m$ 个，输出所有可能的选择方案。</p>
<p>排列型：把 $1-n$ 这 $n$ 个整数排成一行后随机打乱顺序，输出所有可能的次序。</p>
</blockquote>
<a id="more"></a>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>这三题的思路大致一致，所以放在一起来写。</p>
<p>指数型：很明显，这个问题可以转化成：</p>
<p>有 $n$ 个整数，每个整数可以选可以不选，求总共有几种方案。</p>
<p>我们可以使用递归来求解问题，每次递归时，我们有两条路：“选”，”不选”</p>
<p>放在代码里就是这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">v.push_back(p);<span class="comment">//选择这个数</span></span><br><span class="line">calc(x+<span class="number">1</span>);<span class="comment">//选择这个数的分支</span></span><br><span class="line">v.pop_back();<span class="comment">//还原现场</span></span><br><span class="line"></span><br><span class="line">calc(x+<span class="number">1</span>);<span class="comment">//不选这个数的分支</span></span><br></pre></td></tr></table></figure>
<p>而每次递归后，我们面对的问题规模（还剩几个数需要选）-1，变成一个规模更小的问题，所以可以用递归求解。</p>
<p>组合型：这个问题和上一个本质一样，我们只要加入更多的限制条件：</p>
<ol>
<li>当当前选取的数数量大于 $m$ 时，不再选数。</li>
<li>当剩下的数全选也不够 $m$ 时，不再选数。</li>
</ol>
<p>放在代码里就是这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (v.size() &gt; m || v.size + (n-x+<span class="number">1</span>) &lt; m) <span class="keyword">return</span> ;</span><br></pre></td></tr></table></figure>
<p>排列性：这里，我们的问题就变成了：</p>
<p>把 $n$ 个整数按照任意次序排列</p>
<p>递归中，我们每次选取一个数放在当前位置，问题就变成了：把 $n-1$ 个整数按照任意次序排列，所以可以用递归来做</p>
<p>放在代码里就是这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!chos[i]) &#123;</span><br><span class="line">			ord[x] = i;</span><br><span class="line">			chos[i] = <span class="number">1</span>;</span><br><span class="line">			calc(x+<span class="number">1</span>);</span><br><span class="line">			chos[i] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p> 指数型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; chosen;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">choice</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == x+<span class="number">1</span>) &#123;</span><br><span class="line">        fp(i,<span class="number">0</span>,chosen.size()) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,chosen[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    choice(n+<span class="number">1</span>);</span><br><span class="line">    chosen.push_back(n);</span><br><span class="line">    choice(n+<span class="number">1</span>);</span><br><span class="line">    chosen.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x = read();</span><br><span class="line">    choice(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>组合型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">c</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (v.size() == m) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>;i &lt; v.size();++i) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d "</span>,v[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (v.size() &gt; m || v.size() + (n - x + <span class="number">1</span>) &lt; m) &#123;<span class="comment">//判断边界，第一个是判断当前是否大于m个了，第二个判断是否选不够</span></span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;	</span><br><span class="line">	v.push_back(x);</span><br><span class="line">	c(x+<span class="number">1</span>);</span><br><span class="line">	v.pop_back();</span><br><span class="line">	c(x+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = read(),m = read();</span><br><span class="line">	c(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>排列型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n,ord[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">bool</span> chos[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x == n+<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d "</span>,ord[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!chos[i]) &#123;</span><br><span class="line">			ord[x] = i;</span><br><span class="line">			chos[i] = <span class="number">1</span>;</span><br><span class="line">			calc(x+<span class="number">1</span>);</span><br><span class="line">			chos[i] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = read();</span><br><span class="line">	calc(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>解题报告</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>解题报告 AcWing 102. 最佳牛围栏</title>
    <url>/2020/05/22/Acwing102/</url>
    <content><![CDATA[<blockquote>
<p>给你一个长度为 $n$ 的数列，求出这个数列的平均数最大且长度不小于$L$的连续子段。 </p>
</blockquote>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先思考一下怎么快速的求一个子序列平均数最大的问题：<br>在一个数列$a_1…a_n$中，求一个平均数最大的连续子段。<br>我们可以观察到一个性质：设$a$的平均数为$p$<br>则$a_i = p + (a_i-p)$，令 $b_i = a_i - p$ 显然有 $\sum^n_{i=1} b_i = 0$<br>所以我们可以利用$b_i$来判断是否为真正的平均数。<br>若$\sum^n_{i=1} b_i &lt; 0$，说明 $p$ 比真正的平均数大了。<br>若$\sum^n_{i=1} b_i &gt; 0$，说明 $p$ 比真正的平均数小了。<br>而我们可以发现，最终的答案 $p$ 具有单调性：<br>设当前结果为$s$，若$s &lt; p$，一定有更大的平均值<br>若$s &gt; p$，则它的长度就是错的。<br>所以我们可以简单的利用上面两个结论进行二分答案。<br>回归题目，我们发现，如果要让 $p$ 最大，则要找到一个 $\sum^r_{i=l}$ 最大的字段。<br>问题就被转化为了求一个数列的长度不小于$L$的最大子段和。<br>$O(n)$ 求最大子段和显然不用我多讲，加上一个限制也并不难推导。<br>因为当前位置的答案只能由之前$1…i-L$的答案来得出，也就是说，随着$i$的增长，我们的决策集合每次只会增大1，开个变量随便维护下就完了。<br>这里借用lyd老师的柿子，$sum_i$表示$i$的前缀和。</p>
<script type="math/tex; mode=display">\max_{i-j\geq L} \{a_{j+1}+...+a_i\} = \max_{L\leq i\leq n} \{sum_i - \min_{0\leq j \leq i-L} sum_j\}</script><p>这里就涵盖了一个化归的思想，巧妙地将难题转化为了一个见过的题目。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ri register int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">min</span><span class="params">(T x,T y)</span> </span>&#123;<span class="keyword">return</span> x&lt;y?x:y;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">max</span><span class="params">(T x,T y)</span> </span>&#123;<span class="keyword">return</span> x&gt;y?x:y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">double</span> a[N],sum[N],b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) &#123;</span><br><span class="line">        b[i] = a[i] - mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) &#123;</span><br><span class="line">        sum[i] = sum[i<span class="number">-1</span>] + b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> minn = <span class="number">1e10</span>,maxx = <span class="number">-1e10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m;i &lt;= n;++i) &#123;</span><br><span class="line">        minn = min(minn,sum[i-m]);</span><br><span class="line">        maxx = max(maxx,sum[i]-minn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (maxx &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">double</span> l = <span class="number">-1e6</span>,r = <span class="number">1e6</span>;</span><br><span class="line">    <span class="keyword">while</span> (r-l &gt; eps) &#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">int</span>(r*<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>CF1336A Linova and Kingdom 解题报告</title>
    <url>/2020/04/16/CF1336A/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://codeforces.ml/contest/1337/problem/C" target="_blank" rel="noopener">CF1336A/CF1337C</a></p>
<p>有一个有 $n$ 个点的树，以 1 为根，你可以选择 $k$ 个节点，使得这 $k$ 个节点到 1 节点的最短路径中经过的非选择的点最多。</p>
</blockquote>
<a id="more"></a>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>先约定：<br>$siz_v$ 为以 $v$ 为根的子树大小，当 $v$ 为叶子节点时，$siz_v = 1$。。<br>$dep_v$ 为从根到 $v$ 的最短路径长度（即深度）。  </p>
<p>首先我们可以发现，这里每选择一个点是会对它的子树造成影响。<br>例如这里：<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/52wr03fh.png" alt=""><br>如果我们已经选择了 4,5，那么如果再选择 2， 4,5 到根节点的权值就会各 -1。<br>所以我们不止要简单的计算深度最大的，而且要计算它的子树大小最小的。<br>因此，我们设一个点的贡献为 $f_v$，$f_v = dep_v - siz_v$,最后对 $f_i$ 排序求出最小的 $k$ 个值相加即可。<br>显然对于 $dep_i$ 和 $siz_i$ 我们可以通过一遍 DFS 求出来<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">	a[s].dep = a[f].dep+<span class="number">1</span>,a[s].siz = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = hd[s];i;i = nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">int</span> v = to[i];</span><br><span class="line">		<span class="keyword">if</span> (v == f) <span class="keyword">continue</span>;</span><br><span class="line">		dfs1(v,s);</span><br><span class="line">		a[s].siz += a[v].siz;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>之后就是简单的计算 $f_i$ 的过程了，不再多说。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//本代码是赛时代码，可能有些变量名称不一样，但大体思路一致。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long<span class="comment">//答案会超出int的范围</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ri register int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> v = getchar();<span class="keyword">int</span> x = <span class="number">0</span>,f = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(v)) &#123;<span class="keyword">if</span> (v == <span class="string">'-'</span>)f = <span class="number">-1</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(v)) &#123;x = x * <span class="number">10</span> + v - <span class="number">48</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">500001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> to[M],hd[N],nxt[M],tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;to[++tot] = v;nxt[tot] = hd[u];hd[u] = tot;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;add(u,v),add(v,u);&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> dep,siz;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="comment">//a[i].dep 存的是 dep[i] a[i].siz 存的是 siz[i] </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a.dep-a.siz)&gt;(b.dep-b.siz);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按照dep[i] - siz[i]（也就是f[i]）排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">	a[s].dep = a[f].dep+<span class="number">1</span>,a[s].siz = <span class="number">1</span>;<span class="comment">//计算dep和siz</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = hd[s];i;i = nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">int</span> v = to[i];</span><br><span class="line">		<span class="keyword">if</span> (v == f) <span class="keyword">continue</span>;</span><br><span class="line">		dfs1(v,s);</span><br><span class="line">		a[s].siz += a[v].siz;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,k,ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = read(),k = read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = read(),y = read();</span><br><span class="line">		addedge(x,y);</span><br><span class="line">	&#125;</span><br><span class="line">	a[<span class="number">0</span>].dep = <span class="number">0</span>,a[<span class="number">0</span>].siz = <span class="number">0</span>;</span><br><span class="line">	dfs1(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);<span class="comment">//排序</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= k;++i) &#123;</span><br><span class="line">		ans += (a[i].dep - a[i].siz);</span><br><span class="line">	&#125;<span class="comment">//选前k个</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>树上问题</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForcesRound#1206题解</title>
    <url>/2019/08/22/CodeForcesRound-1206%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="A-Choose-Two-Numbers"><a href="#A-Choose-Two-Numbers" class="headerlink" title="A. Choose Two Numbers"></a>A. <a href="https://codeforces.com/contest/1206/problem/A" target="_blank" rel="noopener">Choose Two Numbers</a></h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给你两个集合 $A,B$, 要求你分别从$A,B$中取出一个数，使得两数之和不在$A$中也不在$B$中</p>
<p>$n ,m\leq 100$<br><a id="more"></a></p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>看数据范围应该很容易想出来一个 $O(nm(n+m))$ 的暴力，枚举 $A,B$ 中的每一个数，将他们相加之后再在两个集合中判定一下，这个题就完了。事实上由于$n ,m\leq 100$ 可以轻松通过本题。</p>
<p>但是显然，还会有更好的解法，我们可以观察到，如果选取这两个集合中最大的数相加，显然这个和不会出现在两个集合里面，复杂度下降到了 $O(m \log {m} + n \log {n})  $  如果用排序还可以达到$O(m+n)$的线性时间复杂度(排序是作者给出的解法，实际上可以直接读入的时候求出)</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><p> $O(nm(n+m))$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> v = getchar();<span class="keyword">int</span> x = <span class="number">0</span>,f = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(v)) &#123;<span class="keyword">if</span>(v == <span class="string">'-'</span>)f = <span class="number">-1</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(v)) &#123;x = x * <span class="number">10</span> + v - <span class="number">48</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N],b[N],n,m,a1,a2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) &#123;</span><br><span class="line">		a[i] = read();</span><br><span class="line">	&#125;</span><br><span class="line">	m = read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;++i) &#123;</span><br><span class="line">		b[i] = read();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;++j) &#123;</span><br><span class="line">			a1 = a[i],a2 = b[j];</span><br><span class="line">			<span class="keyword">int</span> sum = a1 + a2;<span class="keyword">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= n;++k) &#123;</span><br><span class="line">				<span class="keyword">if</span> (sum == a[k]) &#123;</span><br><span class="line">					flag = <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= m;++k) &#123;</span><br><span class="line">				<span class="keyword">if</span> (sum == b[k]) &#123;</span><br><span class="line">					flag = <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,a1,a2);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> $O(m + n)  $ </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::max;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> v = getchar();<span class="keyword">int</span> x = <span class="number">0</span>,f = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(v)) &#123;<span class="keyword">if</span>(v == <span class="string">'-'</span>)f = <span class="number">-1</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(v)) &#123;x = x * <span class="number">10</span> + v - <span class="number">48</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> tmp,a,b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) &#123;</span><br><span class="line">		tmp = read();</span><br><span class="line">        a = max(a,tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	m = read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;++i) &#123;</span><br><span class="line">		tmp = read();</span><br><span class="line">        b = max(b,tmp);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d"</span>,a,b);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="B-Make-Product-Equal-One"><a href="#B-Make-Product-Equal-One" class="headerlink" title="B. Make Product Equal One"></a>B. <a href="https://codeforces.com/contest/1206/problem/B" target="_blank" rel="noopener">Make Product Equal One</a></h2><h3 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给你一个有 $n$ 个数字的数列，你有两种操作：将某个数 $+1$ 或 $-1$ 。求用最小的操作次数让这个数列的每一项乘起来等于 1</p>
<p>$n \leq 10^5$</p>
<h3 id="解题思路：-1"><a href="#解题思路：-1" class="headerlink" title="解题思路："></a>解题思路：</h3><p><del>用C换来的</del></p>
<p>分析一下，每个数字只有两种情况：变成 1 或者变成 -1 </p>
<p>所以每个数字的代价就是<code>min(abs(1 - a[i]),abs(-1 - a[i]))</code></p>
<p>值得一提的几个<del>大坑</del>点是，最后可能会变成 -1 ，所以顺便记一下，如果最后变成 -1 了记得加上 2 。而且 0 也要记，最后要加上 0 的个数。</p>
<p>时间复杂度$O(n)$</p>
<h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> v = getchar();<span class="keyword">int</span> x = <span class="number">0</span>,f = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(v)) &#123;<span class="keyword">if</span>(v == <span class="string">'-'</span>)f = <span class="number">-1</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(v)) &#123;x = x * <span class="number">10</span> + v - <span class="number">48</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pre[N],n,p1,p2,ans,z,res = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) &#123;</span><br><span class="line">		pre[i] = read();</span><br><span class="line">		<span class="keyword">if</span> (pre[i] == <span class="number">0</span>) &#123;</span><br><span class="line">			z++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(pre+<span class="number">1</span>,pre+<span class="number">1</span>+n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (pre[i] &lt;= <span class="number">-1</span>) &#123;</span><br><span class="line">			ans += (<span class="number">-1</span> - pre[i]);</span><br><span class="line">			res *= <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (pre[i] &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">			ans += (pre[i] - <span class="number">1</span>);</span><br><span class="line">			res *= <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (z) &#123;</span><br><span class="line">			ans += z;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			ans += <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		ans += z;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-Almost-Equal"><a href="#C-Almost-Equal" class="headerlink" title="C. Almost Equal"></a>C. <a href="https://codeforces.com/contest/1205/problem/A" target="_blank" rel="noopener">Almost Equal</a></h2><h3 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个数字 $n$ ，要求你使用 $1…2*n$ 的数字构造出一个环，使得这个环每三个数相加的和之间差不超过 1.</p>
<h3 id="解题思路：-2"><a href="#解题思路：-2" class="headerlink" title="解题思路："></a>解题思路：</h3><p>偶数显然不能构造，奇数按照样例构造即可，具体看代码</p>
<h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::min;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> v = getchar();<span class="keyword">int</span> x = <span class="number">0</span>,f = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(v)) &#123;<span class="keyword">if</span>(v == <span class="string">'-'</span>)f = <span class="number">-1</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(v)) &#123;x = x * <span class="number">10</span> + v - <span class="number">48</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pre[N],n,now = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = read();</span><br><span class="line">	<span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"NO"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">2</span>*n;++i) &#123;</span><br><span class="line">		pre[now] = i;</span><br><span class="line">		<span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">			now += <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> ((i / <span class="number">2</span>) % <span class="number">2</span>) &#123;</span><br><span class="line">				now -= n;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				now += n;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">2</span>*n;++i) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,pre[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="D-Shortest-Circle"><a href="#D-Shortest-Circle" class="headerlink" title="D. Shortest Circle"></a>D. <a href="https://codeforces.com/contest/1205/problem/B" target="_blank" rel="noopener">Shortest Circle</a></h2><h3 id="题目描述：-3"><a href="#题目描述：-3" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给你 $n$ 个点，每个点有一个点权，两点之间有边当且仅当 $a[i] \&amp; a[j] \ne 0$ ，求出图中最小环的长度。</p>
<p>$n \leq 100000,a_i \leq 10^{18}$</p>
<h3 id="解题思路：-3"><a href="#解题思路：-3" class="headerlink" title="解题思路："></a>解题思路：</h3><p>直接构造显然是 $O(n^2)$ 的，考虑优化建边的过程。</p>
<p>首先可以观察到，如果二进制内某一位有 3 个 1 ，那么肯定有一个长度为 3 的环，直接输出即可。</p>
<p>那么现在问题简化为了每位至多有两个 1 的情况，我们可以发现每一位最多只有一条边，所以整张图其实至多剩下 60 条边了！接下来直接跑一遍最小环即可，我使用的是 Floyd .</p>
<p>注意开 long long</p>
<h3 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b) ((a) &lt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">130</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> v = getchar();<span class="keyword">int</span> x = <span class="number">0</span>,f = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(v)) &#123;<span class="keyword">if</span> (v == <span class="string">'-'</span>)f = <span class="number">-1</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(v)) &#123;x = x * <span class="number">10</span> + v - <span class="number">48</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> a[N],pre[N],f[M][M],n,cnt,dis[M][M],ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) &#123;</span><br><span class="line">		a[i] = read();</span><br><span class="line">		<span class="keyword">if</span> (a[i] != <span class="number">0</span>) pre[++cnt] = a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">64</span>;++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (a[j]&gt;&gt;(i<span class="number">-1</span>)&amp;<span class="number">1</span>) &#123;</span><br><span class="line">				cnt++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (cnt &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"3"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= cnt;++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= cnt;++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i != j &amp;&amp; (pre[i] &amp; pre[j]) != <span class="number">0</span>) &#123;</span><br><span class="line">				f[i][j] = <span class="number">1</span>;dis[i][j] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				f[i][j] = dis[i][j] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= cnt;++k) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; k;++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>;j &lt; k;++j) &#123;</span><br><span class="line">				ans = min(dis[i][j] + f[i][k] + f[k][j],ans);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= cnt;++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= cnt;++j) &#123;</span><br><span class="line">				dis[i][j] = min(dis[i][k]+dis[k][j],dis[i][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,((ans&gt;=<span class="number">0x3f3f3f3f</span>) ? <span class="number">-1</span> : ans));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Codeforces赛后题解</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
        <tag>图论</tag>
        <tag>暴力</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces55D-Beautiful Numbers  解题报告</title>
    <url>/2019/08/13/Codeforces55D-Beautiful%20Numbers%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<blockquote>
<p><a href="http://codeforces.com/problemset/problem/55/D" target="_blank" rel="noopener">Codeforces55D-Beautiful Numbers</a></p>
<p>定义“美丽的数字”为：被它自己的每一位数上的数整除的数</p>
<p>给定区间$[L,R]$，求有多少个美丽的数字</p>
</blockquote>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>显然的数位DP，简单拉个板子就写完了.但是定义状态的时候发现会存不下，我们考虑压缩一下他们的状态。</p>
<p>引入两条重要的性质：</p>
<ol>
<li>如果一个数能整除它的所有数位上的数，那么它一定能整除所有这些数位上的数的最小公倍数</li>
<li>而$1$到$9$的最小公倍数是$2520$，所有数可能形成的数位上所有数的最小公倍数一定是$2520$的因数</li>
</ol>
<p>因为$lcm(1,2,3,4,5,6,7,8,9) = 2520$，所以直接定义$dp[i][j][k]$为前$i$位数$mod$$  2520 = j$，前$i$位数的$lcm$为$j$。</p>
<p>然而，这样设计状态出来会发现总状态数达到了$20<em>2520</em>2520 = 127008000$，显然存不下，我们再次考虑进行优化。观察到第二维还是会有冗余，手打个表可以发现总共只有48种可能性，再次进行压缩。</p>
<p>根据性质1，如果最后的数能整除$k$，那么它一定能整除它各位数字的最小公倍数。由于性质2，所有可能出现的$k$都是$2520$的因数，借助这一性质，将$j$取模$2520$，若所得的结果整除$k$，那么原来的数也一定整除$k$。所以转移方程就很自然的出来了：</p>
<p>$f[i][j][k] = \sum f[i][lcm(k,x)][j*10+x \mod 2520|1 \leq x\leq Maxx]$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE A</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2520 + 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 200</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> v = getchar();ll x = <span class="number">0</span>,f = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(v)) &#123;<span class="keyword">if</span> (v == <span class="string">'-'</span>)&#123;f = <span class="number">-1</span>;&#125;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(v)) &#123;x = x * <span class="number">10</span> + v - <span class="number">48</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line">ll dp[<span class="number">20</span>][<span class="number">50</span>][N],dig[N],ind[N],cnt,mod,num[N],l,r,c;<span class="function">ll <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?gcd(b,a%b):a;&#125;</span><br><span class="line"><span class="function">ll <span class="title">mylcm</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a/gcd(a,b)*b;&#125;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(ll now,ll lcm,ll sum,<span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!now) &#123;</span><br><span class="line">		<span class="keyword">return</span> sum % lcm == <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!limit &amp;&amp; dp[now][num[lcm]][sum] != <span class="number">-1</span>) <span class="keyword">return</span> dp[now][num[lcm]][sum];</span><br><span class="line">	ll ans = <span class="number">0</span>,ret = (limit)?dig[now]:<span class="number">9</span>;</span><br><span class="line">	<span class="keyword">for</span> (ll i = <span class="number">0</span>;i &lt;= ret;++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> lcm1 = i ? mylcm(lcm,i) : lcm;</span><br><span class="line">		<span class="keyword">int</span> sum1 = (sum * <span class="number">10</span> + i) % mod;</span><br><span class="line">		ans += dfs(now<span class="number">-1</span>,lcm1,sum1,limit&amp;&amp;i==ret);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">if</span> (!limit) &#123;</span><br><span class="line">		dp[now][num[lcm]][sum] = ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">work</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (x) &#123;</span><br><span class="line">		dig[++len] = x % <span class="number">10</span>;x /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dfs(len,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">	<span class="keyword">int</span> T = read();</span><br><span class="line">	mod = <span class="number">2520</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= mod;++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (mod % i == <span class="number">0</span>) &#123;</span><br><span class="line">			num[i] = cnt++;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		ll l = read(),r = read();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,work(r) - work(l<span class="number">-1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>解题报告</category>
      </categories>
      <tags>
        <tag>数位DP</tag>
        <tag>DP</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>Luogu1840 Color the Axis_NOI导刊2011提高（05） 解题报告</title>
    <url>/2019/09/22/ColortheAxis/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.luogu.org/problem/P1840" target="_blank" rel="noopener">Color the Axis_NOI导刊2011提高（05）</a></p>
<p>在一条数轴上有$N$个点，分别是$1 \rightarrow N$。一开始所有的点都被染成黑色。接着我们进行$M$次操作，第$i$次操作将$[L_i,R_i]$这些点染成白色。请输出每个操作执行后剩余黑色点的个数。</p>
</blockquote>
<a id="more"></a>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>这个题的思路很简单，把黑色的部分当成1，白色的部分当成0来处理，使用支持区间修改，区间查询的数据结构维护一下即可。  </p>
<p>如果你和我一样是写线段树的，那么更简单了，在下传lazytag的时候只需要将其的左右节点清零即可。</p>
<p>另外在区间查询时由于每次都是查整段的，所以只需要输出<code>tree[1].num</code>即可</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">500010</span>&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">0</span>,f = <span class="number">1</span>;<span class="keyword">char</span> v = getchar();</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(v)) &#123;<span class="keyword">if</span> (v ==<span class="string">'-'</span>) f = <span class="number">-1</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(v)) &#123;x = x * <span class="number">10</span> + v - <span class="number">48</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> l,r,num,tag;</span><br><span class="line">&#125;tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	tree[p].l = l;tree[p].r = r;</span><br><span class="line">	<span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">		tree[p].num = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	build (p &lt;&lt; <span class="number">1</span>,l,mid);</span><br><span class="line">	build (p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>,mid + <span class="number">1</span>,r);</span><br><span class="line">	tree[p].num = tree[p&lt;&lt;<span class="number">1</span>].num + tree[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].num;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!tree[p].num) &#123;</span><br><span class="line">		tree[p&lt;&lt;<span class="number">1</span>].num = tree[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].num = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change</span> <span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (tree[p].l &gt;= x &amp;&amp; tree[p].r &lt;= y) &#123;</span><br><span class="line">		tree[p].num = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> ; </span><br><span class="line">	&#125;</span><br><span class="line">	spread(p);</span><br><span class="line">	<span class="keyword">int</span> mid = (tree[p].l + tree[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (mid &gt;= x) change(p&lt;&lt;<span class="number">1</span>,x,y);</span><br><span class="line">	<span class="keyword">if</span> (mid &lt; y) change(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,y);</span><br><span class="line">	tree[p].num = tree[p&lt;&lt;<span class="number">1</span>].num + tree[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].num;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = read(),m = read();</span><br><span class="line">	build (<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = read(),y = read();</span><br><span class="line">		change(<span class="number">1</span>,x,y);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,tree[<span class="number">1</span>].num);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>解题报告</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>Luogu P2194 HXY烧情侣 解题报告</title>
    <url>/2019/10/11/Hxyburncp/</url>
    <content><![CDATA[<h2 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h2><p><a href="https://www.luogu.org/problem/P2194" target="_blank" rel="noopener">P2194 HXY烧情侣</a></p>
<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<p>众所周知，HXY已经加入了FFF团。现在她要开始喜（sang）闻（xin）乐（bing）见（kuang）地烧情侣了。这里有$n$座电影院，$n$对情侣分别在每座电影院里，然后电影院里都有汽油，但是要使用它需要一定的费用。$m$条单向通道连接相邻的两对情侣所在电影院。然后HXY有个绝技，如果她能从一个点开始烧，最后回到这个点，那么烧这条回路上的情侣的费用只需要该点的汽油费即可。并且每对情侣只需烧一遍，电影院可以重复去。然后她想花尽可能少的费用烧掉所有的情侣。问最少需要多少费用，并且当费用最少时的方案数是多少？由于方案数可能过大，所以请输出方案数对$1e9+7$取模的结果。</p>
<p>（注：这里HXY每次可以从任何一个点开始走回路。就是说一个回路走完了，下一个开始位置可以任选。所以说不存在烧不了所有情侣的情况，即使图不连通，HXY自行选择顶点进行烧情侣行动。且走过的道路可以重复走。）<br><a id="more"></a></p>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2></blockquote>
<p>题目中写的很清楚，这题直接套一个 Tarjan 就完了</p>
<p>现在讨论一下两个问题：</p>
<ol>
<li><p>最少需要多少费用</p>
<p>这个比较好想，只要将缩点后的每个 SCC 权值变成其中点权最小的即可</p>
</li>
<li><p>总共有多少方案</p>
<p>这个比较难想，但是我们可以结合一下乘法原理的思想，将每个 SCC 中的点权等于 SCC 的点权的个数相乘</p>
</li>
</ol>
<p>可能有点绕口，我们用形式化的语言来描述一下</p>
<p>记 $siz_i$  为 $SCC_i$ 中点权最小的权值， $num_i$ 为 $SCC_i$ 中点权等于最小点权的权值的点，$cnt$ 为 SCC 数量</p>
<p>则有</p>
<script type="math/tex; mode=display">ans_1 = \sum^{cnt}_{i=1}siz[i]</script><script type="math/tex; mode=display">ans_2 = \prod^{cnt}_{i=1}num_i</script><p>便可写出代码</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">stack</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> long long ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> register int ri</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>],*p1=buf,*p2=buf;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">gc</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,<span class="number">1</span>,<span class="number">1</span>&lt;&lt;<span class="number">21</span>,<span class="built_in">stdin</span>),p1==p2)?EOF:*p1++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> v = gc();<span class="keyword">int</span> x = <span class="number">0</span>,f = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(v)) &#123;<span class="keyword">if</span> (v == <span class="string">'-'</span>)f = <span class="number">-1</span>;v = gc();&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(v)) &#123;x = x * <span class="number">10</span> + v - <span class="number">48</span>;v = gc();&#125;</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">500001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> to[M],hd[N],nxt[M],tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;to[++tot] = v;nxt[tot] = hd[u];hd[u] = tot;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;add(u,v),add(v,u);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">min</span><span class="params">(T x,T y)</span> </span>&#123;<span class="keyword">return</span> x&lt;y?x:y;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">max</span><span class="params">(T x,T y)</span> </span>&#123;<span class="keyword">return</span> x&gt;y?x:y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],c[N],cnt,num,siz[N],p[N],pre[N],ins[N],n,m,ans1,ans2 = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	dfn[x] = low[x] = ++cnt;</span><br><span class="line">	s.push(x);ins[x] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = hd[x];i;i = nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!dfn[to[i]]) &#123;</span><br><span class="line">			tarjan(to[i]);</span><br><span class="line">			low[x] = min(low[x],low[to[i]]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ins[to[i]]) &#123;</span><br><span class="line">			low[x] = min(low[x],dfn[to[i]]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dfn[x] == low[x]) &#123;</span><br><span class="line">		<span class="keyword">int</span> y;c[x] = ++num;</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			y = s.top();c[y] = num;ins[y] = <span class="number">0</span>;s.pop();</span><br><span class="line">			<span class="keyword">if</span> (pre[y] &lt; p[num]) &#123;</span><br><span class="line">				p[num] = pre[y];</span><br><span class="line">				siz[num] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (pre[y] == p[num]) &#123;</span><br><span class="line">				++siz[num];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">while</span> (x != y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(p,INF,<span class="keyword">sizeof</span>(p));</span><br><span class="line">	n = read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) pre[i] = read();</span><br><span class="line">	m = read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = read(),y = read();add(x,y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!dfn[i]) tarjan(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= num;++i) &#123;</span><br><span class="line">		ans1 += p[i];ans2 *= siz[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d %d"</span>,ans1,ans2);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>解题报告</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title>Luogu P3469 [POI2008]BLO-Blockade 解题报告</title>
    <url>/2019/09/08/Luogu%20P3469%20%5BPOI2008%5DBLO-Blockade%20%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.luogu.org/problem/P3469" target="_blank" rel="noopener">[POI2008]BLO-Blockade</a></p>
<p>有 $n$ 个节点的无向图，定义封锁一个点为切断这个点的所有连边。求每个节点被封锁后图内的不连通有序点对个数。</p>
</blockquote>
<a id="more"></a>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>Tarjan。</p>
<p>首先分类讨论一下，封锁一个点有两种情况：</p>
<ol>
<li><p>不是割点</p>
<p>这种情况好搞，从图中显然可以看出只有自己和其他 $n - 1 $ 个节点不连通，因为是有序节点，所以答案为 $2 \times (n-1)$</p>
<p><img src="https://s2.ax1x.com/2019/09/08/n3Muo8.png" alt=""></p>
</li>
<li><p>是割点</p>
<p>这种情况就有意思了。</p>
<p>我们可以发现，如果点 i 为割点，显然去掉这个点之后整个图会变成几个联通块，如下图：</p>
<p><img src="https://s2.ax1x.com/2019/09/08/n3MWFO.png" alt=""></p>
<p>这种情况我们也很好发现，把联通块的大小两两相乘可得答案。</p>
<p>记第 i 个联通块为$s_i$</p>
<p>但是把联通块大小两两相乘的复杂度为 $O(n^2)$ 不能接受，我们可以在 dfs 时把搜索树子树大小算出来，记为 $siz[i]$</p>
<p>最后的答案即为： </p>
<p>$(n - 1 - \sum_{i=1}^{t}siz[s_k])*(1+\sum_{i=1}^{t}siz[s_k])$ </p>
</li>
</ol>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cctype&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N &#x3D; 100010;</span><br><span class="line">const int M &#x3D; 500010&lt;&lt;1;</span><br><span class="line">inline int read() &#123;</span><br><span class="line">	int x &#x3D; 0,f &#x3D; 1;char v &#x3D; getchar();</span><br><span class="line">	while (!isdigit(v)) &#123;if (v &#x3D;&#x3D;&#39;-&#39;) f &#x3D; -1;v &#x3D; getchar();&#125;</span><br><span class="line">	while (isdigit(v)) &#123;x &#x3D; x * 10 + v - 48;v &#x3D; getchar();&#125;</span><br><span class="line">	return x * f;</span><br><span class="line">&#125;</span><br><span class="line">int nxt[M],hd[N],to[M],tot &#x3D; 1,cnt,dfn[N],low[N],siz[N],n,m;</span><br><span class="line">long long ans[N];</span><br><span class="line">bool cut[N];</span><br><span class="line"></span><br><span class="line">inline void adde(int u,int v) &#123;</span><br><span class="line">	to[++tot] &#x3D; v;nxt[tot] &#x3D; hd[u];hd[u] &#x3D; tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline void addedge(int u,int v) &#123;</span><br><span class="line">	adde(u,v);adde(v,u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void tarjan(int x) &#123;</span><br><span class="line">	dfn[x] &#x3D; low[x] &#x3D; ++cnt;</span><br><span class="line">	siz[x] &#x3D; 1;</span><br><span class="line">	int flag &#x3D; 0,sum &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; hd[x];i;i &#x3D; nxt[i]) &#123;</span><br><span class="line">		int v &#x3D; to[i];</span><br><span class="line">		if (!dfn[v]) &#123;</span><br><span class="line">			tarjan(v);</span><br><span class="line">			low[x] &#x3D; min(low[x],low[v]);</span><br><span class="line">			siz[x] +&#x3D; siz[v];</span><br><span class="line">			if (low[v] &gt;&#x3D; dfn[x]) &#123;</span><br><span class="line">				flag++;</span><br><span class="line">				ans[x] +&#x3D; (long long)siz[v]*(n - siz[v]);</span><br><span class="line">				sum +&#x3D; siz[v];</span><br><span class="line">				if (x !&#x3D; 1 || flag &gt; 1) &#123;</span><br><span class="line">					cut[x] &#x3D; 1;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">		else &#123;</span><br><span class="line">			low[x] &#x3D; min(low[x],dfn[v]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (cut[x]) &#123;</span><br><span class="line">		ans[x] +&#x3D; (long long)(n - sum - 1) * (sum + 1) + (n - 1);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		ans[x] &#x3D; 2*(n-1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	n &#x3D; read(),m &#x3D; read();</span><br><span class="line">	for (int i &#x3D; 1;i &lt;&#x3D; m;++i) &#123;</span><br><span class="line">		int x &#x3D; read(),y &#x3D; read();</span><br><span class="line">		if (x &#x3D;&#x3D; y) &#123;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		addedge(x,y);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	tarjan(1);</span><br><span class="line">	for (int i &#x3D; 1;i &lt;&#x3D; n;++i) &#123;</span><br><span class="line">		printf(&quot;%lld\n&quot;,ans[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>部分思路来自于lyd的《算法竞赛进阶指南》</p>
]]></content>
      <categories>
        <category>解题报告</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>Tarjan</tag>
        <tag>割点</tag>
      </tags>
  </entry>
  <entry>
    <title>Luogu P2132 小Z的队伍排列 解题报告</title>
    <url>/2020/06/20/Luogu-P2132-%E5%B0%8FZ%E7%9A%84%E9%98%9F%E4%BC%8D%E6%8E%92%E5%88%97-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.luogu.com.cn/problem/P2132" target="_blank" rel="noopener">P2132 小Z的队伍排列</a></p>
<p>小Z想给班里的同学拍一张合影，为此需要先让大家排好队伍。他希望大家站成 $k$ 排，并规定了每排的人数，保证每一排的人数都不多于后面一排的人数。</p>
<p>这时小Z发现队伍看起来还是乱糟糟的，原因是大家的身高互不相同。于是，他希望排头对齐，每位同学都比自己正后方的同学以及排头方向的同学矮。</p>
<p>排完以后，善于思考的小Z还想知道一共有多少种排法。</p>
</blockquote>
<a id="more"></a>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>线性 DP。</p>
<p>首先因为“保证每一排的人数都不多于后面一排的人数”且“每位同学都比自己正后方的同学以及排头方向的同学矮”，所以合法方案中每行每列的身高显然单调。</p>
<p>所以我们可以从高到低考虑每个学生所站的位置，这样搞的话，我们只要用一个$(a_1,a_2,a_3…a_n)$ 就能体现出已经处理的东西的轮廓。</p>
<p>而每次考虑一个学生的时候，为了保证单调性，我们只能将他放在满足人员未满并且 $a_i &lt; a_{i-1}$ 或 $i = 1$ 的行中。</p>
<p>所以定义 $(a_1,a_2,a_3…a_n)$ 为阶段，这样就满足了动态规划问题的最优子结构性质，并且每安排一名新学生时候 $a_1,a_2,a_3…a_n$ 中总有一个会 $+1$，满足各个维度线性增长的原则，也就是线性 DP 了。</p>
<p>接下来，我们来设计状态转移方程，本题中的 $k \leq 5$，所以<del>无脑</del>设计 </p>
<p>$f_{a_1,a_2,a_3,a_4,a_5}$表示每排从最左边起分别站了 $a_1,a_2,a_3,a_4,a_5$ 个人的方案数量</p>
<p>$f_{0,0,0,0,0} = 1$ </p>
<p>目标：$f_{k_1,k_2,k_3,k_4,k_5}$</p>
<p>转移：</p>
<p>当 $i = 1$ 时，如果 $a_1 &lt; k_1$，也就是人还没被放满时，$f_{a_1+1,a_2,a_3,a_4,a_5}+=f_{a_1,a_2,a_3,a_4,a_5}$</p>
<p>当 $i &gt; 1$ 时，如果 $a_i &lt; k_i \&amp; a_i &lt; a_{i-1}$，$f_{a_1,a_2+1,a_3,a_4,a_5}+=f_{a_1,a_2,a_3,a_4,a_5}$</p>
<p>（此处为当$i = 2$时，其他同理。）</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ri register int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span> &lt;&lt; <span class="number">20</span>], *p1, *p2;</span><br><span class="line"><span class="comment">//#define getchar() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1 &lt;&lt; 20, stdin), p1 == p2)?EOF: *p1++)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;t)</span> </span>&#123;</span><br><span class="line">	ri v = getchar();T f = <span class="number">1</span>;t = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(v)) &#123;<span class="keyword">if</span> (v == <span class="string">'-'</span>)f = <span class="number">-1</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(v)) &#123;t = t * <span class="number">10</span> + v - <span class="number">48</span>;v = getchar();&#125;</span><br><span class="line">	t *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;t,Args&amp;... args)</span> </span>&#123;</span><br><span class="line">		read(t);read(args...);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line">ll f[N][N][N][N][N],n;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	read(n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) read(a[i]);</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> a1 = <span class="number">0</span>;a1 &lt;= a[<span class="number">1</span>];++a1) &#123;</span><br><span class="line">		 <span class="keyword">for</span> (<span class="keyword">int</span> a2 = <span class="number">0</span>;a2 &lt;= min(a1,a[<span class="number">2</span>]);++a2) &#123;</span><br><span class="line">		 	<span class="keyword">for</span> (<span class="keyword">int</span> a3 = <span class="number">0</span>;a3 &lt;= min(a2,a[<span class="number">3</span>]);++a3) &#123;</span><br><span class="line">		 		<span class="keyword">for</span> (<span class="keyword">int</span> a4 = <span class="number">0</span>;a4 &lt;= min(a3,a[<span class="number">4</span>]);++a4) &#123;</span><br><span class="line">		 			<span class="keyword">for</span> (<span class="keyword">int</span> a5 = <span class="number">0</span>;a5 &lt;= min(a4,a[<span class="number">5</span>]);++a5) &#123;</span><br><span class="line">		 				ll &amp;p = f[a1][a2][a3][a4][a5];<span class="comment">//指针储存，传统艺能</span></span><br><span class="line">		 				<span class="keyword">if</span> (a1 &amp;&amp; a1 &gt; a2) p += f[a1<span class="number">-1</span>][a2][a3][a4][a5];</span><br><span class="line">		 				<span class="keyword">if</span> (a2 &amp;&amp; a2 &gt; a3) p += f[a1][a2<span class="number">-1</span>][a3][a4][a5];</span><br><span class="line">		 				<span class="keyword">if</span> (a3 &amp;&amp; a3 &gt; a4) p += f[a1][a2][a3<span class="number">-1</span>][a4][a5];</span><br><span class="line">		 				<span class="keyword">if</span> (a4 &amp;&amp; a4 &gt; a5) p += f[a1][a2][a3][a4<span class="number">-1</span>][a5];</span><br><span class="line">		 				<span class="keyword">if</span> (a5) p += f[a1][a2][a3][a4][a5<span class="number">-1</span>];</span><br><span class="line">		 			&#125;</span><br><span class="line">		 		&#125;</span><br><span class="line">		 	&#125;</span><br><span class="line">		 &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[a[<span class="number">1</span>]][a[<span class="number">2</span>]][a[<span class="number">3</span>]][a[<span class="number">4</span>]][a[<span class="number">5</span>]]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>解题报告</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title>Luogu P4999 烦人的数学作业 解题报告</title>
    <url>/2019/09/07/Luogu%20P4999%20%E7%83%A6%E4%BA%BA%E7%9A%84%E6%95%B0%E5%AD%A6%E4%BD%9C%E4%B8%9A%20%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.luogu.org/problem/P4999" target="_blank" rel="noopener">P4999 烦人的数学作业</a></p>
<p>给出一个区间$L - R$，求$L$到$R$区间内<strong>每个数的数字和</strong>，如123这个数的数字和为1+2+3=6</p>
<p>有T组数据，结果$\mod 10^9+7$</p>
</blockquote>
<p>$（1 \leq L \leq R \leq 10^18）$<br><a id="more"></a></p>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p><del>确实烦人</del></p>
<p>第一眼看上去跟<a href="https://www.luogu.org/problem/P2602" target="_blank" rel="noopener">[ZJOI2010]数字计数</a>很像，确实是，把那个题的数位DP抄过来乘个 i 这题就没了。</p>
<p>那为啥要写这个题解呢？因为这个题坑多。</p>
<ol>
<li>注意开 long long</li>
<li>取模很坑，请使用传统技巧<code>(ans % mod + mod) % mod</code>，正确性证明应该不用多说</li>
</ol>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = N &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> v = getchar();<span class="keyword">int</span> x = <span class="number">0</span>,f = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(v)) &#123;<span class="keyword">if</span> (v == <span class="string">'-'</span>)f = <span class="number">-1</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(v)) &#123;x = x * <span class="number">10</span> + v - <span class="number">48</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[N],dp[N][N],l,r;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">bool</span> limit,<span class="keyword">bool</span> zer,<span class="keyword">int</span> dig,<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (pos == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">if</span> (!limit &amp;&amp; dp[pos][sum]) <span class="keyword">return</span> dp[pos][sum];</span><br><span class="line">	<span class="keyword">int</span> up = <span class="number">9</span>;</span><br><span class="line">	<span class="keyword">if</span> (limit) up = num[pos];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= up;++j) &#123;</span><br><span class="line">		ans += dfs(pos<span class="number">-1</span>,(j==up)&amp;&amp;limit,zer||j,dig,sum+((j||zer)&amp;&amp;(j==dig)));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!limit&amp;&amp;zer)&#123;</span><br><span class="line">		dp[pos][sum] = ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (p) &#123;</span><br><span class="line">		num[++len] = p % <span class="number">10</span>;</span><br><span class="line">		p /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dfs(len,<span class="number">1</span>,<span class="number">0</span>,w,<span class="number">0</span>) % mod;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T = read();</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		l = read(),r = read();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">9</span>;++i) &#123;</span><br><span class="line">			ans += ((work(r,i) - work(l<span class="number">-1</span>,i) % mod) * i) % mod;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,(ans%mod+mod)%mod);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>解题报告</category>
      </categories>
      <tags>
        <tag>数位DP</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>Luogu 1417 烹调方案 解题报告</title>
    <url>/2019/09/22/Luogu1417/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.luogu.org/problem/P1417" target="_blank" rel="noopener">烹调方案</a></p>
<p>一共有$n$件食材，每件食材有三个属性， $a_i$ ， $b_i$ 和 $c_i$ ，如果在 $t$ 时刻完成第 $i$ 样食材则得到 $a_i-t*b_i$ 的美味指数，用第 $i$ 件食材做饭要花去 $c_i$ 的时间。</p>
<p>在 $T$ 时间内设计烹调方案使得美味指数最大</p>
</blockquote>
<a id="more"></a>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>显然是一个01背包，但是，当你写完01背包板子交上去以后会发现只有30分。  </p>
<p>题目中给了一个条件：在 $t$ 时刻完成第 $i$ 样食材则得到 $a_i-t*b_i$ 的美味指数，有了这个条件，显然我们要对每个物品选择的先后性进行讨论了。</p>
<p>设 $a_1,b_1,c_1$ 为第一组物品，$a_2,b_2,c_2$ 为第二组物品， $t$为当前时间.</p>
<p>将两个物品可获得的值表示出来为：</p>
<script type="math/tex; mode=display">
m_1 = a_1-(t \times c_1) \times b_1 + a_2 - (t+c_1+c_2) \times b_2</script><script type="math/tex; mode=display">
m_2 = a_2-(t \times c_2) \times b_2 + a_1 - (t+c_1+c_2) \times b_1</script><p>设 $m_1 &gt; m_2$ 得</p>
<script type="math/tex; mode=display">
a_1-(t \times c_1) \times b_1 + a_2 - (t+c_1+c_2) \times b_2   > m_2 = a_2-(t \times c_2) \times b_2 + a_1 - (t+c_1+c_2) \times b_1</script><p>拆项得</p>
<script type="math/tex; mode=display">
a_1-b_1t-b_1c_1+a_2-b_2t-b_2c_1-b_2c_2>a_2-b_2t-b_2c_2+a_1-b_1t-b_1c_1-b_1c_2</script><p>化简得  </p>
<script type="math/tex; mode=display">
b_1c_2 > b_2c_1</script><p>由此，我们就得到了我们 sort 函数中cmp的写法。注意开 long long 这题就完了。</p>
<p>这题的关键就在此，我不知道是为什么，大部分题解中都没有给出自己的完整证明，这个证明也不难证，希望读者看完后可以自己证明一遍。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">500010</span>&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">0</span>,f = <span class="number">1</span>;<span class="keyword">char</span> v = getchar();</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(v)) &#123;<span class="keyword">if</span> (v ==<span class="string">'-'</span>) f = <span class="number">-1</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(v)) &#123;x = x * <span class="number">10</span> + v - <span class="number">48</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> f[N],n,m,ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> a,b,c;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;rhs,<span class="keyword">const</span> node &amp;rs) &#123;</span><br><span class="line">		<span class="keyword">return</span> rhs.b*rs.c &gt; rhs.c*rs.b;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;pre[N];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	m = read(),n = read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i)	pre[i].a = read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i)	pre[i].b = read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i)	pre[i].c = read();</span><br><span class="line">	sort(pre+<span class="number">1</span>,pre+<span class="number">1</span>+n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = m;j &gt;= pre[i].c;--j) &#123;</span><br><span class="line">			f[j] = max(f[j],f[j-pre[i].c] + (pre[i].a - j * pre[i].b));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;++i) &#123;</span><br><span class="line">		ans = max(ans,f[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>解题报告</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 2020 提高组夏令营 模拟赛 1 赛后补题</title>
    <url>/2020/07/31/Luogu2020SC1/</url>
    <content><![CDATA[<p>值得复习<br><a id="more"></a></p>
<h2 id="A-连接前后缀"><a href="#A-连接前后缀" class="headerlink" title="A.连接前后缀"></a>A.连接前后缀</h2><p>40 Pts: 暴力枚举，把每个枚举出来的前后缀加起来丢进一个 <code>map</code> </p>
<p>时间复杂度 $O(nm \log nm)$</p>
<p>80 Pts: 把 40 Pts 的做法改成使用字符串 hash</p>
<p>时间复杂度 $O(nm)$</p>
<p>100 Pts: 观察到这个问题其实和如下问题等价：求出字符串 $p + q$ 有多少种重复的情况，用 $nm$ 减去这个答案的值就是了。</p>
<p>所以我们来关注如何快速求出重复段。</p>
<p>样例 1 里，如果第一个字符串里我们选择了 <code>ab</code> 第二个选择了 <code>a</code> ，那么观察到如果第一个字符串选择了 <code>a</code> 第二个选择了 <code>ba</code> 。那么就是一个重复段。</p>
<p>于是我们可以发现，如果第一个与第二个有重复的字符，显然会造成重复段的出现。那么重复段的数量是多少呢？还是从这个样例入手：</p>
<ol>
<li><code>aba</code> 会有 1 个重复：<code>ab-a</code> ,<code>a-ba</code></li>
<li><code>abba</code> 会有 2 个重复：<code>a-bba</code>,<code>ab-ba</code>,<code>a-bba</code></li>
<li><code>abbba</code> 会有 1 个重复：<code>ab-bba</code>,<code>abb-ba</code></li>
</ol>
<p>这样重复数也就是 4.</p>
<p>当你把样例都推一遍时，你能得出一个式子：</p>
<p>重复段个数 = $\sum_{i = a}^z cnt_A * cnt_B$</p>
<p>其含义是重复段个数为 A 和 B 中重复字母的乘积的和。</p>
<p>最后注意，因为是前缀/后缀，所以第一个/最后一个是必选的，不用统计进去。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">char</span> s[N],p[N];</span><br><span class="line"><span class="keyword">int</span> n,m,cnt1[N],cnt2[N];</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,s,p);</span><br><span class="line">    n = <span class="built_in">strlen</span>(s),m = <span class="built_in">strlen</span>(p);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;++i) cnt1[s[i] - <span class="string">'a'</span> + <span class="number">1</span>]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m - <span class="number">1</span>;++i) cnt2[p[i] - <span class="string">'a'</span> + <span class="number">1</span>]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">26</span>;++i) &#123;</span><br><span class="line">        ans += <span class="number">1L</span>L * cnt1[i] * cnt2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,<span class="number">1L</span>L * n*m-ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="B-合并排列"><a href="#B-合并排列" class="headerlink" title="B.合并排列"></a>B.合并排列</h2><p>一个很玄学的题。</p>
<p>首先分析一下题目，它要求的是两个 <strong>排列</strong> 。</p>
<p>说明其必须是从 $1\dots n$ 的一个数列。</p>
<p>所以，如果一个数字在这个数列中没有出现两次，那么这个就无法被拼出来。</p>
<p>排除掉第一种情况，我们就可以把问题转化一下：把一个数列给黑白染色，让黑白部分均为一个 $1\dots n$的排列。也就是说，这个数列有解当且仅当其可以被划分成若干段且满足相关条件。</p>
<p>再看下题目的条件：相当于每次从两个排列中取出较小的那个，那么如果 $a_i &gt; a_{i+1}$ ，显然这两个并不是来自一个排列的。（如果是来自一个排列的显然 $a_{i+1}$ 就先出来了）</p>
<p>所以每一段都是当前的前缀最大值以及后面的一串以及到接下来的下一个前缀最大值。</p>
<p>可能有点抽象，举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 2 4 1 2 3 4 1</span><br><span class="line">I   I       I</span><br></pre></td></tr></table></figure>
<p>它的前缀最大值在如上标号的三个地方出现,所以这个就可以被划分成三段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[3 2] [4 1 2 3] [4 1]</span><br></pre></td></tr></table></figure>
<p>那么怎么判断这个分段是否合法呢？首先，一个充要条件就是：一个段内没有相同元素。因为每一段是在一个排列里的，如果排列里出现两个相同的数就出问题了。</p>
<p>如果你认为只有这样，那就太简单了，有个反例可以秒掉：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[2 1] [3 1] [3 2]</span><br></pre></td></tr></table></figure>
<p>显然这个是无法分割的。</p>
<p>所以我们把分段当中元素有相同的元素的段连一条边，那么这里要构成一张二分图才能保证有合法方案。上面的例子就是构成了一个三元环，所以无法划分。</p>
<p>于是这题就做完了，当然详细看代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">basic_check</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = ((<span class="keyword">int</span>)t.size() - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(n + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++) cnt[t[i]] += <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt[i] != <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">int</span> T;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t(<span class="number">2</span> * n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++) <span class="built_in">cin</span> &gt;&gt; t[i];</span><br><span class="line">    <span class="keyword">if</span> (!basic_check(t)) &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO\n"</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pre_max = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; max_pos;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">      pre_max = max(pre_max, t[i]);</span><br><span class="line">      <span class="keyword">if</span> (t[i] == pre_max) &#123;</span><br><span class="line">        max_pos.push_back(i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    max_pos.push_back(<span class="number">2</span> * n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; seg(<span class="number">2</span> * n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)max_pos.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = max_pos[i]; j &lt; max_pos[i + <span class="number">1</span>]; j++) &#123;</span><br><span class="line">        seg[j] = i + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pos(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">      pos[t[i]].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> good = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (seg[pos[i][<span class="number">0</span>]] == seg[pos[i][<span class="number">1</span>]]) good = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (good) &#123;</span><br><span class="line">      <span class="keyword">int</span> k = (<span class="keyword">int</span>)max_pos.size() - <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; G(k + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = seg[pos[i][<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">int</span> b = seg[pos[i][<span class="number">1</span>]];</span><br><span class="line">        G[a].push_back(b);</span><br><span class="line">        G[b].push_back(a);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        sort(G[i].begin(), G[i].end());</span><br><span class="line">        G[i].erase(unique(G[i].begin(), G[i].end()), G[i].end());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; col(k + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">auto</span> bfs = [&amp;](<span class="keyword">int</span> x) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        Q.push(x);</span><br><span class="line">        col[x] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">          <span class="keyword">int</span> cur = Q.front(); Q.pop();</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">auto</span> nx: G[cur]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (col[nx] == col[cur]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (col[nx] == <span class="number">0</span>) &#123;</span><br><span class="line">              col[nx] = -col[cur];</span><br><span class="line">              Q.push(nx);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!col[i] &amp;&amp; !bfs(i)) good = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (good ? <span class="string">"YES\n"</span> : <span class="string">"NO\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="C-安放皇冠"><a href="#C-安放皇冠" class="headerlink" title="C.安放皇冠"></a>C.安放皇冠</h2><p>先咕咕着</p>
]]></content>
      <tags>
        <tag>树上问题</tag>
        <tag>图论</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>Luogu P1032 字串变换 解题报告</title>
    <url>/2020/02/11/LuoguP1032/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.luogu.com.cn/problem/P1032" target="_blank" rel="noopener">【NOIP2002】字串变换</a></p>
<p>给你两个字符串 $A,B$ ，并给你 $n$ 个规则$(n\leq 6)$ ，求从 $A$ 到 $B$ 最小的变换步数（若$10$步内无法变换则无解，字符串长度不能超过$20$）。</p>
</blockquote>
<a id="more"></a>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>从”$10$步内无法变换则无解” 则可以马上反应到：这是个搜索题（要素察觉）</p>
<p>既然是个搜索题，我们就要确定几点：搜索方式，搜索状态，搜索转移，搜索边界。</p>
<p>方式：这题是求最快的步数，所以我们采用 bfs 显然会比 dfs 快很多，而且有起点和终点状态我们就可以用双向搜索（具体不多说了），这里我们讲单向 bfs 的方法。</p>
<p>状态：首先，题目是对一个字符串进行操作，所以字符串显然是其中的一个状态</p>
<p>其次，题目中提到了对步数的限制，所以步数也是其中的一个状态。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> sum;<span class="comment">//步数</span></span><br><span class="line">    <span class="built_in">string</span> s;<span class="comment">//当前字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转移：其实题目中给的已经很明显了：就是按照这几种规则去转移当前字符串即可。</p>
<p>边界：题目中也有明显的指出，每次取出队头节点时要判断一下步数是否$ &gt; 10$。</p>
<p>以上便是此题的基本思路，但是这题的代码及其繁琐，所以我们着重讲一讲代码的实现。</p>
<ol>
<li><p>储存规则：规则是两个字符串，我们可以用一个<code>pair&lt;string,string&gt;</code>来储存。</p>
</li>
<li><p>转移：我们用的是<code>string</code>，在这里，我们可以使用<code>stirng::find</code> 和 <code>string::replace</code>来实现字串的替换。</p>
</li>
<li><p>特判：每次取出节点的时候判断一下步数，每次变换完判断一下长度是否超限。</p>
</li>
</ol>
<p>由此，我们可以写出一份基本的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; &gt; ma;<span class="comment">//储存变换规则</span></span><br><span class="line"><span class="built_in">queue</span> &lt;node&gt; s;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	node s = (node)&#123;a,<span class="number">0</span>&#125;;</span><br><span class="line">	q.push(s);<span class="comment">//初始状态插入</span></span><br><span class="line">	<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">		node p = q.front();q.pop();</span><br><span class="line">		<span class="built_in">string</span> now = p.s;	</span><br><span class="line">		<span class="keyword">int</span> num = p.sum;<span class="comment">//取出当前状态</span></span><br><span class="line">		<span class="keyword">if</span> (num &gt; <span class="number">10</span>) <span class="keyword">continue</span>;<span class="comment">//判断当前步数是否&gt;10</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; tot;++i) &#123;<span class="comment">//循环判断</span></span><br><span class="line">			<span class="built_in">string</span> a1 = ma[i].first,b1 = ma[i].second;</span><br><span class="line">			<span class="keyword">if</span> (now.find(a1) != <span class="built_in">std</span>::<span class="built_in">string</span>::npos) &#123;<span class="comment">//如果能找到</span></span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">size_t</span> j = now.find(a1);j != <span class="built_in">std</span>::<span class="built_in">string</span>::npos;j = now.find(a1,j+<span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="comment">//上行代码有几个点要讲解的：1.使用size_t是因为string::npos是size_t的，如果不懂什么意思可以把它当作unsigned long long(有大佬说系统位数是32位这个值会变成unsigned int)来看待 2.前面一个find是找到最开始串里有没有这个最初的串，后面是在这个变换完的串之后看是否还有可以变换的</span></span><br><span class="line">					<span class="built_in">string</span> t = now;</span><br><span class="line">					t.replace(j,a1.length(),b1);<span class="comment">//将可以变换的变换为 b1</span></span><br><span class="line">					<span class="keyword">if</span> (t == b) &#123;<span class="built_in">cout</span> &lt;&lt; num+<span class="number">1</span>;<span class="keyword">return</span> ;&#125;<span class="comment">//如果找到了，可以直接退出</span></span><br><span class="line">					<span class="keyword">if</span> (t.length() &lt;= <span class="number">20</span>) &#123;<span class="comment">//判断字符串长度</span></span><br><span class="line">                        node pp = (node)&#123;t,num+<span class="number">1</span>&#125;;</span><br><span class="line">                        q.push(pp);</span><br><span class="line">                        se.insert(t);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"NO ANSWER!"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这份代码没什么问题，但是我们可以分析一下这个题目性质：</p>
<p>显然，一个串可以被几个不同的规则搜到，但是由于我们是 bfs 所以可以证明最开始搜到的那个情况是最优的，之后搜到的情况都可以直接舍弃。</p>
<p>所以，我们可以把用过的情况存在一个 <code>map</code> 里，如果这个情况搜过了就跳过。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (t.length() &lt;= <span class="number">20</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (se.find(t)==se.end())&#123;</span><br><span class="line">        node pp = (node)&#123;t,num+<span class="number">1</span>&#125;;</span><br><span class="line">        q.push(pp);</span><br><span class="line">        se.insert(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，你的代码就没什么问题了。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ri register int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">500001</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="built_in">string</span> s;<span class="keyword">int</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; &gt; ma;</span><br><span class="line"><span class="built_in">string</span> a,b,a1,b1;</span><br><span class="line"><span class="keyword">int</span> ans,cnt,tot;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> &lt;<span class="built_in">string</span>&gt; se;</span><br><span class="line"><span class="built_in">queue</span> &lt;node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	node s = (node)&#123;a,<span class="number">0</span>&#125;;</span><br><span class="line">	q.push(s);</span><br><span class="line">	<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">		node p = q.front();q.pop();</span><br><span class="line">		<span class="built_in">string</span> now = p.s;	</span><br><span class="line">		<span class="keyword">int</span> num = p.sum;</span><br><span class="line">		<span class="keyword">if</span> (num &gt; <span class="number">10</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; tot;++i) &#123;</span><br><span class="line">			<span class="built_in">string</span> a1 = ma[i].first,b1 = ma[i].second;</span><br><span class="line">			<span class="keyword">if</span> (now.find(a1) != <span class="built_in">std</span>::<span class="built_in">string</span>::npos) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">size_t</span> j = now.find(a1);j != <span class="built_in">std</span>::<span class="built_in">string</span>::npos;j = now.find(a1,j+<span class="number">1</span>)) &#123;</span><br><span class="line">					<span class="built_in">string</span> t = now;</span><br><span class="line">					t.replace(j,a1.length(),b1);</span><br><span class="line">					<span class="keyword">if</span> (t == b) &#123;<span class="built_in">cout</span>&lt;&lt;num+<span class="number">1</span>;<span class="keyword">return</span> ;&#125;</span><br><span class="line">					<span class="keyword">if</span> (t.length() &lt;= <span class="number">20</span>) &#123;</span><br><span class="line">						<span class="keyword">if</span> (se.find(t)==se.end())&#123;</span><br><span class="line">							node pp = (node)&#123;t,num+<span class="number">1</span>&#125;;</span><br><span class="line">							q.push(pp);</span><br><span class="line">							se.insert(t);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"NO ANSWER!"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; a1 &gt;&gt; b1) &#123;</span><br><span class="line">		ma.push_back(make_pair(a1,b1));</span><br><span class="line">		++tot;</span><br><span class="line">	&#125;</span><br><span class="line">	bfs();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>解题报告</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>搜索</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Luogu P2169 正则表达式 解题报告</title>
    <url>/2019/10/11/LuoguP2169/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.luogu.org/problem/P2169" target="_blank" rel="noopener">P2169 正则表达式</a><br>在Internet网络中的每台电脑并不是直接一对一连通的，而是某些电脑之间存在单向的网络连接，也就是说存在A到B的连接不一定存在B到A的连接，并且有些连接传输速度很快，有些则很慢，所以不同连接传输所花的时间是有大有小的。另外，如果存在A到B的连接的同时也存在B到A的连接的话，那么A和B实际上处于同一局域网内，可以通过本地传输，这样花费的传输时间为0。</p>
<p>现在小Z告诉你整个网络的构成情况，他希望知道从他的电脑（编号为1），到小X的电脑（编号为n）所需要的最短传输时间。</p>
<p>对于100%的数据，$1\leq n\leq200000, 1\leq m\leq 1000000$</p>
</blockquote>
<a id="more"></a>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>Tarjan 缩点 + SPFA/DP </p>
<p>首先观察数据范围，显然这么大的 $n,m$ ，直接跑 $O(nm)$ 的 SPFA 会炸掉。</p>
<p>观察题面，发现如果有 x 和 y 构成一个环（处在同一个 SCC 中），那么他们之间的边长度为 0 </p>
<p>这启发我们可以用缩点后再来跑 SPFA ，但是这样的复杂度是不够严谨的，最坏情况下仍旧是 $O(nm)$ 的，只是由于这题水所以可以过。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>SPFA 版本 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> v = getchar();<span class="keyword">int</span> x = <span class="number">0</span>,f = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(v)) &#123;<span class="keyword">if</span> (v == <span class="string">'-'</span>)f = <span class="number">-1</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(v)) &#123;x = x * <span class="number">10</span> + v - <span class="number">48</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">5000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> to[M],hd[N],nxt[M],tot,edg[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span>&#123;to[++tot] = v;edg[tot] = w;nxt[tot] = hd[u];hd[u] = tot;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> x&lt;y?x:y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> x&gt;y?x:y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">stack</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],ins[N],cnt,num,c[N],n,m,p[N],f[N];</span><br><span class="line"><span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	dfn[x] = low[x] = ++cnt;</span><br><span class="line">	s.push(x);ins[x] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = hd[x];i;i = nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!dfn[to[i]]) &#123;</span><br><span class="line">			tarjan(to[i]);</span><br><span class="line">			low[x] = min(low[x],low[to[i]]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ins[to[i]]) &#123;</span><br><span class="line">			low[x] = min(low[x],dfn[to[i]]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dfn[x] == low[x]) &#123;</span><br><span class="line">		c[x] = ++num;<span class="keyword">int</span> y;</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			y = s.top(),s.pop();</span><br><span class="line">			ins[y] = <span class="number">0</span>;c[y] = num;</span><br><span class="line">		&#125;<span class="keyword">while</span> (x != y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> vis[N],dis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">	<span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	vis[s] = <span class="number">1</span>;dis[s] = <span class="number">0</span>;</span><br><span class="line">	q.push(s);</span><br><span class="line">	<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = q.front();q.pop();</span><br><span class="line">		vis[x] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = hd[x];i;i = nxt[i]) &#123;</span><br><span class="line">			<span class="keyword">int</span> y = to[i],w = edg[i];</span><br><span class="line">			<span class="keyword">if</span> (c[x] == c[y]) w = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (dis[y] &gt; dis[x] + w) &#123;</span><br><span class="line">				dis[y] = dis[x] + w;</span><br><span class="line">				<span class="keyword">if</span> (!vis[y]) &#123;</span><br><span class="line">					q.push(y);</span><br><span class="line">					vis[y] = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = read(),m = read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = read(),y = read(),w = read();add(x,y,w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) <span class="keyword">if</span> (!dfn[i]) tarjan(i);</span><br><span class="line">	SPFA(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,dis[n]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>解题报告</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>Tarjan</tag>
        <tag>缩点</tag>
      </tags>
  </entry>
  <entry>
    <title>Luogu P1156 垃圾陷阱 解题报告</title>
    <url>/2020/07/02/LuoguP1156/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.luogu.com.cn/problem/P1156" target="_blank" rel="noopener">P1156 垃圾陷阱</a></p>
<p>“垃圾井”是农夫们扔垃圾的地方，它的深度为$D(2 \le D \le 100)$英尺。</p>
<p>卡门想把垃圾堆起来，等到堆得与井同样高时，她就能逃出井外了。另外，卡门可以通过吃一些垃圾来维持自己的生命。</p>
<p>每个垃圾都可以用来吃或堆放，并且堆放垃圾不用花费卡门的时间。</p>
<p>假设卡门预先知道了每个垃圾扔下的时间$t (0 &lt; t \le 1000)$，以及每个垃圾堆放的高度$h(1 \le h \le 25$)和吃进该垃圾能维持生命的时间$f(1 \le f \le 30)$，要求出卡门最早能逃出井外的时间，假设卡门当前体内有足够持续$10$小时的能量，如果卡门$10$小时内没有进食，卡门就将饿死。</p>
</blockquote>
<a id="more"></a>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>线性 DP + 背包变形</p>
<p>回顾一下 01 背包的基本思路：</p>
<p>对于每个物品，有两种决策方式</p>
<ol>
<li>选择该物品 $f_{i,j} = \max(f_{i,j},f_{i,j-v_i}+w_i)$</li>
<li>不选择该物品 $f_{i,j} = \max(f_{i,j},f_{i-1,j})$</li>
</ol>
<p>对应本题，每个物品同样有两种决策方式</p>
<ol>
<li>吃下该物品，则血量增加 $w_i$</li>
<li>堆放该物品，血量减 1，高度增加 $h_i$</li>
</ol>
<p>所以我们可以设计 $f_{i,j}$ 表示当前对第 $i$ 个物品进行决策，已经填满 $j$ 的高度。</p>
<p>物品还带有时间维，所以我们可以预先对所有物品进行排序，保证物品这维增长是线性的。</p>
<p>转移比较难思考，第一种转移是从 $f_{i-1,j}$ 来的，而第二种转移是要到 $f_{i,j+h_i}$ 去，所以写的方式还有些不同。</p>
<p>转移方程：</p>
<script type="math/tex; mode=display">len = time_i - time_i-1</script><p>表示从上一个物品到当前物品的时间</p>
<script type="math/tex; mode=display">f_{i,j} = \max(f_{i,j}.f_{i-1,j} -len + w_i)</script><p>表示吃下该物品的转移，注意中间的时间也要扣掉</p>
<script type="math/tex; mode=display">f_{i,j+h_i} = \max(f_{i,j+h_i,f_{i-1,j} - len})</script><p>表示堆放该物品的转移。</p>
<p>初值： $f_{0,0} = 10$</p>
<p>在这里，我们并不需要倒序循环 $j$ （因为第一维循环保证用$i-1$阶段更新$i$），但是如果需要用滚动数组优化的话，为了避免重复更新需要倒序循环。</p>
<p>并且在转移过程中，如果当前血量足够<strong>下一次</strong>跳就可以跳出陷阱，就可以直接终止循环，记录答案了。因为从小到大枚举 $i$ 所以可以保证答案最优。</p>
<p>最后，如果实在填不满的话，从头开始模拟一遍即可。</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ri register int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span> &lt;&lt; <span class="number">20</span>], *p1, *p2;</span><br><span class="line"><span class="comment">//#define getchar() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1 &lt;&lt; 20, stdin), p1 == p2)?EOF: *p1++)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;t)</span> </span>&#123;</span><br><span class="line">	ri v = getchar();T f = <span class="number">1</span>;t = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(v)) &#123;<span class="keyword">if</span> (v == <span class="string">'-'</span>)f = <span class="number">-1</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(v)) &#123;t = t * <span class="number">10</span> + v - <span class="number">48</span>;v = getchar();&#125;</span><br><span class="line">	t *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;t,Args&amp;... args)</span> </span>&#123;</span><br><span class="line">	read(t);read(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">min</span><span class="params">(T x,T y)</span> </span>&#123;<span class="keyword">return</span> x&lt;y?x:y;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">max</span><span class="params">(T x,T y)</span> </span>&#123;<span class="keyword">return</span> x&gt;y?x:y;&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">0x3f3f3f3f3f3f3f3f</span>LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2010</span>;</span><br><span class="line"><span class="keyword">int</span> f[N][N],n,m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> t,f,h;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;a,<span class="keyword">const</span> node &amp;b) &#123;</span><br><span class="line">		<span class="keyword">return</span> a.t &lt; b.t;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	read(m,n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) &#123;</span><br><span class="line">		read(a[i].t,a[i].f,a[i].h);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0xcf</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (flag) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= m;++j) &#123;	</span><br><span class="line">			<span class="keyword">if</span> (f[i<span class="number">-1</span>][j] - (a[i].t - a[i<span class="number">-1</span>].t) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (j + a[i].h &gt;= m) &#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">"%d"</span>,a[i].t);</span><br><span class="line">					flag = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				f[i][j] = max(f[i][j],f[i<span class="number">-1</span>][j] - (a[i].t - a[i<span class="number">-1</span>].t) + a[i].f);</span><br><span class="line">				f[i][j+a[i].h] = max(f[i][j+a[i].h],f[i<span class="number">-1</span>][j] - (a[i].t - a[i<span class="number">-1</span>].t));</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>,now = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (now &lt; (a[i].t - a[i<span class="number">-1</span>].t)) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%d"</span>,now+ans);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			ans += (a[i].t - a[i<span class="number">-1</span>].t);</span><br><span class="line">			now = now - (a[i].t - a[i<span class="number">-1</span>].t) + a[i].f;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d"</span>,now +ans);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>解题报告</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>线性DP</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title>Luogu P2303 [SDOI2012] Longge 的问题 解题报告</title>
    <url>/2020/08/05/LuoguP2303/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.luogu.com.cn/problem/P2303" target="_blank" rel="noopener">P2303 [SDOI2012] Longge 的问题</a></p>
<p>求 $\sum\limits_{i=1}^n \gcd(i, n)$ </p>
<p>$n \leq 2 ^ {32}$</p>
</blockquote>
<a id="more"></a>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>数学题。（第一次推出式子来真的好开心hhhh）</p>
<p>首先看到 gcd ，第一反应应该是从 $n$ 的因数开始思考。</p>
<p>那么我们把 $n$ 质因数分解，设 $d | n$</p>
<p>我们要求的东西其实就是 $\sum\limits_{d = 1}^n (d * \sum\limits_{i = 1}^n[\gcd (i,n) = j])$</p>
<p>化简一波式子：</p>
<script type="math/tex; mode=display">
\begin{aligned}
    &\sum\limits_{d = 1}^n(d * \sum\limits_{i = 1}^n[\gcd (i,n) = j])\\
    & = \sum\limits_{d = 1}^n(d * \sum\limits_{i = 1}^n[\gcd (i/j,n/j)])\\
    & = \sum\limits_{d = 1}^n(d * \varphi(n/j))\\
    & = \sum\limits_{d|n}(d * \varphi(n/j))
\end{aligned}</script><p>然后直接算就行了。<br>时间复杂度$O(d(n) * \sqrt{n})$</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll n,ans;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">phi</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    ll ans = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i *i &lt;= x;++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) &#123;x /= i;&#125;</span><br><span class="line">            ans = (ans * (i<span class="number">-1</span>) / i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) ans = (ans * (x<span class="number">-1</span>) / x);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i * i &lt;= n;++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            ans += i*phi(n/i);</span><br><span class="line">            <span class="keyword">if</span> (i * i != n) ans += n/i * phi(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>解题报告</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title>Luogu P2458 [SDOI2006]保安站岗 解题报告</title>
    <url>/2020/07/06/LuoguP2458/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.luogu.com.cn/problem/P2458" target="_blank" rel="noopener">P2458 [SDOI2006]保安站岗</a></p>
<p>有一棵无根树有 $n$ 个点，每个点都可以被其相邻的点望到。</p>
<p>每个点带有一个权值，求保证所有点都可以被望到的情况下花费总代价最少。</p>
</blockquote>
<a id="more"></a>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>树形 DP。</p>
<p>最开始我的想法和<a href="https://www.luogu.com.cn/problem/P2016" target="_blank" rel="noopener">树上最小点覆盖</a>的想法一样，每个点有选与不选两种状态，暴力转移。</p>
<p>成功拿到 10 分。</p>
<p>回到正题，这题和树上最小点覆盖的本质区别在于：</p>
<ul>
<li>树上最小点覆盖每个点只能被父亲看见</li>
<li>本题中的每个点可以被父亲或者儿子看见</li>
</ul>
<p>所以直接导致我们的状态不再适用。</p>
<p>那么怎么办呢？可以暴力直接把这种情况加进去！</p>
<p>同样，我们设 $f_{i,0/1/2}$ 表示第 $i$ 个点的情况：</p>
<ul>
<li>如果是 0 ，表示当前点被选中</li>
<li>如果是 1 ，表示当前点是被父亲看到的，且当前点未被选中</li>
<li>如果是 2 ，表示当前点是被儿子看到的，且当前点未被选中</li>
</ul>
<p>前两种情况的转移方程很好写，考虑可行性即可。</p>
<script type="math/tex; mode=display">f_{x,0} = \min_{y \in son(x)}(f_{y,0,}f_{y,1},f_{y,2})</script><p>因为该点被选中，所以子节点怎么转移都行</p>
<script type="math/tex; mode=display">f_{x,1} = \min_{y \in son(x)}(f_{y,0},f_{y,2})</script><p>因为该点没被选中，所以子节点中 $f_{y,1}$ 就不能被转移。</p>
<p>最后一种情况<strong>似乎</strong>大同小异：</p>
<script type="math/tex; mode=display">f_{x,2} = \min_{y \in son(x)}(f_{y,0},f_{y,2})</script><p>但是，让我们考虑这样的一种情况：<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/2dlo1zih.png" alt=""></p>
<p>在这张图中，$f_{1,2} = f_{2,2}+f_{3,2}+f_{4,2}$ ，显然不符合状态的定义， $1$ 并没有被观察到，所以我们还要暴力选择一个$f_{y,0}-f_{y,2}$差值最小的点（上图中为 $2$）才能保证正确性。</p>
<p>所以我们就可以写出最后一种情况的方程了：</p>
<p>如果有选择 $f_{y,0}$，则</p>
<script type="math/tex; mode=display">f_{x,2} = \min_{y \in son(x)}(f_{y,0},f_{y,2})</script><p>如果没有，则</p>
<script type="math/tex; mode=display">f_{x,2} = \min_{y \in son(x)}(f_{y,0},f_{y,2}) + \min_{y \in son(x)}(f_{y,0} - f_{y,2}))</script><p>这两个只要在代码实现时候记录下即可。</p>
<p>初值：$f_{x,0} = a_x,f_{x,1} = f_{x,2} = 0$</p>
<p>目标：$\min(f_{root,0},f_{root,2})$（根节点没有父亲，所以没有 $f_{root,1}$ 的情况）</p>
<p>最后，由于并没有指定根，所以读入时还要记一下入度为 0 的点当作根开始 DP。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>省略头文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n,a[N],f[N][<span class="number">3</span>],deg[N];</span><br><span class="line"><span class="comment">//f_&#123;i,0&#125; 表示当前点放一个 f_&#123;i,1&#125;表示父亲放 f_&#123;i,2&#125; 表示儿子放</span></span><br><span class="line"><span class="comment">//当前点放的话随便转移</span></span><br><span class="line"><span class="comment">//父亲点放的话可以转移到f_&#123;y,0&#125;或f_&#123;y,2&#125;</span></span><br><span class="line"><span class="comment">//儿子放的话要找到一个最小儿子 让放置儿子代价最小</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">	f[x][<span class="number">0</span>] = <span class="number">1</span>;	</span><br><span class="line">	<span class="keyword">int</span> del = INF;<span class="comment">//记录f_&#123;y,0&#125; - f_&#123;y,2&#125;的最小值</span></span><br><span class="line">	<span class="keyword">bool</span> flag = <span class="literal">false</span>;<span class="comment">//记录是否选择全部不选</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = hd[x];i;i = nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">int</span> y = to[i];</span><br><span class="line">		<span class="keyword">if</span> (y == fa) <span class="keyword">continue</span>;</span><br><span class="line">		dfs(y,x);</span><br><span class="line">		f[x][<span class="number">0</span>] += <span class="built_in">std</span>::min(f[y][<span class="number">0</span>],<span class="built_in">std</span>::min(f[y][<span class="number">1</span>],f[y][<span class="number">2</span>]));<span class="comment">//第一种情况更新</span></span><br><span class="line">		f[x][<span class="number">1</span>] += <span class="built_in">std</span>::min(f[y][<span class="number">0</span>],f[y][<span class="number">2</span>]);<span class="comment">//第二种情况更新</span></span><br><span class="line">		<span class="keyword">if</span> (f[y][<span class="number">0</span>] &lt; f[y][<span class="number">2</span>]) &#123;</span><br><span class="line">			f[x][<span class="number">2</span>] += f[y][<span class="number">0</span>];</span><br><span class="line">			flag = <span class="literal">true</span>;<span class="comment">//选择了f_&#123;y,0&#125;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			del = <span class="built_in">std</span>::min(del,f[y][<span class="number">0</span>] - f[y][<span class="number">2</span>]);<span class="comment">//计算f_&#123;y,0&#125; - f_&#123;y,2&#125;的最小值</span></span><br><span class="line">			f[x][<span class="number">2</span>] += f[y][<span class="number">2</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">		f[x][<span class="number">2</span>] += del;<span class="comment">//如果没有选择则暴力加上</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	read(n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> x;read(x);<span class="keyword">int</span> y;read(y);</span><br><span class="line">		addedge(x,y);</span><br><span class="line">		deg[y]++;<span class="comment">//记录每个点入度</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> root = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) <span class="keyword">if</span> (!deg[i]) root = i;<span class="comment">//记录根节点</span></span><br><span class="line">	dfs(root,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">std</span>::min(f[root][<span class="number">0</span>],f[root][<span class="number">2</span>]));</span><br><span class="line">    <span class="comment">//根节点没有父亲，所以不用转移f_&#123;root,1&#125;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>解题报告</category>
      </categories>
      <tags>
        <tag>树上问题</tag>
        <tag>DP</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>Luogu P4552 [Poetize6] IncDec Sequence 解题报告</title>
    <url>/2020/05/14/LuoguP4552/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.luogu.com.cn/problem/P4552" target="_blank" rel="noopener">P2132 IncDec Sequence</a></p>
<p>给定一个长度为 $n$ 的数列 ${a_1,a_2,\cdots,a_n}$，每次可以选择一个区间$[l,r]$，使这个区间内的数都加 $1$ 或者都减 $1$。 </p>
<p>请问至少需要多少次操作才能使数列中的所有数都一样，并求出在保证最少次数的前提下，最终得到的数列有多少种。</p>
</blockquote>
<a id="more"></a>
<p>一道有意思的差分题目，第一个问题相当于积木大赛，可以直接分析也可以根据差分性质来搞。<br>首先做 $a$ 数列的差分数列 $b$，那么问题就变成了使得$b_2…b_n = 0$<br>首先考虑配对一个正数一个负数 这样操作次数是最少的 首先考虑这种<br>这种的操作次数为 $\min(p,q)$ ($p,q$为差分数列正数和，负数和)</p>
<p>显然，这样会造成最后至多一个数没有消灭，此时可以将它与 $b_1$ 或者 $b_{n+1}$ 配对。<br>由于两种配对方式不同，会出现$|p-q|+1$种序列，并且最小次数为$|p-q|$<br>于是就解决了本题。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ri register int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span> &lt;&lt; <span class="number">20</span>], *p1, *p2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getchar() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1 &lt;&lt; 20, stdin), p1 == p2)?EOF: *p1++)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;t)</span> </span>&#123;</span><br><span class="line">	ri v = getchar();T f = <span class="number">1</span>;t = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(v)) &#123;<span class="keyword">if</span> (v == <span class="string">'-'</span>)f = <span class="number">-1</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(v)) &#123;t = t * <span class="number">10</span> + v - <span class="number">48</span>;v = getchar();&#125;</span><br><span class="line">	t *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;t,Args&amp;... args)</span> </span>&#123;</span><br><span class="line">		read(t);read(args...);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">min</span><span class="params">(T x,T y)</span> </span>&#123;<span class="keyword">return</span> x&lt;y?x:y;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">max</span><span class="params">(T x,T y)</span> </span>&#123;<span class="keyword">return</span> x&gt;y?x:y;&#125;</span><br><span class="line"></span><br><span class="line">ll a[N],b[N],n,p,q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) read(a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;++i) &#123;b[i] = a[i]-a[i<span class="number">-1</span>];<span class="keyword">if</span> (b[i] &gt; <span class="number">0</span>)p+=b[i];<span class="keyword">else</span> q -=b[i];&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n%lld"</span>,max(p,q),<span class="built_in">abs</span>(p-q)+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>解题报告</category>
      </categories>
      <tags>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title>Luogu P3842 [TJOI2007]线段 解题报告</title>
    <url>/2020/06/27/LuoguP3842/</url>
    <content><![CDATA[<blockquote>
<p><a href="[&lt;https://www.luogu.com.cn/problem/P2132&gt;](https://www.luogu.com.cn/problem/P3842">P3842 [TJOI2007]线段</a>)</p>
<p>在一个 $n*n$ 的平面上，在每一行中有一条线段，第 $i$ 行的线段的左端点是$(i, l_i)$，右端点是$(i, r_i)$，其中 $i \leq l_i \leq r_i \leq n$。</p>
<p>你从$(1, 1)$点出发，要求沿途走过所有的线段，最终到达$(n, n)$点，且所走的路程长度要尽量短。</p>
<p>更具体一些说，你在任何时候只能选择向下走一步（行数增加 1）、向左走一步（列数减少 1）或是向右走一步（列数增加 1）。当然，由于你不能向上行走，因此在从任何一行向下走到另一行的时候，你必须保证已经走完本行的那条线段。</p>
</blockquote>
<a id="more"></a>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>线性 DP.</p>
<p>首先我们观察题目中的三种操作，可以概括成：</p>
<ul>
<li>在横坐标上 +1 -1</li>
<li>在纵坐标上 +1</li>
</ul>
<p>初步定义 $f_{i,j}$ 代表在第 $i$ 行第 $j$ 列里的最短长度。</p>
<p>然而我们很快可以发现，这里的 $n \leq 20000$ ，而且转移时并不是很好写，有许多冗余状态（横坐标在最长线段外的点我们显然不可能走到）</p>
<p>我们再对这个过程进行深入分析，发现其实在走线段的过程中只有横坐标会变化，而且这个变化并不用 DP 维护，暴力加上即可。</p>
<p>所以我们再定义 $f_{i,0/1}$ 代表在第 $i$ 行时，若为 0，则说明<strong>走完这条线段后</strong>在线段的左端点，若为 1，则说明<strong>走完这条线段后</strong>在线段的右端点。</p>
<p>这样我们的转移也呼之欲出了，</p>
<p>$f_{i,0}$ 可以从 $f_{i-1,0}$ 或 $f_{i-1,1}$ 转移来，转移方程为</p>
<script type="math/tex; mode=display">f_{i,0} = \min(f_{i-1,0} + \operatorname{dis}(l_{i-1},r_i),f_{i-1,1} + \operatorname{dis}(r_{i-1},r_i)) + len + 1</script><p>上述方程表示由上一行的线段的左端点转移来时，先走到当前行的右端点再向下走，最后走一遍到当前线段的左端点。右端点同理。</p>
<p>同理，</p>
<p>$f_{i,1}$  可以从 $f_{i-1,0}$ 或 $f_{i-1,1}$ 转移来，转移方程为</p>
<script type="math/tex; mode=display">f_{i,1} = \min(f_{i-1,0} + \operatorname{dis}(l_{i-1},l_i),f_{i-1,1} + \operatorname{dis}(r_{i-1},l_i)) + len + 1</script><p>上述方程表示由上一行的线段的左端点转移来时，先走到当前行的左端点再向下走，最后走一遍到当前线段的左端点。右端点同理。</p>
<p>因为其满足各个维度线性增长，故其为线性 DP ，时间复杂度 $O(n)$</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ri register int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span> &lt;&lt; <span class="number">20</span>], *p1, *p2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getchar() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1 &lt;&lt; 20, stdin), p1 == p2)?EOF: *p1++)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;t)</span> </span>&#123;</span><br><span class="line">	ri v = getchar();T f = <span class="number">1</span>;t = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(v)) &#123;<span class="keyword">if</span> (v == <span class="string">'-'</span>)f = <span class="number">-1</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(v)) &#123;t = t * <span class="number">10</span> + v - <span class="number">48</span>;v = getchar();&#125;</span><br><span class="line">	t *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;t,Args&amp;... args)</span> </span>&#123;</span><br><span class="line">	read(t);read(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">min</span><span class="params">(T x,T y)</span> </span>&#123;<span class="keyword">return</span> x&lt;y?x:y;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">max</span><span class="params">(T x,T y)</span> </span>&#123;<span class="keyword">return</span> x&gt;y?x:y;&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">0x3f3f3f3f3f3f3f3f</span>LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">25100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">2</span>],l[N],r[N],n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">abs</span>(x-y);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	read(n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;=  n;++i) read(l[i],r[i]);</span><br><span class="line">	f[<span class="number">1</span>][<span class="number">1</span>] = dis(<span class="number">1</span>,r[<span class="number">1</span>]),f[<span class="number">1</span>][<span class="number">0</span>] = dis(<span class="number">1</span>,r[<span class="number">1</span>]) + dis(l[<span class="number">1</span>],r[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> len = dis(l[i],r[i]);</span><br><span class="line">		f[i][<span class="number">0</span>] = min(f[i<span class="number">-1</span>][<span class="number">0</span>]+dis(l[i<span class="number">-1</span>],r[i]),f[i<span class="number">-1</span>][<span class="number">1</span>]+dis(r[i<span class="number">-1</span>],r[i])) + len + <span class="number">1</span>;</span><br><span class="line">		f[i][<span class="number">1</span>] = min(f[i<span class="number">-1</span>][<span class="number">0</span>]+dis(l[i<span class="number">-1</span>],l[i]),f[i<span class="number">-1</span>][<span class="number">1</span>]+dis(r[i<span class="number">-1</span>],l[i])) + len + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans = min(f[n][<span class="number">0</span>] + dis(l[n],n),f[n][<span class="number">1</span>] + dis(r[n],n));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>解题报告</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title>ACWing 95 费解的开关 解题报告</title>
    <url>/2020/04/07/hardsolvedswitch/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.acwing.com/problem/content/97/" target="_blank" rel="noopener">费解的开关</a></p>
<p>给你一个 $5\times 5$ 的方格，每次操作可以改变上下左右中五个格子，给定始状态，判断是否可能在6步以内使所有的灯都变亮。</p>
</blockquote>
<a id="more"></a>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>这道题目首先看，我们就知道必然与位运算有着密切的关系，因为出现了0和1，这是一个重要的发现.</p>
<p>接着我们在仔细分析题意，我们知道如果纯暴力枚举的话，必然是会超时的，那么如何优化呢？</p>
<p>我们需要从题目中找出非常有用的性质来优化，这是一个大致的思路方向。</p>
<p>每一个位置顶多只会操作一次。因为如果操作两次的话，相当于不操作，必然是不满足最优解。</p>
<p>在一套方案中，操作的顺序无关紧要，这一个略加思索便可得知。</p>
<p>最重要的性质，如果我们确定了第I行的操作方案的话，那么后面的行数都可以依此递推，下面给出一个详细的解答。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11011</span><br><span class="line">10110</span><br><span class="line">01111</span><br><span class="line">11111</span><br></pre></td></tr></table></figure>
<p>比如说这个例子，如果我们确定了第1行，那么第二行所有的0(坐标：$a_{i,j}$)  </p>
<p>都只能是第三行 $a_{i+1,j}$ 来修改了，因为如果你第二行修改的话，那么第一行将会打乱，下面每一行依此类推。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">char</span> a[N][N];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[<span class="number">5</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,dy[<span class="number">5</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> ax = x + dx[i],ay = y + dy[i];</span><br><span class="line">		<span class="keyword">if</span> (ax &lt; <span class="number">0</span> || ax &gt; <span class="number">4</span> || ay &lt; <span class="number">0</span> || ay &gt; <span class="number">4</span>) <span class="keyword">continue</span>;</span><br><span class="line">		a[ax][ay] ^= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> success = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[<span class="number">4</span>][i] == <span class="string">'0'</span>) &#123;</span><br><span class="line">			success = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">233333333</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; <span class="number">1</span>&lt;&lt;<span class="number">5</span>;++k) &#123;</span><br><span class="line">		<span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">char</span> b[N][N];</span><br><span class="line">		<span class="built_in">memcpy</span>(b,a,<span class="keyword">sizeof</span>(a));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (k &gt;&gt; i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">				step++;</span><br><span class="line">				change(<span class="number">0</span>,i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">5</span>;++j) &#123;</span><br><span class="line">				<span class="keyword">if</span> (a[i][j] == <span class="string">'0'</span>) &#123;</span><br><span class="line">					step++;</span><br><span class="line">					change(i+<span class="number">1</span>,j);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (check()) &#123;</span><br><span class="line">			ans = min(ans,step);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">memcpy</span>(a,b,<span class="keyword">sizeof</span>(b));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ans &lt;= <span class="number">6</span>) <span class="keyword">return</span> ans;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T = read();</span><br><span class="line">	<span class="keyword">while</span> (T -- ) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;++i) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,work());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>解题报告</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>数论入门</title>
    <url>/2020/08/04/Mathgetstarted/</url>
    <content><![CDATA[<p>前言：本文主要是听了洛谷夏令营的网课后做的一些数论笔记，难度大致在提高左右，想获得最好的观看体验，建议您准备好纸笔。</p>
<a id="more"></a>
<h3 id="整除"><a href="#整除" class="headerlink" title="整除"></a>整除</h3><p>若 $a = bk$，其中 $a, b, k$ 都是整数，则 $b$ 整除 $a$，记做 $b|a$。</p>
<p>也称 $b$ 是 $a$ 的约数（因数），$a$ 是 $b$ 的倍数</p>
<h4 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h4><ul>
<li><p>$1$ 整除任何数，任何数都整除 $0$</p>
</li>
<li><p>若 $a|b, a|c$，则 $a|(b + c), a|(b − c)$<br>(证明：$b = b’a,c = c’a$ 然后就随便弄了)</p>
</li>
<li><p>若 $a|b$，则对任意整数 $c$，$a|bc$</p>
</li>
<li><p>传递性：若 $a|b, b|c$，则 $a|c$</p>
</li>
</ul>
<hr>
<h3 id="质数与合数"><a href="#质数与合数" class="headerlink" title="质数与合数"></a>质数与合数</h3><p>若大于 $1$ 的正整数 $p$ 仅有两个因子 $1,p$，则称 $p$ 是一个质数（素数）。</p>
<p>否则，若 $p &gt; 1$，则称 $p$ 是一个合数。</p>
<p><strong>1 不是质数也不是合数</strong></p>
<p>若 $n$ 是一个合数，则 $n$ 至少有 $1$ 个质因子。因此其中最小的质因子一定不大于 $\sqrt{n}$</p>
<p>质数有无穷多个。不大于 $n$ 的质数约有 $\frac{n} {\ln n}$ 个。</p>
<p>唯一分解定理：把正整数 n 写成质数的乘积</p>
<p>（即 $n = p_1 ^ {c_1} p_2^{c_2}p_3^{c_3} \dots p_k ^ {c_k}$，其中 pi 为质数且单调不减），</p>
<p>这样的表示是唯一的。</p>
<hr>
<h3 id="质因数分解"><a href="#质因数分解" class="headerlink" title="质因数分解"></a>质因数分解</h3><p>观察到 $n$ 最多只有 1 个大于 $\sqrt{n}$ 的质因子</p>
<p>直接 $O(\sqrt{n})$ 枚举即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">factor</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i * i &lt;= x;++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) fac[++tot] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x != <span class="number">1</span>) fac[++tot] = x;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="带余除法、同余"><a href="#带余除法、同余" class="headerlink" title="带余除法、同余"></a>带余除法、同余</h3><p>对于$a,b (a,b \in  \mathbb{Z},b &gt; 0)$ ，存在唯一的 $q,r(q,r \in  \mathbb{Z})$ </p>
<p>满足 $a = bq + r$，其中 $0 \leq r &lt; b$ </p>
<p>我们把 $q$ 称为商，$r$ 称为余数</p>
<p>余数可以用 $a \mod b(a \% b)$来表示。</p>
<p>若两数 $a,b$ 除以 $c$ 的余数相等，则称 $a,b$ 模 $c$ 同余，记作 $a \equiv b (\mod c)$</p>
<h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p>$a \equiv b (\mod c)$ 与 $c | (a - b)$ 等价</p>
<h4 id="推论"><a href="#推论" class="headerlink" title="推论"></a>推论</h4><p>若 $a \equiv b (\mod c),d | c$ 则 $a \equiv b (\mod d)$</p>
<hr>
<h3 id="最大公约数-Greatest-Common-Divisor"><a href="#最大公约数-Greatest-Common-Divisor" class="headerlink" title="最大公约数(Greatest Common Divisor)"></a>最大公约数(Greatest Common Divisor)</h3><p>设 $a, b$ 是不都为 0 的整数，$c$ 为满足 $c|a$ 且 $c|b$ 的最大整数，则称 $c$ 是 $a, b$ 的最大公约数</p>
<p>记为 $\gcd(a, b)$ 或 $(a, b)$</p>
<p>类似地可以定义多个数的最大公约数</p>
<p>求 GCD 的一般公式：质因数分解</p>
<script type="math/tex; mode=display">
\begin{aligned}
    &a = p_1^{c_1}p_2^{c_2}\dots p_k^{c_k}\\
    &b = p_1^{d_1}p_2^{d_2}\dots p_k^{d_k}\\
    &(a,b) = p_1^{\min{c_1,d_1}}p_2^{\min{c_2,d_2}} \dots p_k^{\min{c_k,d_k}}
\end{aligned}</script><h4 id="性质：-1"><a href="#性质：-1" class="headerlink" title="性质："></a>性质：</h4><script type="math/tex; mode=display">
\begin{aligned}
    &(a, a) = (0, a) = a \\
    &\text{if } a|b,\text{then }  (a, b) = a \\
    &(a, b) = (a, a + b) = (a, ka + b) \\
    &(ka, kb) = k·(a, b) \\ 
    &(a, b, c) = ((a, b), c) 
\end{aligned}</script><p>若 $(a, b) = 1$，则称 $a, b$ 互质（互素）</p>
<p>互质的两个数往往有很好的性质</p>
<hr>
<h3 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h3><p>又称辗转相除法</p>
<p>迭代求两数 gcd 的做法</p>
<p>由 $(a, b) = (a, ka + b)$ 的性质：$(a, b) = (b, a \mod b)$</p>
<p>时间复杂度 $O(\log \max{a,b})$</p>
<p>如何证明？每次递归 $b$ 的范围缩小一半，也就是说要证明 $a \mod b \leq \frac{a}{2}$</p>
<p>分类讨论一手：</p>
<script type="math/tex; mode=display">
\begin{aligned}
    &1.b \leq \frac{a}{2}\\
    &\Rightarrow a \mod b < b \leq \frac{a}{2}\\
    &2.a > b > \frac{a}{2} \\
    &\Rightarrow a \mod b = a - b \leq \frac{a}{2}
\end{aligned}</script><hr>
<h3 id="裴蜀定理"><a href="#裴蜀定理" class="headerlink" title="裴蜀定理"></a>裴蜀定理</h3><p>设 $(a, b) = d$，则对任意整数 $x, y$，有 $d|(ax + by)$ 成立</p>
<p>特别地，一定存在 $x, y$ 满足 $ax + by = d$</p>
<p>等价的表述：不定方程 $ax + by = c (a,b,c \in  \mathbb{Z})$有解的充要条件为 $(a, b)|c$</p>
<p>推论：$a, b$ 互质等价于 $ax + by = 1$ 有解</p>
<h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>显然有 $d | a,d | b$</p>
<p>根据之前的引理有 $d | ax,d | by$</p>
<p>故 $d | (ax+by)$</p>
<p>对于第二个结论（以下转自<a href="https://oi-wiki.org/math/bezouts/" target="_blank" rel="noopener">OI Wiki</a>）</p>
<p>若任何一个等于 $0$ , 则 $\gcd(a,b)=a$ . 这时定理显然成立。</p>
<p>若 $a,b$ 不等于 $0$ .</p>
<p>由于 $\gcd(a,b)=\gcd(a,-b)$ ,</p>
<p>不妨设 $a,b$ 都大于 $0$ , $a\geq b,\gcd(a,b)=d$ .</p>
<p>对 $ax+by=d$ , 两边同时除以 $d$ , 可得 $a_1x+b_1y=1$ , 其中 $(a_1,b_1)=1$ .</p>
<p>转证 $a_1x+b_1y=1$ .</p>
<p>我们先回顾一下辗转相除法是怎么做的，由 $\gcd(a, b) \rightarrow \gcd(b,a\mod b) \rightarrow …$ 我们把模出来的数据叫做 $r$ 于是，有</p>
<script type="math/tex; mode=display">\gcd(a_1,b_1)=\gcd(b_1,r_1)=\gcd(r_1,r_2)=\cdots=(r_{n-1},r_n)=1</script><p>把辗转相除法中的运算展开，做成带余数的除法，得</p>
<script type="math/tex; mode=display">
\begin{aligned}
    a_1 &= q_1b+r_1 &(0\leq r_1<b_1) \\
    b_1 &= q_2r_1+r_2 &(0\leq r_2<r_1) \\ 
    r_1 &= q_3r_2+r_3 &(0\leq r_3<r_2) \\ 
    &\cdots \\
    r_{n-3} &= q_{n-1}r_{n-2}+r_{n-1} \\
    r_{n-2} &= q_nr_{n-1}+r_n \\
    r_{n-1} &= q_{n+1}r_n
\end{aligned}</script><p>不妨令辗转相除法在除到互质的时候退出则 $r_n=1$ 所以有（ $q$ 被换成了 $x$ ，为了符合最终形式）</p>
<script type="math/tex; mode=display">r_{n-2}=x_nr_{n-1}+1</script><p>即</p>
<script type="math/tex; mode=display">1=r_{n-2}-x_nr_{n-1}</script><p>由倒数第三个式子 $r_{n-1}=r_{n-3}-x_{n-1}r_{n-2}$ 代入上式，得</p>
<script type="math/tex; mode=display">1=(1+x_nx_{n-1})r_{n-2}-x_nr_{n-3}</script><p>然后用同样的办法用它上面的等式逐个地消去 $r_{n-2},\cdots,r_1$ ,</p>
<p>可证得 $1=a_1x+b_1y$ . 这样等于是一般式中 $d=1$ 的情况。</p>
<hr>
<h3 id="Exgcd"><a href="#Exgcd" class="headerlink" title="Exgcd"></a>Exgcd</h3><p>由裴蜀定理可得，方程 $ax + by = \gcd(a,b)$ 必有一组解。</p>
<p>所以我们考虑如何求出这样的方程的一组解。</p>
<h4 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h4><p>设 </p>
<script type="math/tex; mode=display">
\begin{aligned}
    &ax_1 + by_1 = \gcd(a,b) \\
    &bx_2 + (a \mod b)y_2 = \gcd(b,a \mod b) 
\end{aligned}</script><p>则</p>
<script type="math/tex; mode=display">
\begin{aligned}
    &\because \gcd(a,b) = \gcd(b,a \mod b)\\
    &\therefore ax_1 + by_1 = bx_2 + (a \mod b)y_2 \\
    &\because (a \mod b ) = a - (\lfloor \frac{a}{b} \rfloor \times b)\\
    &\therefore ax_1 + by_1 = bx_2 + (a-\lfloor \frac{a}{b} \rfloor \times b) y_2 \\
\end{aligned}</script><p>展开得</p>
<script type="math/tex; mode=display">
\begin{aligned}
    &ax_1 + by_1 = ay_2 + bx_2 - \lfloor \frac{a}{b} \rfloor by_2 = &ay_2 + b(x_2 - \lfloor \frac{a}{b} \rfloor y_2)\\
    &\because a = a,b = b \\
    &\therefore x_1 = y_2 , y_1 = x_2 - \lfloor \frac{a}{b} \rfloor y_2
\end{aligned}</script><p>所以就可以递归求解了。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)  &#123;</span><br><span class="line">        x = <span class="number">1</span>,y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> q = a / b;</span><br><span class="line">    exgcd(b,a%b,y,x);</span><br><span class="line">    x = y;</span><br><span class="line">    y = y - q * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p>考虑形如 $ax + by = c (a,b,c \in  \mathbb{Z})$ 的方程的所有解</p>
<p>首先由裴蜀定理得，不定方程 $ax + by = c (a,b,c \in  \mathbb{Z})$有解的充要条件为 $(a, b)|c$ 。</p>
<p>先考虑求一组特殊解的情况：首先将 $a,b,c$ 都除以 $\gcd(a,b)$ 得 $a_0x + b_0y = c_0$</p>
<p>此时 $\gcd(a_0,b_0) = 1$,所以我们可以求出 $a_0x + b_0y = 1$ 的一组解 $x_0,y_0$ ，则原方程的一组特解为</p>
<script type="math/tex; mode=display">x_1 = \frac{x_0c}{\gcd(a,b)},y_1 = \frac{y_0c}{\gcd (a,b)}</script><p>然后我们考虑构造所有解的形式：</p>
<p>设有 $d (d \in \mathbb{Q})$ 那么必有 $a(x_1 + db) + b(y_1 - da) = c$</p>
<p>同时，这组解需要保证 $db,da \in  \mathbb{Z}$</p>
<p>令当 $d$ 取到最小可能的正值的 $d_x = db,d_y = da$ ,那么任意解中这两个变量与 $x_1,x_2$ 的偏差一定分别是 $d_x,d_y$ 的倍数。</p>
<p>显然，最小的时候 $d_x = \frac{b}{\gcd (a,b)},d_y = \frac{-a}{\gcd (a,b)}$</p>
<p>所有解就是 $x = x_0 + kd_x,y = y_0 + kd_y (k \in  \mathbb{Z})$</p>
<hr>
<h3 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h3><p>若 $ax \equiv 1 (\mod b)$，则称 $x$ 是 $a$ 关于模 $b$ 的逆元，</p>
<p>常记做 $a^{-1}$。</p>
<p>回忆同余的性质。上式等价于 $ax + by = 1$ </p>
<p>如何求逆元？等价于解方程 $ax + by = 1$</p>
<p>因此逆元不一定存在：存在的充要条件为 $\gcd (a, b) = 1$</p>
<p>推论：$p$ 是质数，$p$ 不整除 $a$，则 $a$ 模 $p$ 的逆元存在。</p>
<p>结论：在 $[0,b)$ 的范围内，若存在 $a$ 关于 $b$ 的逆元，则它是唯一的。</p>
<p>证明：反证法，若存在 2 个 $a$ 关于 $b$ 的逆元，设其为 $x_1,x_2$，不妨假设 $0 &lt; x_1 &lt; x_2 &lt; b$ </p>
<p>也就是说 $ax_1 \equiv ax_2 \equiv 1 (\mod b)$</p>
<p>可以得出 $b | a(x_2 - x_1)$ ，由于 $\gcd(a,b) = 1$，所以 $b | (x_2 - x_1)$</p>
<p>也就是有 $0 \leq (x_2 - x_1) &lt; b$ , 所以不成立。</p>
<h4 id="求逆元"><a href="#求逆元" class="headerlink" title="求逆元"></a>求逆元</h4><p>我们刚才说求逆元等价于解方程 $ax + by = 1$，所以直接 <code>exgcd</code> 求解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inv</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    exgcd(a,b,x,y);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样求单个逆元的复杂度是 $O(\log n)$。</p>
<p>如何 $O(n)$ 求 $1\dots n$ 模质数 $p$ 的逆元？</p>
<ul>
<li><p>方法一：递推</p>
<p>  假设现在要求 $i$ 的逆元  </p>
<p>  考虑带余除法，设 $p = iq + r$，则有 $iq + r \equiv 0(\mod p)$</p>
<p>  注意到 $p$ 是质数，因此 $r \not = {0}$，$r$ 的逆元存在</p>
<p>  等式两边乘 $i^{−1}r^{−1}$，得到 $qr^{−1} + i^{−1} \equiv 0(\mod p)$</p>
<p>  因此 $i−1 \equiv −qr^{−1} \equiv -\frac{p}{i}(p \mod i)^{−1}(\mod p)$</p>
<p>  注意这里如果直接算 $-\frac{p}{i}$ 会产生负数，然后 $p -\frac{p}{i} \equiv -\frac{p}{i} (\mod p)$，所以这么算就不会出问题</p>
<p>  代码</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> inv[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prework</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;++i) &#123;</span><br><span class="line">        inv[i] = (p - p / i) * inv[p % i] % p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>方法二：倒推</li>
</ul>
<p>例题：组合数取模 1</p>
<blockquote>
<p>回答 $T$ 次询问</p>
<p>每次询问 $C(n, k) \mod 998244353$(一个质数)</p>
<p>$T ≤ 10^5$, $0 \leq k \leq n \leq 10^7$</p>
</blockquote>
<p>分析：$C(n, k) = n!/(k!(n − k)!)$</p>
<p>线性求逆，预处理 $n!$ 以及 $n! ^ {-1}$ </p>
<p>$O(1)$ 回答询问</p>
<hr>
<h3 id="线性同余方程"><a href="#线性同余方程" class="headerlink" title="线性同余方程"></a>线性同余方程</h3><p>形如 $ax \equiv c(\mod b)$ 的方程，称为线性同余方程。</p>
<p>等价于 $ax + by = c$ 因此有解条件为 $\gcd(a, b)|c$</p>
<p>若 $\gcd(a, b) = 1$，则 $x$ 有唯一解 $x ≡ a^{-1}c(\mod b)$。</p>
<p>否则设 $(a, b) = d, a = a^{\prime}d, b = b^{\prime}d, c = c’d$</p>
<p>那么有 $a’x + b’y = c’$，即 $a’x \equiv c’(\mod b’)$</p>
<p>这里 $(a’, b’) = 1$，因此有 $x ≡ (a’)^{−1}c’(\mod b’)$</p>
<p>综上，任意的线性同余方程总可以判定为无解，或化为 $x \equiv a(\mod m)$ 的形式。</p>
<hr>
<h3 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h3><p>对于同余方程组 $x \equiv a_i(\mod m_i)(i = 1\dots n)$，</p>
<p>若 $m_i$ 两两互质，则 $x$ 在 $\mod M$ 下有唯一解。这里 $M = m_1m_2\dots m_n$</p>
<h4 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h4><ol>
<li>计算所有模数的积 $M$</li>
<li>对于第 $i$ 个方程<ol>
<li>计算 $n_i = \frac{M}{m_i}$</li>
<li>因为 $\gcd(n_i,m_i) = 1$，所以 $n_i$ 关于 $m_i$ 的逆元 $t_i$ 存在，求出 $t_i$</li>
<li>计算 $c_i = n_i \times t_i$ </li>
</ol>
</li>
<li>方程组的唯一解为 $a = \sum_{i = 1}^k a_ic_i (\mod n)$</li>
</ol>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CRT</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a[],<span class="keyword">const</span> <span class="keyword">int</span> m[],<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> M = <span class="number">1</span>,ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) M *= m[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> ni = M / m[i],ti = inv(ni,m[i]);</span><br><span class="line">        ans = (ans + a[i] *  ni * ti) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>某些计数问题或数论问题给出的模数不是质数 </p>
<p>但是对其质因数分解会发现它没有平方因子，也就是该模数是由一些不重复的质数相乘得到。</p>
<p>那么我们可以分别对这些模数进行计算，最后用 CRT 合并答案。</p>
<hr>
<h3 id="Lucas-定理"><a href="#Lucas-定理" class="headerlink" title="Lucas 定理"></a>Lucas 定理</h3><script type="math/tex; mode=display">\binom{n}{m}\bmod p = \binom{\left\lfloor n/p \right\rfloor}{\left\lfloor m/p\right\rfloor}\cdot\binom{n\bmod p}{m\bmod p}\bmod p</script><hr>
<h3 id="欧拉函数-varphi"><a href="#欧拉函数-varphi" class="headerlink" title="欧拉函数 $\varphi$"></a>欧拉函数 $\varphi$</h3><p>欧拉函数 $\varphi$ (Euler’s totient function)</p>
<p>$\varphi (n)$ 定义为 $[1, n]$ 中与 $n$ 互质的数的个数</p>
<p>例：$\varphi (1) = 1, \varphi (2) = 1, \varphi (6) = 2, \varphi (8) = 4$</p>
<p>若 $p$ 为质数，显然 $\varphi (p) = p - 1$</p>
<h4 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h4><ul>
<li><p>欧拉函数是<strong>积性函数</strong></p>
<p> 若 $\gcd (a,b) = 1$, $\varphi(ab) = \varphi(a) \times \varphi(b)$</p>
<p> 证明：</p>
<p> 首先令 $S(n)$ 为 $[1,n]$ 中与 $n$ 互质的数的集合</p>
<p> 任取 $S(a),S(b)$ 中的数 $a_0,b_0$</p>
<p> 考虑一个线性同余方程组</p>
<script type="math/tex; mode=display">
 \begin{cases}
     \ x \equiv a_0 (\mod a)\\
     \ x \equiv b_0 (\mod b)
 \end{cases}</script><p> 则根据中国剩余定理有 $x \equiv c_0(\mod ab)$ </p>
<p> 可以证明 $\gcd(c_0,a_0) = \gcd(c_0,b_0) = 1$</p>
<p> 所以 $\gcd(c_0,ab) = 1,c_0 \in S(ab)$</p>
<p> 如果反过来，任取 $S(ab)$ 中一个数 $c_0$,那么设 $a_0 = c_0 \mod a,b_0 = c_0 \mod b$</p>
<p> 这样可以证明有 $a_0 \in S(a),b_0 \in S(b)$</p>
<p> 因此，$|S(ab)| = |S(a)| \times |S(b)|$ </p>
<p> 也就是 $\varphi(ab) = \varphi(a) \times \varphi(b)$</p>
</li>
<li><p>若 $n = p ^ k$,则有 $\varphi(n) = n(1-\frac{1}{p})$</p>
<p>  证明：设 $x$ 为满足 $\gcd(x,p^k) &gt; 1$ 的整数,此时 $p | x$</p>
<p>  则这样的 $x$ 有$\frac{n}{p}$ 个,所以 $\varphi(n) = n - \frac{n}{p} = n(1-\frac{1}{p})$</p>
</li>
<li><p>若 $n$ 所有<strong>不同</strong>的质因子为 $p_1,p_2 \dots p_n$</p>
<p>  则 $\varphi(n) = n(1 - \frac{1}{p_1}) \times (1 - \frac{1}{p_2}) \dots (1 - \frac{1}{p_n})$</p>
<p>  证明：把 $n$ 拆成 $p_i ^{a_i}$ 用上面那个就整完了。</p>
</li>
</ul>
<p>根据这些性质，我们可以通过质因子分解求出 $\varphi(n)$，时间复杂度 $O(\sqrt{n})$</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phi</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i * i &lt;= x;++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x *= i;</span><br><span class="line">            ret = ret / i * (i - <span class="number">1</span>);<span class="comment">//这里等价于刚才的1 - 1/p</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) ret = ret / x * (x - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>板子们</title>
    <url>/2019/08/11/%E5%9B%BE%E8%AE%BA%E6%9D%BF%E5%AD%90/</url>
    <content><![CDATA[<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ri register int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span> &lt;&lt; <span class="number">20</span>], *p1, *p2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getchar() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1 &lt;&lt; 20, stdin), p1 == p2)?EOF: *p1++)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;t)</span> </span>&#123;</span><br><span class="line">	ri v = getchar();T f = <span class="number">1</span>;t = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(v)) &#123;<span class="keyword">if</span> (v == <span class="string">'-'</span>)f = <span class="number">-1</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(v)) &#123;t = t * <span class="number">10</span> + v - <span class="number">48</span>;v = getchar();&#125;</span><br><span class="line">	t *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;t,Args&amp;... args)</span> </span>&#123;</span><br><span class="line">		read(t);read(args...);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">min</span><span class="params">(T x,T y)</span> </span>&#123;<span class="keyword">return</span> x&lt;y?x:y;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">max</span><span class="params">(T x,T y)</span> </span>&#123;<span class="keyword">return</span> x&gt;y?x:y;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="存图"><a href="#存图" class="headerlink" title="存图"></a>存图</h2><p>前向星存图，<strong>尽量不用</strong>结构体，<strong>绝对不用</strong>vector<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> hd[N],edg[M],nxt[M],to[M],tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">	edg[++tot] = w;to[tot] = v;nxt[tot] = hd[u];hd[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">	add(u,v,w);add(v,u,w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><p>带堆优化，时间复杂度$O(n\log n)$，在正权图以及<del>SPFA被卡</del>的情况适用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> dis,num;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;a,<span class="keyword">const</span> node &amp;b) &#123;</span><br><span class="line">		<span class="keyword">return</span> a.dis &gt; b.dis;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[N],n,m,s;</span><br><span class="line"><span class="keyword">bool</span> vis[N],hasfuhuan;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">	priority_queue &lt;node&gt; heap;</span><br><span class="line">	<span class="built_in">memset</span>(dis,INF,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">	heap.push((node)&#123;dis[s] = <span class="number">0</span>,s&#125;);</span><br><span class="line">	<span class="keyword">while</span> (!heap.empty()) &#123;</span><br><span class="line">		node p = heap.top();heap.pop();</span><br><span class="line">		<span class="keyword">int</span> x = p.num;</span><br><span class="line">		<span class="keyword">if</span> (vis[x]) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		vis[x] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = hd[x];i;i = nxt[i]) &#123;</span><br><span class="line">			<span class="keyword">int</span> y = to[i],w = edg[i];</span><br><span class="line">			<span class="keyword">if</span> (dis[y] &gt; dis[x] + w) &#123;</span><br><span class="line">				dis[y] = dis[x] + w;</span><br><span class="line">				<span class="keyword">if</span> (!vis[y]) &#123;</span><br><span class="line">					heap.push((node)&#123;dis[y],y&#125;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h3><p>最坏时间复杂度$O(nm)$，在<strong>证明不会被卡</strong>的时候用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	vis[s] = <span class="number">1</span>;dis[s] = <span class="number">0</span>;</span><br><span class="line">	q.push(s);</span><br><span class="line">	<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = q.front();q.pop();</span><br><span class="line">		vis[x] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = hd[x];i;i = nxt[i]) &#123;</span><br><span class="line">			<span class="keyword">int</span> y = to[i],w = edg[i];</span><br><span class="line">			<span class="keyword">if</span> (dis[y] &gt; dis[x] + w) &#123;</span><br><span class="line">				dis[y] = dis[x] + w;</span><br><span class="line">				<span class="keyword">if</span> (!vis[y]) &#123;</span><br><span class="line">					q.push(y);</span><br><span class="line">					vis[y] = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h3><p>稳定时间复杂度$O(nm)$，判负环用 <del>因为不会SPFA判负环</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bellman_Ford</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis,INF,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">	dis[s] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>,flag = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (flag) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;++i) &#123;</span><br><span class="line">			flag = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">int</span> u = edges[i].u,v = edges[i].v,w = edges[i].w;</span><br><span class="line">			<span class="keyword">if</span> (dis[v] &gt; dis[u] + w) &#123;</span><br><span class="line">				dis[v] = dis[u] + w;</span><br><span class="line">				flag = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (++cnt &gt; n) &#123;</span><br><span class="line">				hasfuhuan = <span class="number">1</span>;</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p><del>菜的要死只会Kruskal</del></p>
<h3 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h3><p>并查集+排序 时间复杂度$O(m\log m)$，对于边数较少的图适用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Union-Find Set</span></span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> f[x] == x ? f[x]:f[x] = find(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Kruskal</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> u,v,w;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> edge &amp;a,<span class="keyword">const</span> edge &amp;b) &#123;</span><br><span class="line">		<span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tot = <span class="number">0</span>,ans = <span class="number">0</span>;</span><br><span class="line">	sort(edges+<span class="number">1</span>,edges+<span class="number">1</span>+n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> u = edges[i].u,v = edges[i].v,w = edges[i].w;</span><br><span class="line">		<span class="keyword">if</span> (find(u) != find(v)) &#123;</span><br><span class="line">			ans += w;</span><br><span class="line">			++tot;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (tot == n<span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>用来<del>巧妙</del>求解DAGdp等，利用BFS实现，同样可以用DFS实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">toposort</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!cnt[i]) q.push(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> u = q.front();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = hd[u];i;i = nxt[i]) &#123;</span><br><span class="line">			<span class="keyword">int</span> v = to[i];</span><br><span class="line">			<span class="keyword">if</span> (--cnt[v] == <span class="number">0</span>) &#123;</span><br><span class="line">				q.push(v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树链剖分"><a href="#树链剖分" class="headerlink" title="树链剖分"></a>树链剖分</h2><p><del>树链剖分这个OIer很强</del></p>
<p>快速求解树上问题，具体应用请看<a href="https://www.zzlblog.ga/2019/08/26/树链剖分 学习笔记/">树链剖分 学习笔记</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> dfn[N],top[N],siz[N],son[N],dep[N],fat[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">	son[u] = <span class="number">0</span>;</span><br><span class="line">	siz[u] = <span class="number">1</span>;</span><br><span class="line">	dep[u] = dep[f] + <span class="number">1</span>;</span><br><span class="line">	fat[u] = f;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = hd[u];i;i = nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">int</span> v = to[i],w = edg[i];</span><br><span class="line">		<span class="keyword">if</span> (v != f) &#123;</span><br><span class="line">			dfs(v,u);</span><br><span class="line">			siz[u] += siz[v];</span><br><span class="line">			<span class="keyword">if</span> (siz[v] &gt; siz[son[u]]) &#123;</span><br><span class="line">				son[u] = v;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">	dfn[u] = ++cnt;</span><br><span class="line">	<span class="keyword">if</span> (u == son[f]) &#123;</span><br><span class="line">		top[u] = top[f];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		top[u] = u;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (son[u]) &#123;</span><br><span class="line">		dfs2(son[u],u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = hd[u];i;i = nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">int</span> v = to[i],w = edg[i];</span><br><span class="line">		<span class="keyword">if</span> (v != f &amp;&amp; v != son[u]) &#123;</span><br><span class="line">			dfs2(v,u);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>MST</tag>
        <tag>并查集</tag>
        <tag>拓扑排序</tag>
        <tag>最短路</tag>
        <tag>负环</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>树链剖分 学习笔记</title>
    <url>/2019/08/26/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><del>树链剖分是个很强的 OIer</del></p>
<p>树链剖分是用来解决一系列树上问题的利器。<br><a id="more"></a></p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>链：树上不拐弯的一条路径</li>
<li>重儿子：子树大小最大的儿子</li>
<li>轻儿子：其他儿子</li>
<li>重链：由重儿子组成的链</li>
</ul>
<h2 id="结果和过程"><a href="#结果和过程" class="headerlink" title="结果和过程"></a>结果和过程</h2><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>这是原树</p>
<p><img src="https://s2.ax1x.com/2019/08/25/m2dRDe.png" alt=""></p>
<p>剖分之后的树</p>
<p><img src="https://s2.ax1x.com/2019/08/25/m2wsaj.png" alt=""></p>
<p>这里，<strong>红色的边</strong>构成重链，<strong>蓝色的点</strong>为重儿子，<strong>绿色的点</strong>为轻儿子。</p>
<p>注意，这里的 7 号与 8 号节点子树大小相同，因此我们选择<strong>编号靠前</strong>的儿子为重儿子。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>一般来说，树链剖分通过两遍 dfs 来实现。</p>
<h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">siz[x] <span class="comment">//子树x的大小</span></span><br><span class="line">top[x] <span class="comment">//x所在链的顶端</span></span><br><span class="line">fat[x] <span class="comment">//x的父亲</span></span><br><span class="line">dep[x] <span class="comment">//x的深度</span></span><br><span class="line">son[x] <span class="comment">//x的重儿子</span></span><br></pre></td></tr></table></figure>
<p>第一遍 dfs ，我们先处理出每个节点的<strong>父亲</strong>，<strong>深度</strong>，<strong>子树大小</strong>，<strong>重儿子</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">	siz[u] = <span class="number">1</span>;</span><br><span class="line">	dep[u] = dep[f] + <span class="number">1</span>;</span><br><span class="line">	son[u] = <span class="number">0</span>;</span><br><span class="line">	fat[u] = f;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = hd[u];i;i= nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">int</span> v = to[i];</span><br><span class="line">		<span class="keyword">if</span> (v != f) &#123;</span><br><span class="line">			dfs1(v,u);</span><br><span class="line">			siz[u] += siz[v];</span><br><span class="line">			<span class="keyword">if</span> (siz[v] &gt; siz[son[u]]) &#123;</span><br><span class="line">				son[u] = v;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二遍 dfs，我们处理出每条链<strong>链顶的节点</strong>，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (son[f] == u) &#123;</span><br><span class="line">		top[u] = top[f];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		top[u] = u;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (son[u]) &#123;</span><br><span class="line">		dfs2(son[u],u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = hd[u];i;i = nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">int</span> v = to[i];</span><br><span class="line">		<span class="keyword">if</span> (v != f &amp;&amp; v != son[u]) &#123;</span><br><span class="line">			dfs2(v,u);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样树链剖分的基本结构就写完辣！<del>是不是很简单</del></p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="LCA"><a href="#LCA" class="headerlink" title="LCA"></a>LCA</h4><p>显然，我们可以发现，在一条重链上的两个节点的 LCA 显然就是深度更浅的那个节点。</p>
<p>所以我们可以先将两个节点跳到同一条链上，求出深度浅的那个节点即可，于是有了如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> ta = top[a],tb = top[b];ta != tb;) &#123;</span><br><span class="line">		<span class="keyword">if</span> (dep[ta] &gt; dep[tb]) &#123;</span><br><span class="line">			ta = top[a = fat[ta]];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			tb = top[b = fat[tb]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dep[a] &lt; dep[b] ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度$O(\log{n})$</p>
<p>例题：<a href="https://www.luogu.org/problem/P3379" target="_blank" rel="noopener">板子题</a></p>
<p>随手套个板子写掉。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = N &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> v = getchar();<span class="keyword">int</span> x = <span class="number">0</span>,f = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(v)) &#123;<span class="keyword">if</span> (v == <span class="string">'-'</span>)f = <span class="number">-1</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(v)) &#123;x = x * <span class="number">10</span> + v - <span class="number">48</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> hd[N],edg[M],nxt[M],to[M],n,m,tot,cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">	to[++tot] = v;edg[tot] = w;nxt[tot] = hd[u];hd[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">	add(u,v,w);add(v,u,w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[N],top[N],fat[N],siz[N],son[N],end[N],dep[N],s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">	son[s] = <span class="number">0</span>;</span><br><span class="line">	dep[s] = dep[f] + <span class="number">1</span>;</span><br><span class="line">	siz[s] = <span class="number">1</span>;</span><br><span class="line">	fat[s] = f;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = hd[s];i;i = nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (to[i] != f) &#123;</span><br><span class="line">			dfs1(to[i],s);</span><br><span class="line">			siz[s] += siz[to[i]];</span><br><span class="line">			<span class="keyword">if</span> (siz[to[i]] &gt; siz[son[s]]) &#123;</span><br><span class="line">				son[s] = to[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">	dfn[u] = ++cnt;</span><br><span class="line">	<span class="keyword">if</span> (u == son[f]) &#123;</span><br><span class="line">		top[u] = top[f];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		top[u] = u;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (son[u]) &#123;</span><br><span class="line">		dfs2(son[u],u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = hd[u];i;i = nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">int</span> v = to[i];</span><br><span class="line">		<span class="keyword">if</span> (v != f &amp;&amp; v != son[u]) &#123;</span><br><span class="line">			dfs2(v,u);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	end[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> ta = top[a],tb = top[b];ta != tb;) &#123;</span><br><span class="line">		<span class="keyword">if</span> (dep[ta] &gt; dep[tb]) &#123;</span><br><span class="line">			ta = top[a = fat[ta]];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			tb = top[b = fat[tb]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dep[a] &lt; dep[b] ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = read(),m = read(),s = read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> u = read(),v = read(),w = <span class="number">1</span>;</span><br><span class="line">		addedge(u,v,w);</span><br><span class="line">	&#125;</span><br><span class="line">	dfs1(s,<span class="number">0</span>);</span><br><span class="line">	dfs2(s,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> u = read(),v = read();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,lca(u,v));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="链上修改，子树修改"><a href="#链上修改，子树修改" class="headerlink" title="链上修改，子树修改"></a>链上修改，子树修改</h4><p>这里就必须引出一个新东西了：dfs 序</p>
<p>指的是第几次 dfs 遍历到的这个节点</p>
<p>定义数组<code>dfn[x]</code>为节点 x 的 dfs 序。</p>
<p>我们可以在 <code>dfs2</code> 中顺手维护一下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">	dfn[u] = ++cnt;</span><br><span class="line">	<span class="keyword">if</span> (son[f] == u) &#123;</span><br><span class="line">		top[u] = top[f];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		top[u] = u;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (son)</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = hd[u];i;i = nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">int</span> v = to[i];</span><br><span class="line">		<span class="keyword">if</span> (v != f) &#123;</span><br><span class="line">			dfs2(v,u);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	end[cnt] = u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里给出每个节点加上 <code>dfn</code> 的图</p>
<p><img src="https://s2.ax1x.com/2019/08/25/m2vk9J.png" alt=""></p>
<p>我们可以发现，在每棵<strong>子树</strong>，每条<strong>链</strong>上的dfn都是连续的！</p>
<p>这样看可能不太明朗，我们把它转化成区间来看（这里是子树的，链同理）</p>
<p><img src="https://s2.ax1x.com/2019/08/25/m2vA39.png" alt=""></p>
<p>所以我们就可以利用数据结构维护一下节点了。</p>
<p>对子树修改就是 <code>change(dfn[x],dfn[x]+siz[x]-1)</code></p>
<p>链上修改就是 <code>change(dfn[x],dfn[y])</code></p>
<p>这里的核心思想是：将树上问题转化成序列问题来处理</p>
<p>例题：<a href="https://www.luogu.org/problem/P2590" target="_blank" rel="noopener">[ZJOI2008]树的统计</a></p>
<p>用线段树维护最大值最小值。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = N &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> v = getchar();<span class="keyword">int</span> x = <span class="number">0</span>,f = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(v)) &#123;<span class="keyword">if</span> (v == <span class="string">'-'</span>)f = <span class="number">-1</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(v)) &#123;x = x * <span class="number">10</span> + v - <span class="number">48</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> to[M],hd[N],nxt[M],tot;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	to[++tot] = v;nxt[tot] = hd[u];hd[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	add(u,v);add(v,u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[N],top[N],fat[N],siz[N],dep[N],son[N],rk[N],cnt,n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">	fat[u] = f;</span><br><span class="line">	dep[u] = dep[f] + <span class="number">1</span>;</span><br><span class="line">	son[u] = <span class="number">0</span>;</span><br><span class="line">	siz[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = hd[u];i;i = nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">int</span> v = to[i];</span><br><span class="line">		<span class="keyword">if</span> (v != f) &#123;</span><br><span class="line">			dfs1(v,u);</span><br><span class="line">			siz[u] += siz[v];</span><br><span class="line">			<span class="keyword">if</span> (siz[v] &gt; siz[son[u]]) &#123;</span><br><span class="line">				son[u] = v;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">	dfn[u] = ++cnt;rk[cnt] = u;</span><br><span class="line">	<span class="keyword">if</span> (son[f] == u) &#123;</span><br><span class="line">		top[u] = top[f];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		top[u] = u;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (son[u]) &#123;</span><br><span class="line">		dfs2(son[u],u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = hd[u];i;i = nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">int</span> v = to[i];</span><br><span class="line">		<span class="keyword">if</span> (v != f &amp;&amp; v != son[u]) &#123;</span><br><span class="line">			dfs2(v,u);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> l,r,big,sum;</span><br><span class="line">&#125;tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	tree[p].l = l;tree[p].r = r;</span><br><span class="line">	<span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">		tree[p].big = tree[p].sum = num[rk[l]];</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	build(p &lt;&lt; <span class="number">1</span>,l,mid);</span><br><span class="line">	build(p &lt;&lt; <span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">	tree[p].sum = tree[p&lt;&lt;<span class="number">1</span>].sum + tree[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">	tree[p].big = max(tree[p&lt;&lt;<span class="number">1</span>].big,tree[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].big);</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (tree[p].l == tree[p].r) &#123;</span><br><span class="line">		tree[p].sum = tree[p].big = v;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid = (tree[p].l + tree[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (x &lt;= mid) modify(p&lt;&lt;<span class="number">1</span>,x,v);</span><br><span class="line">	<span class="keyword">if</span> (x &gt; mid) modify(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,v);</span><br><span class="line">	tree[p].sum = tree[p&lt;&lt;<span class="number">1</span>].sum + tree[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">	tree[p].big = max(tree[p&lt;&lt;<span class="number">1</span>].big,tree[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].big);</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">querym</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (tree[p].l &gt;= x &amp;&amp; tree[p].r &lt;= y) &#123;</span><br><span class="line">		<span class="keyword">return</span> tree[p].big;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid = (tree[p].l + tree[p].r) &gt;&gt; <span class="number">1</span>,ans = -INF;</span><br><span class="line">	<span class="keyword">if</span> (x &lt;= mid) &#123;</span><br><span class="line">		ans = max(ans,querym(p&lt;&lt;<span class="number">1</span>,x,y));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (y &gt; mid) &#123;</span><br><span class="line">		ans = max(ans,querym(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,y));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">querys</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (tree[p].l &gt;= x &amp;&amp; tree[p].r &lt;= y) &#123;</span><br><span class="line">		<span class="keyword">return</span> tree[p].sum;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid = (tree[p].l + tree[p].r) &gt;&gt; <span class="number">1</span>,ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (x &lt;= mid) &#123;</span><br><span class="line">		ans += querys(p&lt;&lt;<span class="number">1</span>,x,y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (y &gt; mid) &#123;</span><br><span class="line">		ans += querys(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">	modify(<span class="number">1</span>,dfn[u],t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qmax</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = -INF;</span><br><span class="line">	<span class="keyword">while</span> (top[u] != top[v]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (dep[top[u]] &lt; dep[top[v]]) &#123;</span><br><span class="line">			swap(u,v);</span><br><span class="line">		&#125;</span><br><span class="line">		ans = max(ans,querym(<span class="number">1</span>,dfn[top[u]],dfn[u]));</span><br><span class="line">		u = fat[top[u]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dep[u] &gt; dep[v]) &#123;</span><br><span class="line">		swap(u,v);</span><br><span class="line">	&#125;</span><br><span class="line">	ans = max(ans,querym(<span class="number">1</span>,dfn[u],dfn[v]));</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qsum</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (top[u] != top[v]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (dep[top[u]] &lt; dep[top[v]]) &#123;</span><br><span class="line">			swap(u,v);</span><br><span class="line">		&#125;</span><br><span class="line">		ans += querys(<span class="number">1</span>,dfn[top[u]],dfn[u]);</span><br><span class="line">		u = fat[top[u]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dep[u] &gt; dep[v]) &#123;</span><br><span class="line">		swap(u,v);</span><br><span class="line">	&#125;</span><br><span class="line">	ans += querys(<span class="number">1</span>,dfn[u],dfn[v]);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;++i) &#123;</span><br><span class="line">		addedge(read(),read());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) &#123;</span><br><span class="line">		num[i] = read();</span><br><span class="line">	&#125;</span><br><span class="line">	dfs1(<span class="number">1</span>,<span class="number">0</span>);dfs2(<span class="number">1</span>,<span class="number">0</span>);build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">int</span> m = read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;++i) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">		<span class="keyword">int</span> u = read(),v = read();</span><br><span class="line">		<span class="keyword">if</span> (s == <span class="string">"CHANGE"</span>) &#123;</span><br><span class="line">			change(u,v);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (s == <span class="string">"QSUM"</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,qsum(u,v));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (s == <span class="string">"QMAX"</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,qmax(u,v));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p><a href="https://www.luogu.org/problem/P4114" target="_blank" rel="noopener">Qtree </a>把边权变成点权，巧妙的做法</p>
<p><a href="https://www.luogu.org/problem/P3178" target="_blank" rel="noopener">[HAOI2015]树上操作</a> 练手，区间修改，区间查询</p>
<p><a href="https://www.luogu.org/problem/P3258" target="_blank" rel="noopener">[JLOI2014]松鼠的新家</a> 巧妙的做法，也可以用树上差分来写</p>
<p><a href="https://www.luogu.org/problem/P2146" target="_blank" rel="noopener">[NOI2015]程序包管理器</a> 稍微转换一下问题</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>感谢 <a href="https://minagami.github.io/" target="_blank" rel="noopener">$\color{black}M\color{red}{inagami}$</a> 给我提供了极大的帮助，感谢 <a href="http://yousiki.github.io/" target="_blank" rel="noopener">$\color{black}Y\color{red}{ouSiKi}$</a> 的教导</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>树链剖分</tag>
        <tag>树</tag>
      </tags>
  </entry>
</search>
