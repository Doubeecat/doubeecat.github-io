<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CodeForcesRound#1206题解]]></title>
    <url>%2F2019%2F08%2F22%2FCodeForcesRound-1206%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[A. Choose Two Numbers题目描述：给你两个集合 $A,B$, 要求你分别从$A,B$中取出一个数，使得两数之和不在$A$中也不在$B$中 $n ,m\leq 100$ 解题思路：看数据范围应该很容易想出来一个 $O(nm(n+m))$ 的暴力，枚举 $A,B$ 中的每一个数，将他们相加之后再在两个集合中判定一下，这个题就完了。事实上由于$n ,m\leq 100$ 可以轻松通过本题。 但是显然，还会有更好的解法，我们可以观察到，如果选取这两个集合中最大的数相加，显然这个和不会出现在两个集合里面，复杂度下降到了 $O(m \log {m} + n \log {n}) $ 如果用排序还可以达到$O(m+n)$的线性时间复杂度(排序是作者给出的解法，实际上可以直接读入的时候求出) 代码： $O(nm(n+m))$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;cctype&gt;inline int read() &#123; char v = getchar();int x = 0,f = 1; while (!isdigit(v)) &#123;if(v == '-')f = -1;v = getchar();&#125; while (isdigit(v)) &#123;x = x * 10 + v - 48;v = getchar();&#125; return x * f;&#125;const int N = 110;int a[N],b[N],n,m,a1,a2;int main() &#123; n = read(); for (int i = 1;i &lt;= n;++i) &#123; a[i] = read(); &#125; m = read(); for (int i = 1;i &lt;= m;++i) &#123; b[i] = read(); &#125; for (int i = 1;i &lt;= n;++i) &#123; for (int j = 1;j &lt;= m;++j) &#123; a1 = a[i],a2 = b[j]; int sum = a1 + a2;bool flag = 0; for (int k = 1;k &lt;= n;++k) &#123; if (sum == a[k]) &#123; flag = 1; break; &#125; &#125; for (int k = 1;k &lt;= m;++k) &#123; if (sum == b[k]) &#123; flag = 1; break; &#125; &#125; if (!flag) &#123; printf("%d %d\n",a1,a2); return 0; &#125; &#125; &#125; return 0;&#125; $O(m + n) $ 12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;using std::max;inline int read() &#123; char v = getchar();int x = 0,f = 1; while (!isdigit(v)) &#123;if(v == '-')f = -1;v = getchar();&#125; while (isdigit(v)) &#123;x = x * 10 + v - 48;v = getchar();&#125; return x * f;&#125;const int N = 110;int tmp,a,b;int main() &#123; n = read(); for (int i = 1;i &lt;= n;++i) &#123; tmp = read(); a = max(a,tmp); &#125; m = read(); for (int i = 1;i &lt;= m;++i) &#123; tmp = read(); b = max(b,tmp); &#125; printf("%d %d",a,b); return 0;&#125; B. Make Product Equal One题目描述：给你一个有 $n$ 个数字的数列，你有两种操作：将某个数 $+1$ 或 $-1$ 。求用最小的操作次数让这个数列的每一项乘起来等于 1 $n \leq 10^5$ 解题思路：用C换来的 分析一下，每个数字只有两种情况：变成 1 或者变成 -1 所以每个数字的代价就是min(abs(1 - a[i]),abs(-1 - a[i])) 值得一提的几个大坑点是，最后可能会变成 -1 ，所以顺便记一下，如果最后变成 -1 了记得加上 2 。而且 0 也要记，最后要加上 0 的个数。 时间复杂度$O(n)$ 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;#define int long longinline int read() &#123; char v = getchar();int x = 0,f = 1; while (!isdigit(v)) &#123;if(v == '-')f = -1;v = getchar();&#125; while (isdigit(v)) &#123;x = x * 10 + v - 48;v = getchar();&#125; return x * f;&#125;const int N = 100010;int pre[N],n,p1,p2,ans,z,res = 1;signed main() &#123; n = read(); for (int i = 1;i &lt;= n;++i) &#123; pre[i] = read(); if (pre[i] == 0) &#123; z++; &#125; &#125; sort(pre+1,pre+1+n); for (int i = 1;i &lt;= n;++i) &#123; if (pre[i] &lt;= -1) &#123; ans += (-1 - pre[i]); res *= -1; &#125; else if (pre[i] &gt;= 1) &#123; ans += (pre[i] - 1); res *= 1; &#125; &#125; if (res == -1) &#123; if (z) &#123; ans += z; &#125; else &#123; ans += 2; &#125; &#125; else &#123; ans += z; &#125; cout &lt;&lt; ans; return 0;&#125; C. Almost Equal题目描述：给定一个数字 $n$ ，要求你使用 $1…2*n$ 的数字构造出一个环，使得这个环每三个数相加的和之间差不超过 1. 解题思路：偶数显然不能构造，奇数按照样例构造即可，具体看代码 代码：123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using std::min;inline int read() &#123; char v = getchar();int x = 0,f = 1; while (!isdigit(v)) &#123;if(v == '-')f = -1;v = getchar();&#125; while (isdigit(v)) &#123;x = x * 10 + v - 48;v = getchar();&#125; return x * f;&#125;const int N = 200010;int pre[N],n,now = 1;int main() &#123; n = read(); if (n % 2 == 0) &#123; printf("NO"); return 0; &#125; for (int i = 1;i &lt;= 2*n;++i) &#123; pre[now] = i; if (i % 2 == 0) &#123; now += 1; &#125; else &#123; if ((i / 2) % 2) &#123; now -= n; &#125; else &#123; now += n; &#125; &#125; &#125; printf("YES\n"); for (int i = 1;i &lt;= 2*n;++i) &#123; printf("%d ",pre[i]); &#125; return 0;&#125; D. Shortest Circle题目描述：给你 $n$ 个点，每个点有一个点权，两点之间有边当且仅当 $a[i] \&amp; a[j] \ne 0$ ，求出图中最小环的长度。 $n \leq 100000,a_i \leq 10^{18}$ 解题思路：直接构造显然是 $O(n^2)$ 的，考虑优化建边的过程。 首先可以观察到，如果二进制内某一位有 3 个 1 ，那么肯定有一个长度为 3 的环，直接输出即可。 那么现在问题简化为了每位至多有两个 1 的情况，我们可以发现每一位最多只有一条边，所以整张图其实至多剩下 60 条边了！接下来直接跑一遍最小环即可，我使用的是 Floyd . 注意开 long long 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cctype&gt;#define min(a,b) ((a) &lt; (b) ? (a) : (b))#define int long longconst int N = 100010;const int M = 130; inline int read() &#123; char v = getchar();int x = 0,f = 1; while (!isdigit(v)) &#123;if (v == '-')f = -1;v = getchar();&#125; while (isdigit(v)) &#123;x = x * 10 + v - 48;v = getchar();&#125; return x * f;&#125; int a[N],pre[N],f[M][M],n,cnt,dis[M][M],ans = 0x3f3f3f3f;signed main() &#123; n = read(); for (int i = 1;i &lt;= n;++i) &#123; a[i] = read(); if (a[i] != 0) pre[++cnt] = a[i]; &#125; for (int i = 1;i &lt;= 64;++i) &#123; int cnt = 0; for (int j = 1;j &lt;= n;++j) &#123; if (a[j]&gt;&gt;(i-1)&amp;1) &#123; cnt++; &#125; &#125; if (cnt &gt;= 3) &#123; printf("3"); return 0; &#125; &#125; for (int i = 1;i &lt;= cnt;++i) &#123; for (int j = 1;j &lt;= cnt;++j) &#123; if (i != j &amp;&amp; (pre[i] &amp; pre[j]) != 0) &#123; f[i][j] = 1;dis[i][j] = 1; &#125; else &#123; f[i][j] = dis[i][j] = 0x3f3f3f3f; &#125; &#125; &#125; for (int k = 1;k &lt;= cnt;++k) &#123; for (int i = 1;i &lt; k;++i) &#123; for (int j = i+1;j &lt; k;++j) &#123; ans = min(dis[i][j] + f[i][k] + f[k][j],ans); &#125; &#125; for (int i = 1;i &lt;= cnt;++i) &#123; for (int j = 1;j &lt;= cnt;++j) &#123; dis[i][j] = min(dis[i][k]+dis[k][j],dis[i][j]); &#125; &#125; &#125; printf("%d\n",((ans&gt;=0x3f3f3f3f) ? -1 : ans));&#125;]]></content>
      <categories>
        <category>Codeforces赛后题解</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
        <tag>图论</tag>
        <tag>暴力</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces55D-Beautiful Numbers 解题报告]]></title>
    <url>%2F2019%2F08%2F13%2FCodeforces55D-Beautiful%20Numbers%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[题目链接Codeforces55D-Beautiful Numbers 题意简述定义“美丽的数字”为：被它自己的每一位数上的数整除的数 给定区间[L,R]，求有多少个美丽的数字 思路显然的数位DP，简单拉个板子就写完了.但是定义状态的时候发现会存不下，我们考虑压缩一下他们的状态。 引入两条重要的性质： 如果一个数能整除它的所有数位上的数，那么它一定能整除所有这些数位上的数的最小公倍数 而$1$到$9$的最小公倍数是$2520$，所有数可能形成的数位上所有数的最小公倍数一定是$2520$的因数 因为$lcm(1,2,3,4,5,6,7,8,9) = 2520$，所以直接定义$dp[i][j][k]$为前$i$位数$mod$$ 2520 = j$，前$i$位数的$lcm$为$j$。 然而，这样设计状态出来会发现总状态数达到了$2025202520 = 127008000$，显然存不下，我们再次考虑进行优化。观察到第二维还是会有冗余，手打个表可以发现总共只有48种可能性，再次进行压缩。 根据性质1，如果最后的数能整除$k$，那么它一定能整除它各位数字的最小公倍数。由于性质2，所有可能出现的$k$都是$2520$的因数，借助这一性质，将$j$取模$2520$，若所得的结果整除$k$，那么原来的数也一定整除$k$。所以转移方程就很自然的出来了： $f[i][j][k] = \sum f[i][lcm(k,x)][j*10+x \mod 2520|1 \leq x\leq Maxx]$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#define ll long long#define FILE A#define N 2520 + 1#define M 200inline ll read() &#123; char v = getchar();ll x = 0,f = 1; while (!isdigit(v)) &#123;if (v == '-')&#123;f = -1;&#125;v = getchar();&#125; while (isdigit(v)) &#123;x = x * 10 + v - 48;v = getchar();&#125; return x * f;&#125;ll dp[20][50][N],dig[N],ind[N],cnt,mod,num[N],l,r,c;ll gcd(int a,int b)&#123;return b?gcd(b,a%b):a;&#125;ll mylcm(int a,int b)&#123;return a/gcd(a,b)*b;&#125;ll dfs(ll now,ll lcm,ll sum,int limit) &#123; if (!now) &#123; return sum % lcm == 0; &#125; if (!limit &amp;&amp; dp[now][num[lcm]][sum] != -1) return dp[now][num[lcm]][sum]; ll ans = 0,ret = (limit)?dig[now]:9; for (ll i = 0;i &lt;= ret;++i) &#123; int lcm1 = i ? mylcm(lcm,i) : lcm; int sum1 = (sum * 10 + i) % mod; ans += dfs(now-1,lcm1,sum1,limit&amp;&amp;i==ret); &#125; if (!limit) &#123; dp[now][num[lcm]][sum] = ans; &#125; return ans;&#125;ll work(ll x) &#123; int len = 0; while (x) &#123; dig[++len] = x % 10;x /= 10; &#125; return dfs(len,1,0,1);&#125;int main() &#123; memset(dp,-1,sizeof(dp)); int T = read(); mod = 2520; for (int i = 1;i &lt;= mod;++i) &#123; if (mod % i == 0) &#123; num[i] = cnt++; &#125; &#125; while (T--) &#123; ll l = read(),r = read(); printf("%lld\n",work(r) - work(l-1)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>解题报告</category>
      </categories>
      <tags>
        <tag>数位DP</tag>
        <tag>DP</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经验教训]]></title>
    <url>%2F2019%2F08%2F11%2F%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD%2F</url>
    <content type="text"><![CDATA[多组数据一定要清空（@zgjjj） 在同样的数据范围($n \leq 1000$)下，跑$n$边Djikstra比Floyd快($O((n+m)^2 \log n)$与$O(n^3)$，如果有O2常数差不多)]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图论板子]]></title>
    <url>%2F2019%2F08%2F11%2F%E5%9B%BE%E8%AE%BA%E6%9D%BF%E5%AD%90%2F</url>
    <content type="text"><![CDATA[存图前向星存图，尽量不用结构体，绝对不用vector123456789int hd[N],edg[M],nxt[M],to[M],tot;inline void add(int u,int v,int w) &#123; edg[++tot] = w;to[tot] = v;nxt[tot] = hd[u];hd[u] = tot;&#125;inline void addedge(int u,int v,int w) &#123; add(u,v,w);add(v,u,w);&#125; 最短路Dijkstra带堆优化，时间复杂度$O(n\log n)$，在正权图以及SPFA被卡的情况适用 1234567891011121314151617181920212223242526272829303132struct node &#123; int dis,num; friend inline bool operator &lt; (const node &amp;a,const node &amp;b) &#123; return a.dis &gt; b.dis; &#125;&#125;;int dis[N],n,m,s;bool vis[N],hasfuhuan;void Dijkstra(int s) &#123; priority_queue &lt;node&gt; heap; memset(dis,INF,sizeof(dis)); heap.push((node)&#123;dis[s] = 0,s&#125;); while (!heap.empty()) &#123; node p = heap.top();heap.pop(); int x = p.num; if (vis[x]) &#123; continue; &#125; vis[x] = 1; for (int i = hd[x];i;i = nxt[i]) &#123; int y = to[i],w = edg[i]; if (dis[y] &gt; dis[x] + w) &#123; dis[y] = dis[x] + w; if (!vis[y]) &#123; heap.push((node)&#123;dis[y],y&#125;); &#125; &#125; &#125; &#125;&#125; SPFA最坏时间复杂度$O(nm)$，在证明不会被卡的时候用 12345678910111213141516171819void SPFA(int s) &#123; queue &lt;int&gt; q; vis[s] = 1;dis[s] = 0; q.push(s); while (!q.empty()) &#123; int x = q.front();q.pop(); vis[x] = 0; for (int i = hd[x];i;i = nxt[i]) &#123; int y = to[i],w = edg[i]; if (dis[y] &gt; dis[x] + w) &#123; dis[y] = dis[x] + w; if (!vis[y]) &#123; q.push(y); vis[y] = 1; &#125; &#125; &#125; &#125;&#125; Bellman-Ford稳定时间复杂度$O(nm)$，判负环用 因为不会SPFA判负环 123456789101112131415161718void Bellman_Ford(int s) &#123; memset(dis,INF,sizeof(dis)); dis[s] = 0; int cnt = 0,flag = 1; while (flag) &#123; for (int i = 0;i &lt; m;++i) &#123; flag = 0; int u = edges[i].u,v = edges[i].v,w = edges[i].w; if (dis[v] &gt; dis[u] + w) &#123; dis[v] = dis[u] + w; flag = 1; &#125; if (++cnt &gt; n) &#123; hasfuhuan = 1; &#125; &#125; &#125;&#125; 最小生成树菜的要死只会Kruskal Kruskal并查集+排序 时间复杂度$O(m\log m)$，对于边数较少的图适用 1234567891011121314151617181920212223242526272829//Union-Find Setint f[N];int find(int x) &#123; return f[x] == x ? f[x]:f[x] = find(f[x]);&#125;//Kruskalstruct edge &#123; int u,v,w; friend inline bool operator &lt; (const edge &amp;a,const edge &amp;b) &#123; return a.w &lt; b.w; &#125;&#125;edges[M];int Kruskal() &#123; int tot = 0,ans = 0; sort(edges+1,edges+1+n); for (int i = 1;i &lt;= m;++i) &#123; int u = edges[i].u,v = edges[i].v,w = edges[i].w; if (find(u) != find(v)) &#123; ans += w; ++tot; &#125; if (tot == n-1) &#123; break; &#125; &#125; return ans;&#125; 拓扑排序用来巧妙求解DAGdp等，利用BFS实现，同样可以用DFS实现 12345678910111213141516int cnt[N];void toposort(int s) &#123; queue &lt;int&gt; q; for (int i = 1;i &lt;= n;++i) &#123; if (!cnt[i]) q.push(i); &#125; while (!q.empty()) &#123; int u = q.front(); for (int i = hd[u];i;i = nxt[i]) &#123; int v = to[i]; if (--cnt[v] == 0) &#123; q.push(v); &#125; &#125; &#125;&#125; 树链剖分树链剖分这个OIer很强 快速求解树上问题，具体应用请看《树链剖分 学习笔记》（咕咕咕） 12345678910111213141516171819202122232425262728293031323334353637int dfn[N],top[N],siz[N],son[N],dep[N],fat[N];void dfs1(int u,int f) &#123; son[u] = 0; siz[u] = 1; dep[u] = dep[f] + 1; fat[u] = f; for (int i = hd[u];i;i = nxt[i]) &#123; int v = to[i],w = edg[i]; if (v != f) &#123; dfs(v,u); siz[u] += siz[v]; if (siz[v] &gt; siz[son[u]]) &#123; son[u] = v; &#125; &#125; &#125;&#125;void dfs2(int u,int f) &#123; dfn[u] = ++cnt; if (u == son[f]) &#123; top[u] = top[f]; &#125; else &#123; top[u] = u; &#125; if (son[u]) &#123; dfs2(son[u],u); &#125; for (int i = hd[u];i;i = nxt[i]) &#123; int v = to[i],w = edg[i]; if (v != f &amp;&amp; v != son[u]) &#123; dfs2(v,u); &#125; &#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>MST</tag>
        <tag>并查集</tag>
        <tag>拓扑排序</tag>
        <tag>最短路</tag>
        <tag>负环</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
</search>
