<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ACwing 92 93 94 解题报告</title>
    <url>/2020/04/06/ACwing-%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.acwing.com/problem/content/94/" target="_blank" rel="noopener">递归实现指数型枚举</a></p>
<p><a href="https://www.acwing.com/problem/content/95/" target="_blank" rel="noopener">递归实现组合型枚举</a></p>
<p><a href="https://www.acwing.com/problem/content/96/" target="_blank" rel="noopener">递归实现排列型枚举</a></p>
<p>指数型：在 $1-n$ 这 $n$ 个整数中随机选取任意多个，输出所有可能的次序。</p>
<p>组合型：从 $1- n$ 这 $n$ 个整数中随机选出 $m$ 个，输出所有可能的选择方案。</p>
<p>排列型：把 $1-n$ 这 $n$ 个整数排成一行后随机打乱顺序，输出所有可能的次序。</p>
</blockquote>
<a id="more"></a>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>这三题的思路大致一致，所以放在一起来写。</p>
<p>指数型：很明显，这个问题可以转化成：</p>
<p>有 $n$ 个整数，每个整数可以选可以不选，求总共有几种方案。</p>
<p>我们可以使用递归来求解问题，每次递归时，我们有两条路：“选”，”不选”</p>
<p>放在代码里就是这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">v.push_back(p);<span class="comment">//选择这个数</span></span><br><span class="line">calc(x+<span class="number">1</span>);<span class="comment">//选择这个数的分支</span></span><br><span class="line">v.pop_back();<span class="comment">//还原现场</span></span><br><span class="line"></span><br><span class="line">calc(x+<span class="number">1</span>);<span class="comment">//不选这个数的分支</span></span><br></pre></td></tr></table></figure>
<p>而每次递归后，我们面对的问题规模（还剩几个数需要选）-1，变成一个规模更小的问题，所以可以用递归求解。</p>
<p>组合型：这个问题和上一个本质一样，我们只要加入更多的限制条件：</p>
<ol>
<li>当当前选取的数数量大于 $m$ 时，不再选数。</li>
<li>当剩下的数全选也不够 $m$ 时，不再选数。</li>
</ol>
<p>放在代码里就是这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (v.size() &gt; m || v.size + (n-x+<span class="number">1</span>) &lt; m) <span class="keyword">return</span> ;</span><br></pre></td></tr></table></figure>
<p>排列性：这里，我们的问题就变成了：</p>
<p>把 $n$ 个整数按照任意次序排列</p>
<p>递归中，我们每次选取一个数放在当前位置，问题就变成了：把 $n-1$ 个整数按照任意次序排列，所以可以用递归来做</p>
<p>放在代码里就是这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!chos[i]) &#123;</span><br><span class="line">			ord[x] = i;</span><br><span class="line">			chos[i] = <span class="number">1</span>;</span><br><span class="line">			calc(x+<span class="number">1</span>);</span><br><span class="line">			chos[i] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p> 指数型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; chosen;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">choice</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == x+<span class="number">1</span>) &#123;</span><br><span class="line">        fp(i,<span class="number">0</span>,chosen.size()) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,chosen[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    choice(n+<span class="number">1</span>);</span><br><span class="line">    chosen.push_back(n);</span><br><span class="line">    choice(n+<span class="number">1</span>);</span><br><span class="line">    chosen.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x = read();</span><br><span class="line">    choice(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>组合型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">c</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (v.size() == m) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>;i &lt; v.size();++i) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d "</span>,v[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (v.size() &gt; m || v.size() + (n - x + <span class="number">1</span>) &lt; m) &#123;<span class="comment">//判断边界，第一个是判断当前是否大于m个了，第二个判断是否选不够</span></span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;	</span><br><span class="line">	v.push_back(x);</span><br><span class="line">	c(x+<span class="number">1</span>);</span><br><span class="line">	v.pop_back();</span><br><span class="line">	c(x+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = read(),m = read();</span><br><span class="line">	c(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>排列型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n,ord[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">bool</span> chos[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x == n+<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d "</span>,ord[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!chos[i]) &#123;</span><br><span class="line">			ord[x] = i;</span><br><span class="line">			chos[i] = <span class="number">1</span>;</span><br><span class="line">			calc(x+<span class="number">1</span>);</span><br><span class="line">			chos[i] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = read();</span><br><span class="line">	calc(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>解题报告</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1336A Linova and Kingdom 解题报告</title>
    <url>/2020/04/16/CF1336A/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://codeforces.ml/contest/1337/problem/C" target="_blank" rel="noopener">CF1336A/CF1337C</a></p>
<p>有一个有 $n$ 个点的树，以 1 为根，你可以选择 $k$ 个节点，使得这 $k$ 个节点到 1 节点的最短路径中经过的非选择的点最多。</p>
</blockquote>
<a id="more"></a>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>先约定：<br>$siz_v$ 为以 $v$ 为根的子树大小，当 $v$ 为叶子节点时，$siz_v = 1$。。<br>$dep_v$ 为从根到 $v$ 的最短路径长度（即深度）。  </p>
<p>首先我们可以发现，这里每选择一个点是会对它的子树造成影响。<br>例如这里：<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/52wr03fh.png" alt=""><br>如果我们已经选择了 4,5，那么如果再选择 2， 4,5 到根节点的权值就会各 -1。<br>所以我们不止要简单的计算深度最大的，而且要计算它的子树大小最小的。<br>因此，我们设一个点的贡献为 $f_v$，$f_v = dep_v - siz_v$,最后对 $f_i$ 排序求出最小的 $k$ 个值相加即可。<br>显然对于 $dep_i$ 和 $siz_i$ 我们可以通过一遍 DFS 求出来<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">	a[s].dep = a[f].dep+<span class="number">1</span>,a[s].siz = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = hd[s];i;i = nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">int</span> v = to[i];</span><br><span class="line">		<span class="keyword">if</span> (v == f) <span class="keyword">continue</span>;</span><br><span class="line">		dfs1(v,s);</span><br><span class="line">		a[s].siz += a[v].siz;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>之后就是简单的计算 $f_i$ 的过程了，不再多说。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//本代码是赛时代码，可能有些变量名称不一样，但大体思路一致。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long<span class="comment">//答案会超出int的范围</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ri register int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> v = getchar();<span class="keyword">int</span> x = <span class="number">0</span>,f = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(v)) &#123;<span class="keyword">if</span> (v == <span class="string">'-'</span>)f = <span class="number">-1</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(v)) &#123;x = x * <span class="number">10</span> + v - <span class="number">48</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">500001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> to[M],hd[N],nxt[M],tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;to[++tot] = v;nxt[tot] = hd[u];hd[u] = tot;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;add(u,v),add(v,u);&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> dep,siz;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="comment">//a[i].dep 存的是 dep[i] a[i].siz 存的是 siz[i] </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a.dep-a.siz)&gt;(b.dep-b.siz);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按照dep[i] - siz[i]（也就是f[i]）排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">	a[s].dep = a[f].dep+<span class="number">1</span>,a[s].siz = <span class="number">1</span>;<span class="comment">//计算dep和siz</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = hd[s];i;i = nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">int</span> v = to[i];</span><br><span class="line">		<span class="keyword">if</span> (v == f) <span class="keyword">continue</span>;</span><br><span class="line">		dfs1(v,s);</span><br><span class="line">		a[s].siz += a[v].siz;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,k,ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = read(),k = read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = read(),y = read();</span><br><span class="line">		addedge(x,y);</span><br><span class="line">	&#125;</span><br><span class="line">	a[<span class="number">0</span>].dep = <span class="number">0</span>,a[<span class="number">0</span>].siz = <span class="number">0</span>;</span><br><span class="line">	dfs1(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);<span class="comment">//排序</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= k;++i) &#123;</span><br><span class="line">		ans += (a[i].dep - a[i].siz);</span><br><span class="line">	&#125;<span class="comment">//选前k个</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>树上问题</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForcesRound#1206题解</title>
    <url>/2019/08/22/CodeForcesRound-1206%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="A-Choose-Two-Numbers"><a href="#A-Choose-Two-Numbers" class="headerlink" title="A. Choose Two Numbers"></a>A. <a href="https://codeforces.com/contest/1206/problem/A" target="_blank" rel="noopener">Choose Two Numbers</a></h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给你两个集合 $A,B$, 要求你分别从$A,B$中取出一个数，使得两数之和不在$A$中也不在$B$中</p>
<p>$n ,m\leq 100$<br><a id="more"></a></p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>看数据范围应该很容易想出来一个 $O(nm(n+m))$ 的暴力，枚举 $A,B$ 中的每一个数，将他们相加之后再在两个集合中判定一下，这个题就完了。事实上由于$n ,m\leq 100$ 可以轻松通过本题。</p>
<p>但是显然，还会有更好的解法，我们可以观察到，如果选取这两个集合中最大的数相加，显然这个和不会出现在两个集合里面，复杂度下降到了 $O(m \log {m} + n \log {n})  $  如果用排序还可以达到$O(m+n)$的线性时间复杂度(排序是作者给出的解法，实际上可以直接读入的时候求出)</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><p> $O(nm(n+m))$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> v = getchar();<span class="keyword">int</span> x = <span class="number">0</span>,f = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(v)) &#123;<span class="keyword">if</span>(v == <span class="string">'-'</span>)f = <span class="number">-1</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(v)) &#123;x = x * <span class="number">10</span> + v - <span class="number">48</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N],b[N],n,m,a1,a2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) &#123;</span><br><span class="line">		a[i] = read();</span><br><span class="line">	&#125;</span><br><span class="line">	m = read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;++i) &#123;</span><br><span class="line">		b[i] = read();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;++j) &#123;</span><br><span class="line">			a1 = a[i],a2 = b[j];</span><br><span class="line">			<span class="keyword">int</span> sum = a1 + a2;<span class="keyword">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= n;++k) &#123;</span><br><span class="line">				<span class="keyword">if</span> (sum == a[k]) &#123;</span><br><span class="line">					flag = <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= m;++k) &#123;</span><br><span class="line">				<span class="keyword">if</span> (sum == b[k]) &#123;</span><br><span class="line">					flag = <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,a1,a2);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> $O(m + n)  $ </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::max;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> v = getchar();<span class="keyword">int</span> x = <span class="number">0</span>,f = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(v)) &#123;<span class="keyword">if</span>(v == <span class="string">'-'</span>)f = <span class="number">-1</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(v)) &#123;x = x * <span class="number">10</span> + v - <span class="number">48</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> tmp,a,b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) &#123;</span><br><span class="line">		tmp = read();</span><br><span class="line">        a = max(a,tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	m = read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;++i) &#123;</span><br><span class="line">		tmp = read();</span><br><span class="line">        b = max(b,tmp);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d"</span>,a,b);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="B-Make-Product-Equal-One"><a href="#B-Make-Product-Equal-One" class="headerlink" title="B. Make Product Equal One"></a>B. <a href="https://codeforces.com/contest/1206/problem/B" target="_blank" rel="noopener">Make Product Equal One</a></h2><h3 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给你一个有 $n$ 个数字的数列，你有两种操作：将某个数 $+1$ 或 $-1$ 。求用最小的操作次数让这个数列的每一项乘起来等于 1</p>
<p>$n \leq 10^5$</p>
<h3 id="解题思路：-1"><a href="#解题思路：-1" class="headerlink" title="解题思路："></a>解题思路：</h3><p><del>用C换来的</del></p>
<p>分析一下，每个数字只有两种情况：变成 1 或者变成 -1 </p>
<p>所以每个数字的代价就是<code>min(abs(1 - a[i]),abs(-1 - a[i]))</code></p>
<p>值得一提的几个<del>大坑</del>点是，最后可能会变成 -1 ，所以顺便记一下，如果最后变成 -1 了记得加上 2 。而且 0 也要记，最后要加上 0 的个数。</p>
<p>时间复杂度$O(n)$</p>
<h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> v = getchar();<span class="keyword">int</span> x = <span class="number">0</span>,f = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(v)) &#123;<span class="keyword">if</span>(v == <span class="string">'-'</span>)f = <span class="number">-1</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(v)) &#123;x = x * <span class="number">10</span> + v - <span class="number">48</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pre[N],n,p1,p2,ans,z,res = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) &#123;</span><br><span class="line">		pre[i] = read();</span><br><span class="line">		<span class="keyword">if</span> (pre[i] == <span class="number">0</span>) &#123;</span><br><span class="line">			z++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(pre+<span class="number">1</span>,pre+<span class="number">1</span>+n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (pre[i] &lt;= <span class="number">-1</span>) &#123;</span><br><span class="line">			ans += (<span class="number">-1</span> - pre[i]);</span><br><span class="line">			res *= <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (pre[i] &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">			ans += (pre[i] - <span class="number">1</span>);</span><br><span class="line">			res *= <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (z) &#123;</span><br><span class="line">			ans += z;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			ans += <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		ans += z;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-Almost-Equal"><a href="#C-Almost-Equal" class="headerlink" title="C. Almost Equal"></a>C. <a href="https://codeforces.com/contest/1205/problem/A" target="_blank" rel="noopener">Almost Equal</a></h2><h3 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个数字 $n$ ，要求你使用 $1…2*n$ 的数字构造出一个环，使得这个环每三个数相加的和之间差不超过 1.</p>
<h3 id="解题思路：-2"><a href="#解题思路：-2" class="headerlink" title="解题思路："></a>解题思路：</h3><p>偶数显然不能构造，奇数按照样例构造即可，具体看代码</p>
<h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::min;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> v = getchar();<span class="keyword">int</span> x = <span class="number">0</span>,f = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(v)) &#123;<span class="keyword">if</span>(v == <span class="string">'-'</span>)f = <span class="number">-1</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(v)) &#123;x = x * <span class="number">10</span> + v - <span class="number">48</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pre[N],n,now = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = read();</span><br><span class="line">	<span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"NO"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">2</span>*n;++i) &#123;</span><br><span class="line">		pre[now] = i;</span><br><span class="line">		<span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">			now += <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> ((i / <span class="number">2</span>) % <span class="number">2</span>) &#123;</span><br><span class="line">				now -= n;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				now += n;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">2</span>*n;++i) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,pre[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="D-Shortest-Circle"><a href="#D-Shortest-Circle" class="headerlink" title="D. Shortest Circle"></a>D. <a href="https://codeforces.com/contest/1205/problem/B" target="_blank" rel="noopener">Shortest Circle</a></h2><h3 id="题目描述：-3"><a href="#题目描述：-3" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给你 $n$ 个点，每个点有一个点权，两点之间有边当且仅当 $a[i] \&amp; a[j] \ne 0$ ，求出图中最小环的长度。</p>
<p>$n \leq 100000,a_i \leq 10^{18}$</p>
<h3 id="解题思路：-3"><a href="#解题思路：-3" class="headerlink" title="解题思路："></a>解题思路：</h3><p>直接构造显然是 $O(n^2)$ 的，考虑优化建边的过程。</p>
<p>首先可以观察到，如果二进制内某一位有 3 个 1 ，那么肯定有一个长度为 3 的环，直接输出即可。</p>
<p>那么现在问题简化为了每位至多有两个 1 的情况，我们可以发现每一位最多只有一条边，所以整张图其实至多剩下 60 条边了！接下来直接跑一遍最小环即可，我使用的是 Floyd .</p>
<p>注意开 long long</p>
<h3 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b) ((a) &lt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">130</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> v = getchar();<span class="keyword">int</span> x = <span class="number">0</span>,f = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(v)) &#123;<span class="keyword">if</span> (v == <span class="string">'-'</span>)f = <span class="number">-1</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(v)) &#123;x = x * <span class="number">10</span> + v - <span class="number">48</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> a[N],pre[N],f[M][M],n,cnt,dis[M][M],ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) &#123;</span><br><span class="line">		a[i] = read();</span><br><span class="line">		<span class="keyword">if</span> (a[i] != <span class="number">0</span>) pre[++cnt] = a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">64</span>;++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (a[j]&gt;&gt;(i<span class="number">-1</span>)&amp;<span class="number">1</span>) &#123;</span><br><span class="line">				cnt++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (cnt &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"3"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= cnt;++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= cnt;++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i != j &amp;&amp; (pre[i] &amp; pre[j]) != <span class="number">0</span>) &#123;</span><br><span class="line">				f[i][j] = <span class="number">1</span>;dis[i][j] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				f[i][j] = dis[i][j] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= cnt;++k) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; k;++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>;j &lt; k;++j) &#123;</span><br><span class="line">				ans = min(dis[i][j] + f[i][k] + f[k][j],ans);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= cnt;++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= cnt;++j) &#123;</span><br><span class="line">				dis[i][j] = min(dis[i][k]+dis[k][j],dis[i][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,((ans&gt;=<span class="number">0x3f3f3f3f</span>) ? <span class="number">-1</span> : ans));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Codeforces赛后题解</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
        <tag>图论</tag>
        <tag>暴力</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces55D-Beautiful Numbers  解题报告</title>
    <url>/2019/08/13/Codeforces55D-Beautiful%20Numbers%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<blockquote>
<p><a href="http://codeforces.com/problemset/problem/55/D" target="_blank" rel="noopener">Codeforces55D-Beautiful Numbers</a></p>
<p>定义“美丽的数字”为：被它自己的每一位数上的数整除的数</p>
<p>给定区间$[L,R]$，求有多少个美丽的数字</p>
</blockquote>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>显然的数位DP，简单拉个板子就写完了.但是定义状态的时候发现会存不下，我们考虑压缩一下他们的状态。</p>
<p>引入两条重要的性质：</p>
<ol>
<li>如果一个数能整除它的所有数位上的数，那么它一定能整除所有这些数位上的数的最小公倍数</li>
<li>而$1$到$9$的最小公倍数是$2520$，所有数可能形成的数位上所有数的最小公倍数一定是$2520$的因数</li>
</ol>
<p>因为$lcm(1,2,3,4,5,6,7,8,9) = 2520$，所以直接定义$dp[i][j][k]$为前$i$位数$mod$$  2520 = j$，前$i$位数的$lcm$为$j$。</p>
<p>然而，这样设计状态出来会发现总状态数达到了$20<em>2520</em>2520 = 127008000$，显然存不下，我们再次考虑进行优化。观察到第二维还是会有冗余，手打个表可以发现总共只有48种可能性，再次进行压缩。</p>
<p>根据性质1，如果最后的数能整除$k$，那么它一定能整除它各位数字的最小公倍数。由于性质2，所有可能出现的$k$都是$2520$的因数，借助这一性质，将$j$取模$2520$，若所得的结果整除$k$，那么原来的数也一定整除$k$。所以转移方程就很自然的出来了：</p>
<p>$f[i][j][k] = \sum f[i][lcm(k,x)][j*10+x \mod 2520|1 \leq x\leq Maxx]$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE A</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2520 + 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 200</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> v = getchar();ll x = <span class="number">0</span>,f = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(v)) &#123;<span class="keyword">if</span> (v == <span class="string">'-'</span>)&#123;f = <span class="number">-1</span>;&#125;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(v)) &#123;x = x * <span class="number">10</span> + v - <span class="number">48</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line">ll dp[<span class="number">20</span>][<span class="number">50</span>][N],dig[N],ind[N],cnt,mod,num[N],l,r,c;<span class="function">ll <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?gcd(b,a%b):a;&#125;</span><br><span class="line"><span class="function">ll <span class="title">mylcm</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a/gcd(a,b)*b;&#125;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(ll now,ll lcm,ll sum,<span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!now) &#123;</span><br><span class="line">		<span class="keyword">return</span> sum % lcm == <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!limit &amp;&amp; dp[now][num[lcm]][sum] != <span class="number">-1</span>) <span class="keyword">return</span> dp[now][num[lcm]][sum];</span><br><span class="line">	ll ans = <span class="number">0</span>,ret = (limit)?dig[now]:<span class="number">9</span>;</span><br><span class="line">	<span class="keyword">for</span> (ll i = <span class="number">0</span>;i &lt;= ret;++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> lcm1 = i ? mylcm(lcm,i) : lcm;</span><br><span class="line">		<span class="keyword">int</span> sum1 = (sum * <span class="number">10</span> + i) % mod;</span><br><span class="line">		ans += dfs(now<span class="number">-1</span>,lcm1,sum1,limit&amp;&amp;i==ret);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">if</span> (!limit) &#123;</span><br><span class="line">		dp[now][num[lcm]][sum] = ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">work</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (x) &#123;</span><br><span class="line">		dig[++len] = x % <span class="number">10</span>;x /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dfs(len,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">	<span class="keyword">int</span> T = read();</span><br><span class="line">	mod = <span class="number">2520</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= mod;++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (mod % i == <span class="number">0</span>) &#123;</span><br><span class="line">			num[i] = cnt++;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		ll l = read(),r = read();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,work(r) - work(l<span class="number">-1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>解题报告</category>
      </categories>
      <tags>
        <tag>数位DP</tag>
        <tag>DP</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>Luogu1840 Color the Axis_NOI导刊2011提高（05） 解题报告</title>
    <url>/2019/09/22/ColortheAxis/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.luogu.org/problem/P1840" target="_blank" rel="noopener">Color the Axis_NOI导刊2011提高（05）</a></p>
<p>在一条数轴上有$N$个点，分别是$1 \rightarrow N$。一开始所有的点都被染成黑色。接着我们进行$M$次操作，第$i$次操作将$[L_i,R_i]$这些点染成白色。请输出每个操作执行后剩余黑色点的个数。</p>
</blockquote>
<a id="more"></a>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>这个题的思路很简单，把黑色的部分当成1，白色的部分当成0来处理，使用支持区间修改，区间查询的数据结构维护一下即可。  </p>
<p>如果你和我一样是写线段树的，那么更简单了，在下传lazytag的时候只需要将其的左右节点清零即可。</p>
<p>另外在区间查询时由于每次都是查整段的，所以只需要输出<code>tree[1].num</code>即可</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">500010</span>&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">0</span>,f = <span class="number">1</span>;<span class="keyword">char</span> v = getchar();</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(v)) &#123;<span class="keyword">if</span> (v ==<span class="string">'-'</span>) f = <span class="number">-1</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(v)) &#123;x = x * <span class="number">10</span> + v - <span class="number">48</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> l,r,num,tag;</span><br><span class="line">&#125;tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	tree[p].l = l;tree[p].r = r;</span><br><span class="line">	<span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">		tree[p].num = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	build (p &lt;&lt; <span class="number">1</span>,l,mid);</span><br><span class="line">	build (p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>,mid + <span class="number">1</span>,r);</span><br><span class="line">	tree[p].num = tree[p&lt;&lt;<span class="number">1</span>].num + tree[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].num;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!tree[p].num) &#123;</span><br><span class="line">		tree[p&lt;&lt;<span class="number">1</span>].num = tree[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].num = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change</span> <span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (tree[p].l &gt;= x &amp;&amp; tree[p].r &lt;= y) &#123;</span><br><span class="line">		tree[p].num = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> ; </span><br><span class="line">	&#125;</span><br><span class="line">	spread(p);</span><br><span class="line">	<span class="keyword">int</span> mid = (tree[p].l + tree[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (mid &gt;= x) change(p&lt;&lt;<span class="number">1</span>,x,y);</span><br><span class="line">	<span class="keyword">if</span> (mid &lt; y) change(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,y);</span><br><span class="line">	tree[p].num = tree[p&lt;&lt;<span class="number">1</span>].num + tree[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].num;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = read(),m = read();</span><br><span class="line">	build (<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = read(),y = read();</span><br><span class="line">		change(<span class="number">1</span>,x,y);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,tree[<span class="number">1</span>].num);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>解题报告</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>Luogu P2194 HXY烧情侣 解题报告</title>
    <url>/2019/10/11/Hxyburncp/</url>
    <content><![CDATA[<h2 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h2><p><a href="https://www.luogu.org/problem/P2194" target="_blank" rel="noopener">P2194 HXY烧情侣</a></p>
<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<p>众所周知，HXY已经加入了FFF团。现在她要开始喜（sang）闻（xin）乐（bing）见（kuang）地烧情侣了。这里有$n$座电影院，$n$对情侣分别在每座电影院里，然后电影院里都有汽油，但是要使用它需要一定的费用。$m$条单向通道连接相邻的两对情侣所在电影院。然后HXY有个绝技，如果她能从一个点开始烧，最后回到这个点，那么烧这条回路上的情侣的费用只需要该点的汽油费即可。并且每对情侣只需烧一遍，电影院可以重复去。然后她想花尽可能少的费用烧掉所有的情侣。问最少需要多少费用，并且当费用最少时的方案数是多少？由于方案数可能过大，所以请输出方案数对$1e9+7$取模的结果。</p>
<p>（注：这里HXY每次可以从任何一个点开始走回路。就是说一个回路走完了，下一个开始位置可以任选。所以说不存在烧不了所有情侣的情况，即使图不连通，HXY自行选择顶点进行烧情侣行动。且走过的道路可以重复走。）<br><a id="more"></a></p>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2></blockquote>
<p>题目中写的很清楚，这题直接套一个 Tarjan 就完了</p>
<p>现在讨论一下两个问题：</p>
<ol>
<li><p>最少需要多少费用</p>
<p>这个比较好想，只要将缩点后的每个 SCC 权值变成其中点权最小的即可</p>
</li>
<li><p>总共有多少方案</p>
<p>这个比较难想，但是我们可以结合一下乘法原理的思想，将每个 SCC 中的点权等于 SCC 的点权的个数相乘</p>
</li>
</ol>
<p>可能有点绕口，我们用形式化的语言来描述一下</p>
<p>记 $siz_i$  为 $SCC_i$ 中点权最小的权值， $num_i$ 为 $SCC_i$ 中点权等于最小点权的权值的点，$cnt$ 为 SCC 数量</p>
<p>则有</p>
<script type="math/tex; mode=display">ans_1 = \sum^{cnt}_{i=1}siz[i]</script><script type="math/tex; mode=display">ans_2 = \prod^{cnt}_{i=1}num_i</script><p>便可写出代码</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">stack</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> long long ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> register int ri</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>],*p1=buf,*p2=buf;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">gc</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,<span class="number">1</span>,<span class="number">1</span>&lt;&lt;<span class="number">21</span>,<span class="built_in">stdin</span>),p1==p2)?EOF:*p1++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> v = gc();<span class="keyword">int</span> x = <span class="number">0</span>,f = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(v)) &#123;<span class="keyword">if</span> (v == <span class="string">'-'</span>)f = <span class="number">-1</span>;v = gc();&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(v)) &#123;x = x * <span class="number">10</span> + v - <span class="number">48</span>;v = gc();&#125;</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">500001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> to[M],hd[N],nxt[M],tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;to[++tot] = v;nxt[tot] = hd[u];hd[u] = tot;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;add(u,v),add(v,u);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">min</span><span class="params">(T x,T y)</span> </span>&#123;<span class="keyword">return</span> x&lt;y?x:y;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">max</span><span class="params">(T x,T y)</span> </span>&#123;<span class="keyword">return</span> x&gt;y?x:y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],c[N],cnt,num,siz[N],p[N],pre[N],ins[N],n,m,ans1,ans2 = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	dfn[x] = low[x] = ++cnt;</span><br><span class="line">	s.push(x);ins[x] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = hd[x];i;i = nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!dfn[to[i]]) &#123;</span><br><span class="line">			tarjan(to[i]);</span><br><span class="line">			low[x] = min(low[x],low[to[i]]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ins[to[i]]) &#123;</span><br><span class="line">			low[x] = min(low[x],dfn[to[i]]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dfn[x] == low[x]) &#123;</span><br><span class="line">		<span class="keyword">int</span> y;c[x] = ++num;</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			y = s.top();c[y] = num;ins[y] = <span class="number">0</span>;s.pop();</span><br><span class="line">			<span class="keyword">if</span> (pre[y] &lt; p[num]) &#123;</span><br><span class="line">				p[num] = pre[y];</span><br><span class="line">				siz[num] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (pre[y] == p[num]) &#123;</span><br><span class="line">				++siz[num];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">while</span> (x != y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(p,INF,<span class="keyword">sizeof</span>(p));</span><br><span class="line">	n = read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) pre[i] = read();</span><br><span class="line">	m = read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = read(),y = read();add(x,y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!dfn[i]) tarjan(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= num;++i) &#123;</span><br><span class="line">		ans1 += p[i];ans2 *= siz[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d %d"</span>,ans1,ans2);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>解题报告</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title>Luogu P3469 [POI2008]BLO-Blockade 解题报告</title>
    <url>/2019/09/08/Luogu%20P3469%20%5BPOI2008%5DBLO-Blockade%20%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.luogu.org/problem/P3469" target="_blank" rel="noopener">[POI2008]BLO-Blockade</a></p>
<p>有 $n$ 个节点的无向图，定义封锁一个点为切断这个点的所有连边。求每个节点被封锁后图内的不连通有序点对个数。</p>
</blockquote>
<a id="more"></a>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>Tarjan。</p>
<p>首先分类讨论一下，封锁一个点有两种情况：</p>
<ol>
<li><p>不是割点</p>
<p>这种情况好搞，从图中显然可以看出只有自己和其他 $n - 1 $ 个节点不连通，因为是有序节点，所以答案为 $2 \times (n-1)$</p>
<p><img src="https://s2.ax1x.com/2019/09/08/n3Muo8.png" alt=""></p>
</li>
<li><p>是割点</p>
<p>这种情况就有意思了。</p>
<p>我们可以发现，如果点 i 为割点，显然去掉这个点之后整个图会变成几个联通块，如下图：</p>
<p><img src="https://s2.ax1x.com/2019/09/08/n3MWFO.png" alt=""></p>
<p>这种情况我们也很好发现，把联通块的大小两两相乘可得答案。</p>
<p>记第 i 个联通块为$s_i$</p>
<p>但是把联通块大小两两相乘的复杂度为 $O(n^2)$ 不能接受，我们可以在 dfs 时把搜索树子树大小算出来，记为 $siz[i]$</p>
<p>最后的答案即为： </p>
<p>$(n - 1 - \sum_{i=1}^{t}siz[s_k])*(1+\sum_{i=1}^{t}siz[s_k])$ </p>
</li>
</ol>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cctype&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N &#x3D; 100010;</span><br><span class="line">const int M &#x3D; 500010&lt;&lt;1;</span><br><span class="line">inline int read() &#123;</span><br><span class="line">	int x &#x3D; 0,f &#x3D; 1;char v &#x3D; getchar();</span><br><span class="line">	while (!isdigit(v)) &#123;if (v &#x3D;&#x3D;&#39;-&#39;) f &#x3D; -1;v &#x3D; getchar();&#125;</span><br><span class="line">	while (isdigit(v)) &#123;x &#x3D; x * 10 + v - 48;v &#x3D; getchar();&#125;</span><br><span class="line">	return x * f;</span><br><span class="line">&#125;</span><br><span class="line">int nxt[M],hd[N],to[M],tot &#x3D; 1,cnt,dfn[N],low[N],siz[N],n,m;</span><br><span class="line">long long ans[N];</span><br><span class="line">bool cut[N];</span><br><span class="line"></span><br><span class="line">inline void adde(int u,int v) &#123;</span><br><span class="line">	to[++tot] &#x3D; v;nxt[tot] &#x3D; hd[u];hd[u] &#x3D; tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline void addedge(int u,int v) &#123;</span><br><span class="line">	adde(u,v);adde(v,u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void tarjan(int x) &#123;</span><br><span class="line">	dfn[x] &#x3D; low[x] &#x3D; ++cnt;</span><br><span class="line">	siz[x] &#x3D; 1;</span><br><span class="line">	int flag &#x3D; 0,sum &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; hd[x];i;i &#x3D; nxt[i]) &#123;</span><br><span class="line">		int v &#x3D; to[i];</span><br><span class="line">		if (!dfn[v]) &#123;</span><br><span class="line">			tarjan(v);</span><br><span class="line">			low[x] &#x3D; min(low[x],low[v]);</span><br><span class="line">			siz[x] +&#x3D; siz[v];</span><br><span class="line">			if (low[v] &gt;&#x3D; dfn[x]) &#123;</span><br><span class="line">				flag++;</span><br><span class="line">				ans[x] +&#x3D; (long long)siz[v]*(n - siz[v]);</span><br><span class="line">				sum +&#x3D; siz[v];</span><br><span class="line">				if (x !&#x3D; 1 || flag &gt; 1) &#123;</span><br><span class="line">					cut[x] &#x3D; 1;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">		else &#123;</span><br><span class="line">			low[x] &#x3D; min(low[x],dfn[v]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (cut[x]) &#123;</span><br><span class="line">		ans[x] +&#x3D; (long long)(n - sum - 1) * (sum + 1) + (n - 1);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		ans[x] &#x3D; 2*(n-1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	n &#x3D; read(),m &#x3D; read();</span><br><span class="line">	for (int i &#x3D; 1;i &lt;&#x3D; m;++i) &#123;</span><br><span class="line">		int x &#x3D; read(),y &#x3D; read();</span><br><span class="line">		if (x &#x3D;&#x3D; y) &#123;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		addedge(x,y);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	tarjan(1);</span><br><span class="line">	for (int i &#x3D; 1;i &lt;&#x3D; n;++i) &#123;</span><br><span class="line">		printf(&quot;%lld\n&quot;,ans[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>部分思路来自于lyd的《算法竞赛进阶指南》</p>
]]></content>
      <categories>
        <category>解题报告</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>Tarjan</tag>
        <tag>割点</tag>
      </tags>
  </entry>
  <entry>
    <title>Luogu P4999 烦人的数学作业 解题报告</title>
    <url>/2019/09/07/Luogu%20P4999%20%E7%83%A6%E4%BA%BA%E7%9A%84%E6%95%B0%E5%AD%A6%E4%BD%9C%E4%B8%9A%20%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.luogu.org/problem/P4999" target="_blank" rel="noopener">P4999 烦人的数学作业</a></p>
<p>给出一个区间$L - R$，求$L$到$R$区间内<strong>每个数的数字和</strong>，如123这个数的数字和为1+2+3=6</p>
<p>有T组数据，结果$\mod 10^9+7$</p>
</blockquote>
<p>$（1 \leq L \leq R \leq 10^18）$<br><a id="more"></a></p>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p><del>确实烦人</del></p>
<p>第一眼看上去跟<a href="https://www.luogu.org/problem/P2602" target="_blank" rel="noopener">[ZJOI2010]数字计数</a>很像，确实是，把那个题的数位DP抄过来乘个 i 这题就没了。</p>
<p>那为啥要写这个题解呢？因为这个题坑多。</p>
<ol>
<li>注意开 long long</li>
<li>取模很坑，请使用传统技巧<code>(ans % mod + mod) % mod</code>，正确性证明应该不用多说</li>
</ol>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = N &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> v = getchar();<span class="keyword">int</span> x = <span class="number">0</span>,f = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(v)) &#123;<span class="keyword">if</span> (v == <span class="string">'-'</span>)f = <span class="number">-1</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(v)) &#123;x = x * <span class="number">10</span> + v - <span class="number">48</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[N],dp[N][N],l,r;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">bool</span> limit,<span class="keyword">bool</span> zer,<span class="keyword">int</span> dig,<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (pos == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">if</span> (!limit &amp;&amp; dp[pos][sum]) <span class="keyword">return</span> dp[pos][sum];</span><br><span class="line">	<span class="keyword">int</span> up = <span class="number">9</span>;</span><br><span class="line">	<span class="keyword">if</span> (limit) up = num[pos];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= up;++j) &#123;</span><br><span class="line">		ans += dfs(pos<span class="number">-1</span>,(j==up)&amp;&amp;limit,zer||j,dig,sum+((j||zer)&amp;&amp;(j==dig)));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!limit&amp;&amp;zer)&#123;</span><br><span class="line">		dp[pos][sum] = ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (p) &#123;</span><br><span class="line">		num[++len] = p % <span class="number">10</span>;</span><br><span class="line">		p /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dfs(len,<span class="number">1</span>,<span class="number">0</span>,w,<span class="number">0</span>) % mod;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T = read();</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		l = read(),r = read();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">9</span>;++i) &#123;</span><br><span class="line">			ans += ((work(r,i) - work(l<span class="number">-1</span>,i) % mod) * i) % mod;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,(ans%mod+mod)%mod);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>解题报告</category>
      </categories>
      <tags>
        <tag>数位DP</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>Luogu P2132 小Z的队伍排列 解题报告</title>
    <url>/2020/06/20/Luogu-P2132-%E5%B0%8FZ%E7%9A%84%E9%98%9F%E4%BC%8D%E6%8E%92%E5%88%97-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.luogu.com.cn/problem/P2132" target="_blank" rel="noopener">P2132 小Z的队伍排列</a></p>
<p>小Z想给班里的同学拍一张合影，为此需要先让大家排好队伍。他希望大家站成 $k$ 排，并规定了每排的人数，保证每一排的人数都不多于后面一排的人数。</p>
<p>这时小Z发现队伍看起来还是乱糟糟的，原因是大家的身高互不相同。于是，他希望排头对齐，每位同学都比自己正后方的同学以及排头方向的同学矮。</p>
<p>排完以后，善于思考的小Z还想知道一共有多少种排法。</p>
</blockquote>
<a id="more"></a>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>线性 DP。</p>
<p>首先因为“保证每一排的人数都不多于后面一排的人数”且“每位同学都比自己正后方的同学以及排头方向的同学矮”，所以合法方案中每行每列的身高显然单调。</p>
<p>所以我们可以从高到低考虑每个学生所站的位置，这样搞的话，我们只要用一个$(a_1,a_2,a_3…a_n)$ 就能体现出已经处理的东西的轮廓。</p>
<p>而每次考虑一个学生的时候，为了保证单调性，我们只能将他放在满足人员未满并且 $a_i &lt; a_{i-1}$ 或 $i = 1$ 的行中。</p>
<p>所以定义 $(a_1,a_2,a_3…a_n)$ 为阶段，这样就满足了动态规划问题的最优子结构性质，并且每安排一名新学生时候 $a_1,a_2,a_3…a_n$ 中总有一个会 $+1$，满足各个维度线性增长的原则，也就是线性 DP 了。</p>
<p>接下来，我们来设计状态转移方程，本题中的 $k \leq 5$，所以<del>无脑</del>设计 </p>
<p>$f_{a_1,a_2,a_3,a_4,a_5}$表示每排从最左边起分别站了 $a_1,a_2,a_3,a_4,a_5$ 个人的方案数量</p>
<p>$f_{0,0,0,0,0} = 1$ </p>
<p>目标：$f_{k_1,k_2,k_3,k_4,k_5}$</p>
<p>转移：</p>
<p>当 $i = 1$ 时，如果 $a_1 &lt; k_1$，也就是人还没被放满时，$f_{a_1+1,a_2,a_3,a_4,a_5}+=f_{a_1,a_2,a_3,a_4,a_5}$</p>
<p>当 $i &gt; 1$ 时，如果 $a_i &lt; k_i \&amp; a_i &lt; a_{i-1}$，$f_{a_1,a_2+1,a_3,a_4,a_5}+=f_{a_1,a_2,a_3,a_4,a_5}$</p>
<p>（此处为当$i = 2$时，其他同理。）</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ri register int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span> &lt;&lt; <span class="number">20</span>], *p1, *p2;</span><br><span class="line"><span class="comment">//#define getchar() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1 &lt;&lt; 20, stdin), p1 == p2)?EOF: *p1++)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;t)</span> </span>&#123;</span><br><span class="line">	ri v = getchar();T f = <span class="number">1</span>;t = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(v)) &#123;<span class="keyword">if</span> (v == <span class="string">'-'</span>)f = <span class="number">-1</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(v)) &#123;t = t * <span class="number">10</span> + v - <span class="number">48</span>;v = getchar();&#125;</span><br><span class="line">	t *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;t,Args&amp;... args)</span> </span>&#123;</span><br><span class="line">		read(t);read(args...);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line">ll f[N][N][N][N][N],n;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	read(n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) read(a[i]);</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> a1 = <span class="number">0</span>;a1 &lt;= a[<span class="number">1</span>];++a1) &#123;</span><br><span class="line">		 <span class="keyword">for</span> (<span class="keyword">int</span> a2 = <span class="number">0</span>;a2 &lt;= min(a1,a[<span class="number">2</span>]);++a2) &#123;</span><br><span class="line">		 	<span class="keyword">for</span> (<span class="keyword">int</span> a3 = <span class="number">0</span>;a3 &lt;= min(a2,a[<span class="number">3</span>]);++a3) &#123;</span><br><span class="line">		 		<span class="keyword">for</span> (<span class="keyword">int</span> a4 = <span class="number">0</span>;a4 &lt;= min(a3,a[<span class="number">4</span>]);++a4) &#123;</span><br><span class="line">		 			<span class="keyword">for</span> (<span class="keyword">int</span> a5 = <span class="number">0</span>;a5 &lt;= min(a4,a[<span class="number">5</span>]);++a5) &#123;</span><br><span class="line">		 				ll &amp;p = f[a1][a2][a3][a4][a5];<span class="comment">//指针储存，传统艺能</span></span><br><span class="line">		 				<span class="keyword">if</span> (a1 &amp;&amp; a1 &gt; a2) p += f[a1<span class="number">-1</span>][a2][a3][a4][a5];</span><br><span class="line">		 				<span class="keyword">if</span> (a2 &amp;&amp; a2 &gt; a3) p += f[a1][a2<span class="number">-1</span>][a3][a4][a5];</span><br><span class="line">		 				<span class="keyword">if</span> (a3 &amp;&amp; a3 &gt; a4) p += f[a1][a2][a3<span class="number">-1</span>][a4][a5];</span><br><span class="line">		 				<span class="keyword">if</span> (a4 &amp;&amp; a4 &gt; a5) p += f[a1][a2][a3][a4<span class="number">-1</span>][a5];</span><br><span class="line">		 				<span class="keyword">if</span> (a5) p += f[a1][a2][a3][a4][a5<span class="number">-1</span>];</span><br><span class="line">		 			&#125;</span><br><span class="line">		 		&#125;</span><br><span class="line">		 	&#125;</span><br><span class="line">		 &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[a[<span class="number">1</span>]][a[<span class="number">2</span>]][a[<span class="number">3</span>]][a[<span class="number">4</span>]][a[<span class="number">5</span>]]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>DP</tag>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title>Luogu P1032 字串变换 解题报告</title>
    <url>/2020/02/11/LuoguP1032/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.luogu.com.cn/problem/P1032" target="_blank" rel="noopener">【NOIP2002】字串变换</a></p>
<p>给你两个字符串 $A,B$ ，并给你 $n$ 个规则$(n\leq 6)$ ，求从 $A$ 到 $B$ 最小的变换步数（若$10$步内无法变换则无解，字符串长度不能超过$20$）。</p>
</blockquote>
<a id="more"></a>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>从”$10$步内无法变换则无解” 则可以马上反应到：这是个搜索题（要素察觉）</p>
<p>既然是个搜索题，我们就要确定几点：搜索方式，搜索状态，搜索转移，搜索边界。</p>
<p>方式：这题是求最快的步数，所以我们采用 bfs 显然会比 dfs 快很多，而且有起点和终点状态我们就可以用双向搜索（具体不多说了），这里我们讲单向 bfs 的方法。</p>
<p>状态：首先，题目是对一个字符串进行操作，所以字符串显然是其中的一个状态</p>
<p>其次，题目中提到了对步数的限制，所以步数也是其中的一个状态。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> sum;<span class="comment">//步数</span></span><br><span class="line">    <span class="built_in">string</span> s;<span class="comment">//当前字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转移：其实题目中给的已经很明显了：就是按照这几种规则去转移当前字符串即可。</p>
<p>边界：题目中也有明显的指出，每次取出队头节点时要判断一下步数是否$ &gt; 10$。</p>
<p>以上便是此题的基本思路，但是这题的代码及其繁琐，所以我们着重讲一讲代码的实现。</p>
<ol>
<li><p>储存规则：规则是两个字符串，我们可以用一个<code>pair&lt;string,string&gt;</code>来储存。</p>
</li>
<li><p>转移：我们用的是<code>string</code>，在这里，我们可以使用<code>stirng::find</code> 和 <code>string::replace</code>来实现字串的替换。</p>
</li>
<li><p>特判：每次取出节点的时候判断一下步数，每次变换完判断一下长度是否超限。</p>
</li>
</ol>
<p>由此，我们可以写出一份基本的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; &gt; ma;<span class="comment">//储存变换规则</span></span><br><span class="line"><span class="built_in">queue</span> &lt;node&gt; s;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	node s = (node)&#123;a,<span class="number">0</span>&#125;;</span><br><span class="line">	q.push(s);<span class="comment">//初始状态插入</span></span><br><span class="line">	<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">		node p = q.front();q.pop();</span><br><span class="line">		<span class="built_in">string</span> now = p.s;	</span><br><span class="line">		<span class="keyword">int</span> num = p.sum;<span class="comment">//取出当前状态</span></span><br><span class="line">		<span class="keyword">if</span> (num &gt; <span class="number">10</span>) <span class="keyword">continue</span>;<span class="comment">//判断当前步数是否&gt;10</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; tot;++i) &#123;<span class="comment">//循环判断</span></span><br><span class="line">			<span class="built_in">string</span> a1 = ma[i].first,b1 = ma[i].second;</span><br><span class="line">			<span class="keyword">if</span> (now.find(a1) != <span class="built_in">std</span>::<span class="built_in">string</span>::npos) &#123;<span class="comment">//如果能找到</span></span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">size_t</span> j = now.find(a1);j != <span class="built_in">std</span>::<span class="built_in">string</span>::npos;j = now.find(a1,j+<span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="comment">//上行代码有几个点要讲解的：1.使用size_t是因为string::npos是size_t的，如果不懂什么意思可以把它当作unsigned long long(有大佬说系统位数是32位这个值会变成unsigned int)来看待 2.前面一个find是找到最开始串里有没有这个最初的串，后面是在这个变换完的串之后看是否还有可以变换的</span></span><br><span class="line">					<span class="built_in">string</span> t = now;</span><br><span class="line">					t.replace(j,a1.length(),b1);<span class="comment">//将可以变换的变换为 b1</span></span><br><span class="line">					<span class="keyword">if</span> (t == b) &#123;<span class="built_in">cout</span> &lt;&lt; num+<span class="number">1</span>;<span class="keyword">return</span> ;&#125;<span class="comment">//如果找到了，可以直接退出</span></span><br><span class="line">					<span class="keyword">if</span> (t.length() &lt;= <span class="number">20</span>) &#123;<span class="comment">//判断字符串长度</span></span><br><span class="line">                        node pp = (node)&#123;t,num+<span class="number">1</span>&#125;;</span><br><span class="line">                        q.push(pp);</span><br><span class="line">                        se.insert(t);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"NO ANSWER!"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这份代码没什么问题，但是我们可以分析一下这个题目性质：</p>
<p>显然，一个串可以被几个不同的规则搜到，但是由于我们是 bfs 所以可以证明最开始搜到的那个情况是最优的，之后搜到的情况都可以直接舍弃。</p>
<p>所以，我们可以把用过的情况存在一个 <code>map</code> 里，如果这个情况搜过了就跳过。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (t.length() &lt;= <span class="number">20</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (se.find(t)==se.end())&#123;</span><br><span class="line">        node pp = (node)&#123;t,num+<span class="number">1</span>&#125;;</span><br><span class="line">        q.push(pp);</span><br><span class="line">        se.insert(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，你的代码就没什么问题了。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ri register int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">500001</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="built_in">string</span> s;<span class="keyword">int</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; &gt; ma;</span><br><span class="line"><span class="built_in">string</span> a,b,a1,b1;</span><br><span class="line"><span class="keyword">int</span> ans,cnt,tot;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> &lt;<span class="built_in">string</span>&gt; se;</span><br><span class="line"><span class="built_in">queue</span> &lt;node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	node s = (node)&#123;a,<span class="number">0</span>&#125;;</span><br><span class="line">	q.push(s);</span><br><span class="line">	<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">		node p = q.front();q.pop();</span><br><span class="line">		<span class="built_in">string</span> now = p.s;	</span><br><span class="line">		<span class="keyword">int</span> num = p.sum;</span><br><span class="line">		<span class="keyword">if</span> (num &gt; <span class="number">10</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; tot;++i) &#123;</span><br><span class="line">			<span class="built_in">string</span> a1 = ma[i].first,b1 = ma[i].second;</span><br><span class="line">			<span class="keyword">if</span> (now.find(a1) != <span class="built_in">std</span>::<span class="built_in">string</span>::npos) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">size_t</span> j = now.find(a1);j != <span class="built_in">std</span>::<span class="built_in">string</span>::npos;j = now.find(a1,j+<span class="number">1</span>)) &#123;</span><br><span class="line">					<span class="built_in">string</span> t = now;</span><br><span class="line">					t.replace(j,a1.length(),b1);</span><br><span class="line">					<span class="keyword">if</span> (t == b) &#123;<span class="built_in">cout</span>&lt;&lt;num+<span class="number">1</span>;<span class="keyword">return</span> ;&#125;</span><br><span class="line">					<span class="keyword">if</span> (t.length() &lt;= <span class="number">20</span>) &#123;</span><br><span class="line">						<span class="keyword">if</span> (se.find(t)==se.end())&#123;</span><br><span class="line">							node pp = (node)&#123;t,num+<span class="number">1</span>&#125;;</span><br><span class="line">							q.push(pp);</span><br><span class="line">							se.insert(t);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"NO ANSWER!"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; a1 &gt;&gt; b1) &#123;</span><br><span class="line">		ma.push_back(make_pair(a1,b1));</span><br><span class="line">		++tot;</span><br><span class="line">	&#125;</span><br><span class="line">	bfs();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>解题报告</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>搜索</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Luogu P4552 [Poetize6] IncDec Sequence 解题报告</title>
    <url>/2020/05/14/LuoguP4552/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.luogu.com.cn/problem/P4552" target="_blank" rel="noopener">P2132 IncDec Sequence</a></p>
<p>给定一个长度为 $n$ 的数列 ${a_1,a_2,\cdots,a_n}$，每次可以选择一个区间$[l,r]$，使这个区间内的数都加 $1$ 或者都减 $1$。 </p>
<p>请问至少需要多少次操作才能使数列中的所有数都一样，并求出在保证最少次数的前提下，最终得到的数列有多少种。</p>
</blockquote>
<a id="more"></a>
<p>一道有意思的差分题目，第一个问题相当于积木大赛，可以直接分析也可以根据差分性质来搞。<br>首先做 $a$ 数列的差分数列 $b$，那么问题就变成了使得$b_2…b_n = 0$<br>首先考虑配对一个正数一个负数 这样操作次数是最少的 首先考虑这种<br>这种的操作次数为 $\min(p,q)$ ($p,q$为差分数列正数和，负数和)</p>
<p>显然，这样会造成最后至多一个数没有消灭，此时可以将它与 $b_1$ 或者 $b_{n+1}$ 配对。<br>由于两种配对方式不同，会出现$|p-q|+1$种序列，并且最小次数为$|p-q|$<br>于是就解决了本题。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ri register int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span> &lt;&lt; <span class="number">20</span>], *p1, *p2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getchar() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1 &lt;&lt; 20, stdin), p1 == p2)?EOF: *p1++)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;t)</span> </span>&#123;</span><br><span class="line">	ri v = getchar();T f = <span class="number">1</span>;t = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(v)) &#123;<span class="keyword">if</span> (v == <span class="string">'-'</span>)f = <span class="number">-1</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(v)) &#123;t = t * <span class="number">10</span> + v - <span class="number">48</span>;v = getchar();&#125;</span><br><span class="line">	t *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;t,Args&amp;... args)</span> </span>&#123;</span><br><span class="line">		read(t);read(args...);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">min</span><span class="params">(T x,T y)</span> </span>&#123;<span class="keyword">return</span> x&lt;y?x:y;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">max</span><span class="params">(T x,T y)</span> </span>&#123;<span class="keyword">return</span> x&gt;y?x:y;&#125;</span><br><span class="line"></span><br><span class="line">ll a[N],b[N],n,p,q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) read(a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;++i) &#123;b[i] = a[i]-a[i<span class="number">-1</span>];<span class="keyword">if</span> (b[i] &gt; <span class="number">0</span>)p+=b[i];<span class="keyword">else</span> q -=b[i];&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n%lld"</span>,max(p,q),<span class="built_in">abs</span>(p-q)+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title>ACWing 95 费解的开关 解题报告</title>
    <url>/2020/04/07/hardsolvedswitch/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.acwing.com/problem/content/97/" target="_blank" rel="noopener">费解的开关</a></p>
<p>给你一个 $5\times 5$ 的方格，每次操作可以改变上下左右中五个格子，给定始状态，判断是否可能在6步以内使所有的灯都变亮。</p>
</blockquote>
<a id="more"></a>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>这道题目首先看，我们就知道必然与位运算有着密切的关系，因为出现了0和1，这是一个重要的发现.</p>
<p>接着我们在仔细分析题意，我们知道如果纯暴力枚举的话，必然是会超时的，那么如何优化呢？</p>
<p>我们需要从题目中找出非常有用的性质来优化，这是一个大致的思路方向。</p>
<p>每一个位置顶多只会操作一次。因为如果操作两次的话，相当于不操作，必然是不满足最优解。</p>
<p>在一套方案中，操作的顺序无关紧要，这一个略加思索便可得知。</p>
<p>最重要的性质，如果我们确定了第I行的操作方案的话，那么后面的行数都可以依此递推，下面给出一个详细的解答。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11011</span><br><span class="line">10110</span><br><span class="line">01111</span><br><span class="line">11111</span><br></pre></td></tr></table></figure>
<p>比如说这个例子，如果我们确定了第1行，那么第二行所有的0(坐标：$a_{i,j}$)  </p>
<p>都只能是第三行 $a_{i+1,j}$ 来修改了，因为如果你第二行修改的话，那么第一行将会打乱，下面每一行依此类推。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">char</span> a[N][N];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[<span class="number">5</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,dy[<span class="number">5</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> ax = x + dx[i],ay = y + dy[i];</span><br><span class="line">		<span class="keyword">if</span> (ax &lt; <span class="number">0</span> || ax &gt; <span class="number">4</span> || ay &lt; <span class="number">0</span> || ay &gt; <span class="number">4</span>) <span class="keyword">continue</span>;</span><br><span class="line">		a[ax][ay] ^= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> success = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[<span class="number">4</span>][i] == <span class="string">'0'</span>) &#123;</span><br><span class="line">			success = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">233333333</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; <span class="number">1</span>&lt;&lt;<span class="number">5</span>;++k) &#123;</span><br><span class="line">		<span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">char</span> b[N][N];</span><br><span class="line">		<span class="built_in">memcpy</span>(b,a,<span class="keyword">sizeof</span>(a));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (k &gt;&gt; i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">				step++;</span><br><span class="line">				change(<span class="number">0</span>,i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">5</span>;++j) &#123;</span><br><span class="line">				<span class="keyword">if</span> (a[i][j] == <span class="string">'0'</span>) &#123;</span><br><span class="line">					step++;</span><br><span class="line">					change(i+<span class="number">1</span>,j);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (check()) &#123;</span><br><span class="line">			ans = min(ans,step);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">memcpy</span>(a,b,<span class="keyword">sizeof</span>(b));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ans &lt;= <span class="number">6</span>) <span class="keyword">return</span> ans;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T = read();</span><br><span class="line">	<span class="keyword">while</span> (T -- ) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;++i) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,work());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>解题报告</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>Luogu P2169 正则表达式 解题报告</title>
    <url>/2019/10/11/sol-P2169/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.luogu.org/problem/P2169" target="_blank" rel="noopener">P2169 正则表达式</a><br>在Internet网络中的每台电脑并不是直接一对一连通的，而是某些电脑之间存在单向的网络连接，也就是说存在A到B的连接不一定存在B到A的连接，并且有些连接传输速度很快，有些则很慢，所以不同连接传输所花的时间是有大有小的。另外，如果存在A到B的连接的同时也存在B到A的连接的话，那么A和B实际上处于同一局域网内，可以通过本地传输，这样花费的传输时间为0。</p>
<p>现在小Z告诉你整个网络的构成情况，他希望知道从他的电脑（编号为1），到小X的电脑（编号为n）所需要的最短传输时间。</p>
<p>对于100%的数据，$1\leq n\leq200000, 1\leq m\leq 1000000$</p>
</blockquote>
<a id="more"></a>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>Tarjan 缩点 + SPFA/DP </p>
<p>首先观察数据范围，显然这么大的 $n,m$ ，直接跑 $O(nm)$ 的 SPFA 会炸掉。</p>
<p>观察题面，发现如果有 x 和 y 构成一个环（处在同一个 SCC 中），那么他们之间的边长度为 0 </p>
<p>这启发我们可以用缩点后再来跑 SPFA ，但是这样的复杂度是不够严谨的，最坏情况下仍旧是 $O(nm)$ 的，只是由于这题水所以可以过。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>SPFA 版本 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> v = getchar();<span class="keyword">int</span> x = <span class="number">0</span>,f = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(v)) &#123;<span class="keyword">if</span> (v == <span class="string">'-'</span>)f = <span class="number">-1</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(v)) &#123;x = x * <span class="number">10</span> + v - <span class="number">48</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">5000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> to[M],hd[N],nxt[M],tot,edg[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span>&#123;to[++tot] = v;edg[tot] = w;nxt[tot] = hd[u];hd[u] = tot;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> x&lt;y?x:y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> x&gt;y?x:y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">stack</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],ins[N],cnt,num,c[N],n,m,p[N],f[N];</span><br><span class="line"><span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	dfn[x] = low[x] = ++cnt;</span><br><span class="line">	s.push(x);ins[x] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = hd[x];i;i = nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!dfn[to[i]]) &#123;</span><br><span class="line">			tarjan(to[i]);</span><br><span class="line">			low[x] = min(low[x],low[to[i]]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ins[to[i]]) &#123;</span><br><span class="line">			low[x] = min(low[x],dfn[to[i]]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dfn[x] == low[x]) &#123;</span><br><span class="line">		c[x] = ++num;<span class="keyword">int</span> y;</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			y = s.top(),s.pop();</span><br><span class="line">			ins[y] = <span class="number">0</span>;c[y] = num;</span><br><span class="line">		&#125;<span class="keyword">while</span> (x != y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> vis[N],dis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">	<span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	vis[s] = <span class="number">1</span>;dis[s] = <span class="number">0</span>;</span><br><span class="line">	q.push(s);</span><br><span class="line">	<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = q.front();q.pop();</span><br><span class="line">		vis[x] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = hd[x];i;i = nxt[i]) &#123;</span><br><span class="line">			<span class="keyword">int</span> y = to[i],w = edg[i];</span><br><span class="line">			<span class="keyword">if</span> (c[x] == c[y]) w = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (dis[y] &gt; dis[x] + w) &#123;</span><br><span class="line">				dis[y] = dis[x] + w;</span><br><span class="line">				<span class="keyword">if</span> (!vis[y]) &#123;</span><br><span class="line">					q.push(y);</span><br><span class="line">					vis[y] = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = read(),m = read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = read(),y = read(),w = read();add(x,y,w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) <span class="keyword">if</span> (!dfn[i]) tarjan(i);</span><br><span class="line">	SPFA(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,dis[n]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>解题报告</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>Tarjan</tag>
        <tag>缩点</tag>
      </tags>
  </entry>
  <entry>
    <title>解题报告 AcWing 102. 最佳牛围栏</title>
    <url>/2020/05/22/untitled-1590155596986/</url>
    <content><![CDATA[<blockquote>
<p>给你一个长度为 $n$ 的数列，求出这个数列的平均数最大且长度不小于$L$的连续子段。 </p>
</blockquote>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先思考一下怎么快速的求一个子序列平均数最大的问题：<br>在一个数列$a_1…a_n$中，求一个平均数最大的连续子段。<br>我们可以观察到一个性质：设$a$的平均数为$p$<br>则$a_i = p + (a_i-p)$，令 $b_i = a_i - p$ 显然有 $\sum^n_{i=1} b_i = 0$<br>所以我们可以利用$b_i$来判断是否为真正的平均数。<br>若$\sum^n_{i=1} b_i &lt; 0$，说明 $p$ 比真正的平均数大了。<br>若$\sum^n_{i=1} b_i &gt; 0$，说明 $p$ 比真正的平均数小了。<br>而我们可以发现，最终的答案 $p$ 具有单调性：<br>设当前结果为$s$，若$s &lt; p$，一定有更大的平均值<br>若$s &gt; p$，则它的长度就是错的。<br>所以我们可以简单的利用上面两个结论进行二分答案。<br>回归题目，我们发现，如果要让 $p$ 最大，则要找到一个 $\sum^r_{i=l}$ 最大的字段。<br>问题就被转化为了求一个数列的长度不小于$L$的最大子段和。<br>$O(n)$ 求最大子段和显然不用我多讲，加上一个限制也并不难推导。<br>因为当前位置的答案只能由之前$1…i-L$的答案来得出，也就是说，随着$i$的增长，我们的决策集合每次只会增大1，开个变量随便维护下就完了。<br>这里借用lyd老师的柿子，$sum_i$表示$i$的前缀和。</p>
<script type="math/tex; mode=display">\max_{i-j\geq L} \{a_{j+1}+...+a_i\} = \max_{L\leq i\leq n} \{sum_i - \min_{0\leq j \leq i-L} sum_j\}</script><p>这里就涵盖了一个化归的思想，巧妙地将难题转化为了一个见过的题目。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ri register int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">min</span><span class="params">(T x,T y)</span> </span>&#123;<span class="keyword">return</span> x&lt;y?x:y;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">max</span><span class="params">(T x,T y)</span> </span>&#123;<span class="keyword">return</span> x&gt;y?x:y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">double</span> a[N],sum[N],b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) &#123;</span><br><span class="line">        b[i] = a[i] - mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) &#123;</span><br><span class="line">        sum[i] = sum[i<span class="number">-1</span>] + b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> minn = <span class="number">1e10</span>,maxx = <span class="number">-1e10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m;i &lt;= n;++i) &#123;</span><br><span class="line">        minn = min(minn,sum[i-m]);</span><br><span class="line">        maxx = max(maxx,sum[i]-minn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (maxx &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">double</span> l = <span class="number">-1e6</span>,r = <span class="number">1e6</span>;</span><br><span class="line">    <span class="keyword">while</span> (r-l &gt; eps) &#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">int</span>(r*<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>板子们</title>
    <url>/2019/08/11/%E5%9B%BE%E8%AE%BA%E6%9D%BF%E5%AD%90/</url>
    <content><![CDATA[<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ri register int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span> &lt;&lt; <span class="number">20</span>], *p1, *p2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getchar() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1 &lt;&lt; 20, stdin), p1 == p2)?EOF: *p1++)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;t)</span> </span>&#123;</span><br><span class="line">	ri v = getchar();T f = <span class="number">1</span>;t = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(v)) &#123;<span class="keyword">if</span> (v == <span class="string">'-'</span>)f = <span class="number">-1</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(v)) &#123;t = t * <span class="number">10</span> + v - <span class="number">48</span>;v = getchar();&#125;</span><br><span class="line">	t *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;t,Args&amp;... args)</span> </span>&#123;</span><br><span class="line">		read(t);read(args...);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">min</span><span class="params">(T x,T y)</span> </span>&#123;<span class="keyword">return</span> x&lt;y?x:y;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">max</span><span class="params">(T x,T y)</span> </span>&#123;<span class="keyword">return</span> x&gt;y?x:y;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="存图"><a href="#存图" class="headerlink" title="存图"></a>存图</h2><p>前向星存图，<strong>尽量不用</strong>结构体，<strong>绝对不用</strong>vector<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> hd[N],edg[M],nxt[M],to[M],tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">	edg[++tot] = w;to[tot] = v;nxt[tot] = hd[u];hd[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">	add(u,v,w);add(v,u,w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><p>带堆优化，时间复杂度$O(n\log n)$，在正权图以及<del>SPFA被卡</del>的情况适用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> dis,num;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;a,<span class="keyword">const</span> node &amp;b) &#123;</span><br><span class="line">		<span class="keyword">return</span> a.dis &gt; b.dis;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[N],n,m,s;</span><br><span class="line"><span class="keyword">bool</span> vis[N],hasfuhuan;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">	priority_queue &lt;node&gt; heap;</span><br><span class="line">	<span class="built_in">memset</span>(dis,INF,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">	heap.push((node)&#123;dis[s] = <span class="number">0</span>,s&#125;);</span><br><span class="line">	<span class="keyword">while</span> (!heap.empty()) &#123;</span><br><span class="line">		node p = heap.top();heap.pop();</span><br><span class="line">		<span class="keyword">int</span> x = p.num;</span><br><span class="line">		<span class="keyword">if</span> (vis[x]) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		vis[x] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = hd[x];i;i = nxt[i]) &#123;</span><br><span class="line">			<span class="keyword">int</span> y = to[i],w = edg[i];</span><br><span class="line">			<span class="keyword">if</span> (dis[y] &gt; dis[x] + w) &#123;</span><br><span class="line">				dis[y] = dis[x] + w;</span><br><span class="line">				<span class="keyword">if</span> (!vis[y]) &#123;</span><br><span class="line">					heap.push((node)&#123;dis[y],y&#125;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h3><p>最坏时间复杂度$O(nm)$，在<strong>证明不会被卡</strong>的时候用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	vis[s] = <span class="number">1</span>;dis[s] = <span class="number">0</span>;</span><br><span class="line">	q.push(s);</span><br><span class="line">	<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = q.front();q.pop();</span><br><span class="line">		vis[x] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = hd[x];i;i = nxt[i]) &#123;</span><br><span class="line">			<span class="keyword">int</span> y = to[i],w = edg[i];</span><br><span class="line">			<span class="keyword">if</span> (dis[y] &gt; dis[x] + w) &#123;</span><br><span class="line">				dis[y] = dis[x] + w;</span><br><span class="line">				<span class="keyword">if</span> (!vis[y]) &#123;</span><br><span class="line">					q.push(y);</span><br><span class="line">					vis[y] = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h3><p>稳定时间复杂度$O(nm)$，判负环用 <del>因为不会SPFA判负环</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bellman_Ford</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis,INF,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">	dis[s] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>,flag = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (flag) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;++i) &#123;</span><br><span class="line">			flag = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">int</span> u = edges[i].u,v = edges[i].v,w = edges[i].w;</span><br><span class="line">			<span class="keyword">if</span> (dis[v] &gt; dis[u] + w) &#123;</span><br><span class="line">				dis[v] = dis[u] + w;</span><br><span class="line">				flag = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (++cnt &gt; n) &#123;</span><br><span class="line">				hasfuhuan = <span class="number">1</span>;</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p><del>菜的要死只会Kruskal</del></p>
<h3 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h3><p>并查集+排序 时间复杂度$O(m\log m)$，对于边数较少的图适用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Union-Find Set</span></span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> f[x] == x ? f[x]:f[x] = find(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Kruskal</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> u,v,w;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> edge &amp;a,<span class="keyword">const</span> edge &amp;b) &#123;</span><br><span class="line">		<span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tot = <span class="number">0</span>,ans = <span class="number">0</span>;</span><br><span class="line">	sort(edges+<span class="number">1</span>,edges+<span class="number">1</span>+n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> u = edges[i].u,v = edges[i].v,w = edges[i].w;</span><br><span class="line">		<span class="keyword">if</span> (find(u) != find(v)) &#123;</span><br><span class="line">			ans += w;</span><br><span class="line">			++tot;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (tot == n<span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>用来<del>巧妙</del>求解DAGdp等，利用BFS实现，同样可以用DFS实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">toposort</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!cnt[i]) q.push(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> u = q.front();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = hd[u];i;i = nxt[i]) &#123;</span><br><span class="line">			<span class="keyword">int</span> v = to[i];</span><br><span class="line">			<span class="keyword">if</span> (--cnt[v] == <span class="number">0</span>) &#123;</span><br><span class="line">				q.push(v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树链剖分"><a href="#树链剖分" class="headerlink" title="树链剖分"></a>树链剖分</h2><p><del>树链剖分这个OIer很强</del></p>
<p>快速求解树上问题，具体应用请看<a href="https://www.zzlblog.ga/2019/08/26/树链剖分 学习笔记/">树链剖分 学习笔记</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> dfn[N],top[N],siz[N],son[N],dep[N],fat[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">	son[u] = <span class="number">0</span>;</span><br><span class="line">	siz[u] = <span class="number">1</span>;</span><br><span class="line">	dep[u] = dep[f] + <span class="number">1</span>;</span><br><span class="line">	fat[u] = f;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = hd[u];i;i = nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">int</span> v = to[i],w = edg[i];</span><br><span class="line">		<span class="keyword">if</span> (v != f) &#123;</span><br><span class="line">			dfs(v,u);</span><br><span class="line">			siz[u] += siz[v];</span><br><span class="line">			<span class="keyword">if</span> (siz[v] &gt; siz[son[u]]) &#123;</span><br><span class="line">				son[u] = v;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">	dfn[u] = ++cnt;</span><br><span class="line">	<span class="keyword">if</span> (u == son[f]) &#123;</span><br><span class="line">		top[u] = top[f];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		top[u] = u;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (son[u]) &#123;</span><br><span class="line">		dfs2(son[u],u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = hd[u];i;i = nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">int</span> v = to[i],w = edg[i];</span><br><span class="line">		<span class="keyword">if</span> (v != f &amp;&amp; v != son[u]) &#123;</span><br><span class="line">			dfs2(v,u);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>MST</tag>
        <tag>并查集</tag>
        <tag>拓扑排序</tag>
        <tag>最短路</tag>
        <tag>负环</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>树链剖分 学习笔记</title>
    <url>/2019/08/26/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><del>树链剖分是个很强的 OIer</del></p>
<p>树链剖分是用来解决一系列树上问题的利器。<br><a id="more"></a></p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>链：树上不拐弯的一条路径</li>
<li>重儿子：子树大小最大的儿子</li>
<li>轻儿子：其他儿子</li>
<li>重链：由重儿子组成的链</li>
</ul>
<h2 id="结果和过程"><a href="#结果和过程" class="headerlink" title="结果和过程"></a>结果和过程</h2><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>这是原树</p>
<p><img src="https://s2.ax1x.com/2019/08/25/m2dRDe.png" alt=""></p>
<p>剖分之后的树</p>
<p><img src="https://s2.ax1x.com/2019/08/25/m2wsaj.png" alt=""></p>
<p>这里，<strong>红色的边</strong>构成重链，<strong>蓝色的点</strong>为重儿子，<strong>绿色的点</strong>为轻儿子。</p>
<p>注意，这里的 7 号与 8 号节点子树大小相同，因此我们选择<strong>编号靠前</strong>的儿子为重儿子。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>一般来说，树链剖分通过两遍 dfs 来实现。</p>
<h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">siz[x] <span class="comment">//子树x的大小</span></span><br><span class="line">top[x] <span class="comment">//x所在链的顶端</span></span><br><span class="line">fat[x] <span class="comment">//x的父亲</span></span><br><span class="line">dep[x] <span class="comment">//x的深度</span></span><br><span class="line">son[x] <span class="comment">//x的重儿子</span></span><br></pre></td></tr></table></figure>
<p>第一遍 dfs ，我们先处理出每个节点的<strong>父亲</strong>，<strong>深度</strong>，<strong>子树大小</strong>，<strong>重儿子</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">	siz[u] = <span class="number">1</span>;</span><br><span class="line">	dep[u] = dep[f] + <span class="number">1</span>;</span><br><span class="line">	son[u] = <span class="number">0</span>;</span><br><span class="line">	fat[u] = f;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = hd[u];i;i= nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">int</span> v = to[i];</span><br><span class="line">		<span class="keyword">if</span> (v != f) &#123;</span><br><span class="line">			dfs1(v,u);</span><br><span class="line">			siz[u] += siz[v];</span><br><span class="line">			<span class="keyword">if</span> (siz[v] &gt; siz[son[u]]) &#123;</span><br><span class="line">				son[u] = v;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二遍 dfs，我们处理出每条链<strong>链顶的节点</strong>，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (son[f] == u) &#123;</span><br><span class="line">		top[u] = top[f];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		top[u] = u;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (son[u]) &#123;</span><br><span class="line">		dfs2(son[u],u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = hd[u];i;i = nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">int</span> v = to[i];</span><br><span class="line">		<span class="keyword">if</span> (v != f &amp;&amp; v != son[u]) &#123;</span><br><span class="line">			dfs2(v,u);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样树链剖分的基本结构就写完辣！<del>是不是很简单</del></p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="LCA"><a href="#LCA" class="headerlink" title="LCA"></a>LCA</h4><p>显然，我们可以发现，在一条重链上的两个节点的 LCA 显然就是深度更浅的那个节点。</p>
<p>所以我们可以先将两个节点跳到同一条链上，求出深度浅的那个节点即可，于是有了如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tx = top[x],ty = top[y]</span><br><span class="line">	<span class="keyword">while</span> (tx != ty) &#123;</span><br><span class="line">		<span class="keyword">if</span> (dep[x] &gt; dep[y]) &#123;</span><br><span class="line">			swap(x,y);</span><br><span class="line">		&#125;</span><br><span class="line">		x = fat[top[x]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (x &lt; y) ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度$O(\log{n})$</p>
<p>例题：<a href="https://www.luogu.org/problem/P3379" target="_blank" rel="noopener">板子题</a></p>
<p>随手套个板子写掉。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = N &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> v = getchar();<span class="keyword">int</span> x = <span class="number">0</span>,f = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(v)) &#123;<span class="keyword">if</span> (v == <span class="string">'-'</span>)f = <span class="number">-1</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(v)) &#123;x = x * <span class="number">10</span> + v - <span class="number">48</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> hd[N],edg[M],nxt[M],to[M],n,m,tot,cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">	to[++tot] = v;edg[tot] = w;nxt[tot] = hd[u];hd[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">	add(u,v,w);add(v,u,w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[N],top[N],fat[N],siz[N],son[N],end[N],dep[N],s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">	son[s] = <span class="number">0</span>;</span><br><span class="line">	dep[s] = dep[f] + <span class="number">1</span>;</span><br><span class="line">	siz[s] = <span class="number">1</span>;</span><br><span class="line">	fat[s] = f;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = hd[s];i;i = nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (to[i] != f) &#123;</span><br><span class="line">			dfs1(to[i],s);</span><br><span class="line">			siz[s] += siz[to[i]];</span><br><span class="line">			<span class="keyword">if</span> (siz[to[i]] &gt; siz[son[s]]) &#123;</span><br><span class="line">				son[s] = to[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">	dfn[u] = ++cnt;</span><br><span class="line">	<span class="keyword">if</span> (u == son[f]) &#123;</span><br><span class="line">		top[u] = top[f];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		top[u] = u;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (son[u]) &#123;</span><br><span class="line">		dfs2(son[u],u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = hd[u];i;i = nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">int</span> v = to[i];</span><br><span class="line">		<span class="keyword">if</span> (v != f &amp;&amp; v != son[u]) &#123;</span><br><span class="line">			dfs2(v,u);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	end[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tx = top[x],ty = top[y]</span><br><span class="line">    <span class="keyword">while</span> (tx != ty) &#123;</span><br><span class="line">		<span class="keyword">if</span> (dep[x] &gt; dep[y]) &#123;</span><br><span class="line">			swap(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        x = fat[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (x &lt; y) ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = read(),m = read(),s = read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> u = read(),v = read(),w = <span class="number">1</span>;</span><br><span class="line">		addedge(u,v,w);</span><br><span class="line">	&#125;</span><br><span class="line">	dfs1(s,<span class="number">0</span>);</span><br><span class="line">	dfs2(s,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> u = read(),v = read();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,lca(u,v));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="链上修改，子树修改"><a href="#链上修改，子树修改" class="headerlink" title="链上修改，子树修改"></a>链上修改，子树修改</h4><p>这里就必须引出一个新东西了：dfs 序</p>
<p>指的是第几次 dfs 遍历到的这个节点</p>
<p>定义数组<code>dfn[x]</code>为节点 x 的 dfs 序。</p>
<p>我们可以在 <code>dfs2</code> 中顺手维护一下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">	dfn[u] = ++cnt;</span><br><span class="line">	<span class="keyword">if</span> (son[f] == u) &#123;</span><br><span class="line">		top[u] = top[f];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		top[u] = u;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (son)</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = hd[u];i;i = nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">int</span> v = to[i];</span><br><span class="line">		<span class="keyword">if</span> (v != f) &#123;</span><br><span class="line">			dfs2(v,u);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	end[cnt] = u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里给出每个节点加上 <code>dfn</code> 的图</p>
<p><img src="https://s2.ax1x.com/2019/08/25/m2vk9J.png" alt=""></p>
<p>我们可以发现，在每棵<strong>子树</strong>，每条<strong>链</strong>上的dfn都是连续的！</p>
<p>这样看可能不太明朗，我们把它转化成区间来看（这里是子树的，链同理）</p>
<p><img src="https://s2.ax1x.com/2019/08/25/m2vA39.png" alt=""></p>
<p>所以我们就可以利用数据结构维护一下节点了。</p>
<p>对子树修改就是 <code>change(dfn[x],dfn[x]+siz[x]-1)</code></p>
<p>链上修改就是 <code>change(dfn[x],dfn[y])</code></p>
<p>这里的核心思想是：将树上问题转化成序列问题来处理</p>
<p>例题：<a href="https://www.luogu.org/problem/P2590" target="_blank" rel="noopener">[ZJOI2008]树的统计</a></p>
<p>用线段树维护最大值最小值。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = N &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> v = getchar();<span class="keyword">int</span> x = <span class="number">0</span>,f = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(v)) &#123;<span class="keyword">if</span> (v == <span class="string">'-'</span>)f = <span class="number">-1</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(v)) &#123;x = x * <span class="number">10</span> + v - <span class="number">48</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> to[M],hd[N],nxt[M],tot;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	to[++tot] = v;nxt[tot] = hd[u];hd[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	add(u,v);add(v,u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[N],top[N],fat[N],siz[N],dep[N],son[N],rk[N],cnt,n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">	fat[u] = f;</span><br><span class="line">	dep[u] = dep[f] + <span class="number">1</span>;</span><br><span class="line">	son[u] = <span class="number">0</span>;</span><br><span class="line">	siz[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = hd[u];i;i = nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">int</span> v = to[i];</span><br><span class="line">		<span class="keyword">if</span> (v != f) &#123;</span><br><span class="line">			dfs1(v,u);</span><br><span class="line">			siz[u] += siz[v];</span><br><span class="line">			<span class="keyword">if</span> (siz[v] &gt; siz[son[u]]) &#123;</span><br><span class="line">				son[u] = v;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">	dfn[u] = ++cnt;rk[cnt] = u;</span><br><span class="line">	<span class="keyword">if</span> (son[f] == u) &#123;</span><br><span class="line">		top[u] = top[f];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		top[u] = u;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (son[u]) &#123;</span><br><span class="line">		dfs2(son[u],u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = hd[u];i;i = nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">int</span> v = to[i];</span><br><span class="line">		<span class="keyword">if</span> (v != f &amp;&amp; v != son[u]) &#123;</span><br><span class="line">			dfs2(v,u);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> l,r,big,sum;</span><br><span class="line">&#125;tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	tree[p].l = l;tree[p].r = r;</span><br><span class="line">	<span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">		tree[p].big = tree[p].sum = num[rk[l]];</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	build(p &lt;&lt; <span class="number">1</span>,l,mid);</span><br><span class="line">	build(p &lt;&lt; <span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">	tree[p].sum = tree[p&lt;&lt;<span class="number">1</span>].sum + tree[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">	tree[p].big = max(tree[p&lt;&lt;<span class="number">1</span>].big,tree[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].big);</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (tree[p].l == tree[p].r) &#123;</span><br><span class="line">		tree[p].sum = tree[p].big = v;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid = (tree[p].l + tree[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (x &lt;= mid) modify(p&lt;&lt;<span class="number">1</span>,x,v);</span><br><span class="line">	<span class="keyword">if</span> (x &gt; mid) modify(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,v);</span><br><span class="line">	tree[p].sum = tree[p&lt;&lt;<span class="number">1</span>].sum + tree[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">	tree[p].big = max(tree[p&lt;&lt;<span class="number">1</span>].big,tree[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].big);</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">querym</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (tree[p].l &gt;= x &amp;&amp; tree[p].r &lt;= y) &#123;</span><br><span class="line">		<span class="keyword">return</span> tree[p].big;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid = (tree[p].l + tree[p].r) &gt;&gt; <span class="number">1</span>,ans = -INF;</span><br><span class="line">	<span class="keyword">if</span> (x &lt;= mid) &#123;</span><br><span class="line">		ans = max(ans,querym(p&lt;&lt;<span class="number">1</span>,x,y));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (y &gt; mid) &#123;</span><br><span class="line">		ans = max(ans,querym(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,y));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">querys</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (tree[p].l &gt;= x &amp;&amp; tree[p].r &lt;= y) &#123;</span><br><span class="line">		<span class="keyword">return</span> tree[p].sum;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid = (tree[p].l + tree[p].r) &gt;&gt; <span class="number">1</span>,ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (x &lt;= mid) &#123;</span><br><span class="line">		ans += querys(p&lt;&lt;<span class="number">1</span>,x,y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (y &gt; mid) &#123;</span><br><span class="line">		ans += querys(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">	modify(<span class="number">1</span>,dfn[u],t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qmax</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = -INF;</span><br><span class="line">	<span class="keyword">while</span> (top[u] != top[v]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (dep[top[u]] &lt; dep[top[v]]) &#123;</span><br><span class="line">			swap(u,v);</span><br><span class="line">		&#125;</span><br><span class="line">		ans = max(ans,querym(<span class="number">1</span>,dfn[top[u]],dfn[u]));</span><br><span class="line">		u = fat[top[u]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dep[u] &gt; dep[v]) &#123;</span><br><span class="line">		swap(u,v);</span><br><span class="line">	&#125;</span><br><span class="line">	ans = max(ans,querym(<span class="number">1</span>,dfn[u],dfn[v]));</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qsum</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (top[u] != top[v]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (dep[top[u]] &lt; dep[top[v]]) &#123;</span><br><span class="line">			swap(u,v);</span><br><span class="line">		&#125;</span><br><span class="line">		ans += querys(<span class="number">1</span>,dfn[top[u]],dfn[u]);</span><br><span class="line">		u = fat[top[u]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dep[u] &gt; dep[v]) &#123;</span><br><span class="line">		swap(u,v);</span><br><span class="line">	&#125;</span><br><span class="line">	ans += querys(<span class="number">1</span>,dfn[u],dfn[v]);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;++i) &#123;</span><br><span class="line">		addedge(read(),read());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) &#123;</span><br><span class="line">		num[i] = read();</span><br><span class="line">	&#125;</span><br><span class="line">	dfs1(<span class="number">1</span>,<span class="number">0</span>);dfs2(<span class="number">1</span>,<span class="number">0</span>);build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">int</span> m = read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;++i) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">		<span class="keyword">int</span> u = read(),v = read();</span><br><span class="line">		<span class="keyword">if</span> (s == <span class="string">"CHANGE"</span>) &#123;</span><br><span class="line">			change(u,v);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (s == <span class="string">"QSUM"</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,qsum(u,v));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (s == <span class="string">"QMAX"</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,qmax(u,v));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="傻逼好题推荐"><a href="#傻逼好题推荐" class="headerlink" title="傻逼好题推荐"></a><del>傻逼</del>好题推荐</h2><p><a href="https://www.luogu.org/problem/P4114" target="_blank" rel="noopener">Qtree </a>把边权变成点权，巧妙的做法</p>
<p><a href="https://www.luogu.org/problem/P3178" target="_blank" rel="noopener">[HAOI2015]树上操作</a> 练手，区间修改，区间查询</p>
<p><a href="https://www.luogu.org/problem/P3258" target="_blank" rel="noopener">[JLOI2014]松鼠的新家</a> 巧妙的做法，也可以用树上差分来写</p>
<p><a href="https://www.luogu.org/problem/P2146" target="_blank" rel="noopener">[NOI2015]程序包管理器</a> 稍微转换一下问题</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>感谢 <a href="zgjjj.github.io">$\color{black}z\color{red}{gjjj}$</a> 给我提供了极大的帮助，感谢 <a href="yousiki.github.io">$\color{black}Y\color{red}{ouSiKi}$</a> 的教导</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>树链剖分</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>Luogu 1417 烹调方案 解题报告</title>
    <url>/2019/09/22/Luogu1417/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.luogu.org/problem/P1417" target="_blank" rel="noopener">烹调方案</a></p>
<p>一共有$n$件食材，每件食材有三个属性， $a_i$ ， $b_i$ 和 $c_i$ ，如果在 $t$ 时刻完成第 $i$ 样食材则得到 $a_i-t*b_i$ 的美味指数，用第 $i$ 件食材做饭要花去 $c_i$ 的时间。</p>
<p>在 $T$ 时间内设计烹调方案使得美味指数最大</p>
</blockquote>
<a id="more"></a>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>显然是一个01背包，但是，当你写完01背包板子交上去以后会发现只有30分。  </p>
<p>题目中给了一个条件：在 $t$ 时刻完成第 $i$ 样食材则得到 $a_i-t*b_i$ 的美味指数，有了这个条件，显然我们要对每个物品选择的先后性进行讨论了。</p>
<p>设 $a_1,b_1,c_1$ 为第一组物品，$a_2,b_2,c_2$ 为第二组物品， $t$为当前时间.</p>
<p>将两个物品可获得的值表示出来为：</p>
<script type="math/tex; mode=display">
m_1 = a_1-(t \times c_1) \times b_1 + a_2 - (t+c_1+c_2) \times b_2</script><script type="math/tex; mode=display">
m_2 = a_2-(t \times c_2) \times b_2 + a_1 - (t+c_1+c_2) \times b_1</script><p>设 $m_1 &gt; m_2$ 得</p>
<script type="math/tex; mode=display">
a_1-(t \times c_1) \times b_1 + a_2 - (t+c_1+c_2) \times b_2   > m_2 = a_2-(t \times c_2) \times b_2 + a_1 - (t+c_1+c_2) \times b_1</script><p>拆项得</p>
<script type="math/tex; mode=display">
a_1-b_1t-b_1c_1+a_2-b_2t-b_2c_1-b_2c_2>a_2-b_2t-b_2c_2+a_1-b_1t-b_1c_1-b_1c_2</script><p>化简得  </p>
<script type="math/tex; mode=display">
b_1c_2 > b_2c_1</script><p>由此，我们就得到了我们 sort 函数中cmp的写法。注意开 long long 这题就完了。</p>
<p>这题的关键就在此，我不知道是为什么，大部分题解中都没有给出自己的完整证明，这个证明也不难证，希望读者看完后可以自己证明一遍。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">500010</span>&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">0</span>,f = <span class="number">1</span>;<span class="keyword">char</span> v = getchar();</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(v)) &#123;<span class="keyword">if</span> (v ==<span class="string">'-'</span>) f = <span class="number">-1</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(v)) &#123;x = x * <span class="number">10</span> + v - <span class="number">48</span>;v = getchar();&#125;</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> f[N],n,m,ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> a,b,c;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;rhs,<span class="keyword">const</span> node &amp;rs) &#123;</span><br><span class="line">		<span class="keyword">return</span> rhs.b*rs.c &gt; rhs.c*rs.b;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;pre[N];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	m = read(),n = read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i)	pre[i].a = read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i)	pre[i].b = read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i)	pre[i].c = read();</span><br><span class="line">	sort(pre+<span class="number">1</span>,pre+<span class="number">1</span>+n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = m;j &gt;= pre[i].c;--j) &#123;</span><br><span class="line">			f[j] = max(f[j],f[j-pre[i].c] + (pre[i].a - j * pre[i].b));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;++i) &#123;</span><br><span class="line">		ans = max(ans,f[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>解题报告</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>背包</tag>
      </tags>
  </entry>
</search>
